import classes : 'Classes.ecore#/';
import classescs : 'ClassesCS.ecore#/';
import classescstraces : 'ClassesCS2AS.ecore#/';

transformation classescs2as
{
	check leftCS imports classescs;
	enforce rightAS imports classes;
	middle imports classescstraces;
}

map mClassCS2Class_LM in classescs2as
{
	guard:leftCS classCS : ClassCS;
	new:middle c2c : ClassCS2Class;
	set c2c.classCS := classCS;
}

map mRootCS2Root_LM in classescs2as
{
	guard:leftCS rootCS : RootCS;
	new:middle r2r : RootCS2Root;
	set r2r.rootCS := rootCS;
}

map mPackageCS2Package_LM in classescs2as
{
	guard:leftCS packageCS : PackageCS;
	new:middle p2p : PackageCS2Package;
	set p2p.packageCS := packageCS;
}

map mClassCS2Class_MR in classescs2as
{
	guard:middle c2c : ClassCS2Class;
	new:rightAS _'class' : Class;
	set c2c._'class' := _'class';
}

map mRootCS2Root_MR in classescs2as
{
	guard:middle r2r : RootCS2Root;
	new:rightAS root : Root;
	set r2r.root := root;
}

map mPackageCS2Package_MR in classescs2as
{
	guard:middle p2p : PackageCS2Package;
	new:rightAS _'package' : Package;
	set p2p._'package' := _'package';
}

map uClass_name in classescs2as
{
	guard:rightAS _'class' : Class;
	guard:leftCS classCS : ClassCS;
	check classCS.ClassCS2Class._'class' = _'class';
	set _'class'.name := classCS.name;
}

map uRoot_ownedPackages in classescs2as
{
	guard:rightAS root : Root;
	guard:leftCS rootCS : RootCS;
	check rootCS.RootCS2Root.root = root;
	set root.ownedPackages := rootCS.ownedPackages.PackageCS2Package._'package'->asOrderedSet();
}

map uPackage_name in classescs2as
{
	guard:rightAS _'package' : Package;
	guard:leftCS packageCS : PackageCS;
	check packageCS.PackageCS2Package._'package' = _'package';
	set	_'package'.name := packageCS.name;
}

map uPackage_ownedClasses in classescs2as
{
	guard:rightAS _'package' : Package;
	guard:leftCS packageCS : PackageCS;
	check packageCS.PackageCS2Package._'package' = _'package';
	set	_'package'.ownedClasses := packageCS.ownedClasses.ClassCS2Class._'class'->asOrderedSet();
}

map __root__ in classescs2as
{
	for packageCS : classescs::PackageCS in classescs::PackageCS.allInstances() {
		call mPackageCS2Package_LM {
			packageCS iterates packageCS;
		}
	}
	for p2p : classescstraces::PackageCS2Package in classescstraces::PackageCS2Package.allInstances() {
		call mPackageCS2Package_MR {
			p2p iterates p2p;
		}
	}
	for _'package' : classes::Package in classes::Package.allInstances() {
		for packageCS : classescs::PackageCS in classescs::PackageCS.allInstances() {
			call uPackage_name {
				packageCS iterates packageCS;
				_'package' iterates _'package';
			}
		}
	}
	for _'package' : classes::Package in classes::Package.allInstances() {
		for packageCS : classescs::PackageCS in classescs::PackageCS.allInstances() {
			call uPackage_ownedClasses {
				packageCS iterates packageCS;
				_'package' iterates _'package';
			}
		}
	}
	for classCS : classescs::ClassCS in classescs::ClassCS.allInstances() {
		call mClassCS2Class_LM {
			classCS iterates classCS;
		}
	}
	for c2c : classescstraces::ClassCS2Class in classescstraces::ClassCS2Class.allInstances() {
		call mClassCS2Class_MR {
			c2c iterates c2c;
		}
	}
	for classCS : classescs::ClassCS in classescs::ClassCS.allInstances() {
		for _'class' : classes::Class in classes::Class.allInstances() {
			call uClass_name {
				_'class' iterates _'class';
				classCS iterates classCS;
			}
		}
	}
	for rootCS : classescs::RootCS in classescs::RootCS.allInstances() {
		call mRootCS2Root_LM {
			rootCS iterates rootCS;
		}
	}
	for r2r : classescstraces::RootCS2Root in classescstraces::RootCS2Root.allInstances() {
		call mRootCS2Root_MR {
			r2r iterates r2r;
		}
	}
	for rootCS : classescs::RootCS in classescs::RootCS.allInstances() {
		for root : classes::Root in classes::Root.allInstances() {
			call uRoot_ownedPackages {
				root iterates root;
				rootCS iterates rootCS;
			}
		}
	}
}