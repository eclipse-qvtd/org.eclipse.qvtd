/*******************************************************************************
 * Copyright (c) 2017 Willink Transformations and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v20.html
 *
 * Contributors:
 *     E.D.Willink - initial implementation
 *******************************************************************************/
import ecoreMM : 'http://www.eclipse.org/emf/2002/Ecore'; 
import pivotMM : 'http://www.eclipse.org/ocl/2015/Pivot';
--import extentMM : 'http://www.eclipse.org/qvt/2019/QVTruntimeLibrary';
import extentMM : 'platform:/resource/org.eclipse.qvtd.runtime/model-gen/QVTruntimeLibrary.ecore';
--import qvtlibMM : 'platform:/resource/org.eclipse.qvtd.pivot.qvtbase/model/QVTbaseLibrary.oclstdlib#/';
--import pivotMM : 'platform:/resource/org.eclipse.ocl.pivot/model/Pivot.ecore'::pivot;

package org::eclipse::ocl::pivot2::ecore2pivot {
/**
 * Transform an Ecore metamodel to a Pivot metamodel
 */
	transformation Ecore2Pivot(ecore:{extentMM,ecoreMM}, as:{extentMM,pivotMM})
	{
		/**
		 *  ecore::EAttribute <=> pivot::Property
		 */
		top relation mapEAttribute {
			eClass : ecoreMM::EClass;
			asClass : pivotMM::Class;
			name : String;
			enforce domain ecore eAttribute : EAttribute {
				eContainingClass = eClass,
				name = name
			};
			enforce domain as asProperty : Property {
				owningClass = asClass,
				name = name
			};
			when {
				mapEClass(eClass, asClass);
			}
			where {
				mapETypedElement_type(eAttribute, asProperty);
			}
		}
		
		/**
		 *  ecore::EClass <=> pivot::Class
		 */
		top relation mapEClass overrides mapEClassifier {
			ePackage : ecoreMM::EPackage;
			asPackage : pivotMM::Package;
			name : String;
			isAbstract : Boolean;
			isInterface : Boolean;
			enforce domain ecore eClass : EClass {
				ePackage = ePackage,
				name = name,
				abstract = isAbstract,
				interface = isInterface
			};
			enforce domain as asClass : Class {
				owningPackage = asPackage,
				name = name,
				isAbstract = isAbstract,
				isInterface = isInterface
			};
			when {
				mapEPackage(ePackage, asPackage);
			}
		}
		
		/**
		 *  ecore::EClassifier <=> pivot::Type
		 */
		top abstract relation mapEClassifier {
			enforce domain ecore eClassifier : EClassifier;
			enforce domain as asType : Type;
		}
		
		/**
		 *  ecore::EDataType <=> pivot::DataType
		 */
		top relation mapEDataType overrides mapEClassifier {
			ePackage : ecoreMM::EPackage;
			asPackage : pivotMM::Package;
			name : String;
			enforce domain ecore eDataType : EDataType {
				ePackage = ePackage,
				name = name
			};
			enforce domain as asDataType : DataType {
				owningPackage = asPackage,
				name = name
			};
			when {
				mapEPackage(ePackage, asPackage);
			}
		}
		
		/**
		 *  ecore::EPackage <=> pivot::Package
		 */
		top relation mapEPackage {
			name : String;
			nsPrefix : String;
			nsURI : String;
			enforce domain ecore ePackage : EPackage {
				eSuperPackage = null,
				extent = eExtent : extentMM::qvtruntimelibrary::Extent,
				name = name,
				nsPrefix = nsPrefix,
				nsURI = nsURI
			};
			enforce domain as asPackage : Package {
				Model = asModel : pivotMM::Model,
				name = name,
				nsPrefix = nsPrefix,
				URI = nsURI
			};
			when {
				mapEResource(eExtent, asModel);
			}
		}

		/**
		 *  ecore::EReference <=> pivot::Property
		 */
		top relation mapEReference {
			eClass : ecoreMM::EClass;
			asClass : pivotMM::Class;
			name : String;
			isComposite : Boolean;
			enforce domain ecore eReference : EReference {
				eContainingClass = eClass,
				name = name,
				containment = isComposite
			};
			enforce domain as asProperty : Property {
				owningClass = asClass,
				name = name,
				isComposite = isComposite
			};
			when {
				mapEClass(eClass, asClass);
			}
			where {
				mapETypedElement_type(eReference, asProperty);
			}
		}

		/**
		 *  ecore::EReference <=> pivot::Property
		 */
		top relation mapEReference_implicitOpposite {
			eTargetClass : ecoreMM::EClass;
			eContainingClass : ecoreMM::EClass;
			asContainingClass : pivotMM::Class;
			asOpposite : pivotMM::Property;
			asTargetType : pivotMM::Class;
			name : String;
			enforce domain ecore eReference : EReference {
				eContainingClass = eContainingClass,
				eType = eTargetClass,
				eOpposite = null
			};
			enforce domain as asProperty : Property {
				owningClass = asContainingClass,
				type = asTargetType,
				name = asTargetType.name,
				isImplicit = true,
				opposite = asOpposite
			};
			when {
				mapEClass(eTargetClass, asContainingClass);
				mapEClass(eContainingClass, asTargetType);
				mapEReference(eReference, asOpposite);
			}
		--	where {
		--		mapETypedElement_type(eReference, asProperty);
		--	}
		}
		
		top relation mapEResource {
			enforce domain ecore eExtent : extentMM::qvtruntimelibrary::Extent;
			enforce domain as asModel : pivotMM::Model {
				extent = asExtent : extentMM::qvtruntimelibrary::Extent
			};
		}

		/**
		 *  ecore::ETypedElement.type <=> pivot::TypedElement.type
		 */
		abstract relation mapETypedElement_type {
			enforce domain ecore eTypedElement : ETypedElement;
			enforce domain as asTypedElement: TypedElement;
		}
		relation mapETypedElement_type_unit overrides mapETypedElement_type {
			enforce domain ecore eTypedElement : ETypedElement {
				eType = eType : EClassifier
			} { eTypedElement.upperBound = 1};
			enforce domain as asTypedElement: TypedElement {
				type = asType : Type
			};
			when {
				mapEClassifier(eType, asType);
			}
		}
		relation mapETypedElement_type_collection overrides mapETypedElement_type {
			isOrdered : Boolean;
			isUnique : Boolean;
			asCollection : pivotMM::CollectionType;
			enforce domain ecore eTypedElement : ETypedElement {
				eType = eType : EClassifier,
				_'ordered' = isOrdered,
				_'unique' = isUnique
			} { eTypedElement.upperBound > 1};
			enforce domain as asTypedElement: TypedElement {
				type = asCollection
			};
			when {
			--	mapEClassifier(eType, asType);
				mapEClassifier_Collection(eType, isOrdered, isUnique, asCollection);
			}
		}
		abstract relation mapEClassifier_Collection {
			enforce domain ecore eType : EClassifier, isOrdered : Boolean, isUnique : Boolean;
			enforce domain as asCollection: CollectionType {
		--		elementType = asType : Type
			};
		--	when {
		--		mapEClassifier(eType, asType);
		--	}
		}
		relation mapEClassifier_Bag overrides mapEClassifier_Collection {
			enforce domain ecore eType : EClassifier, isOrdered : Boolean, isUnique : Boolean;
			enforce domain as asCollection: BagType {
				ownedBindings = asBinding : TemplateBinding {
					ownedSubstitutions = asSubstitution : TemplateParameterSubstitution {
						actual = asType : Type,
						formal = pivotMM::Bag::T 
					}
				}
			};
			when {
				not isOrdered;
				not isUnique;
				mapEClassifier(eType, asType);
			}
		}
		relation mapEClassifier_OrderedSet overrides mapEClassifier_Collection {
			enforce domain ecore eType : EClassifier, isOrdered : Boolean, isUnique : Boolean;
			enforce domain as asCollection: OrderedSetType {
				ownedBindings = asBinding : TemplateBinding {
					ownedSubstitutions = asSubstitution : TemplateParameterSubstitution {
						actual = asType : Type,
						formal = pivotMM::OrderedSet::T 
					}
				}
			};
			when {
				isOrdered;
				isUnique;
				mapEClassifier(eType, asType);
			}
		}
		relation mapEClassifier_Sequence overrides mapEClassifier_Collection {
			enforce domain ecore eType : EClassifier, isOrdered : Boolean, isUnique : Boolean;
			enforce domain as asCollection: SequenceType {
				ownedBindings = asBinding : TemplateBinding {
					ownedSubstitutions = asSubstitution : TemplateParameterSubstitution {
						actual = asType : Type,
						formal = pivotMM::Sequence::T 
					}
				}
			};
			when {
				isOrdered;
				not isUnique;
				mapEClassifier(eType, asType);
			}
		}
		relation mapEClassifier_Set overrides mapEClassifier_Collection {
			enforce domain ecore eType : EClassifier, isOrdered : Boolean, isUnique : Boolean;
			enforce domain as asCollection: SetType {
				ownedBindings = asBinding : TemplateBinding {
					ownedSubstitutions = asSubstitution : TemplateParameterSubstitution {
						actual = asType : Type,
						formal = pivotMM::Set::T 
					}
				}
			};
			when {
				not isOrdered;
				isUnique;
				mapEClassifier(eType, asType);
			}
		}
	/*	relation map2SetType {
			/*enforce* / domain ecore eTypedElement : ETypedElement {
				eType = eType : EClassifier
			} { eTypedElement.upperBound > 1};
			enforce domain as asSet : pivotMM::SetType {
				ownedBindings = asBinding : pivotMM::TemplateBinding {
					ownedSubstitutions = asSubstitution : pivotMM::TemplateParameterSubstitution {
						actual = asType : pivotMM::Type
					}	
				}
			};
			when {
				mapEClassifier(eType, asType);
			}
		} */
	}
}
