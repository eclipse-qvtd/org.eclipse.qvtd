import FamiliesMM : 'Families.ecore#/';
import FamilyPlansMM : 'FamilyPlans.ecore#/';
import PersonsMM : 'Persons.ecore#/';

package org::eclipse::qvtd::xtext::qvtrelation::tests::persons2families
{
------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
--	This is a side model-to-model transformation to plan the Persons to Families transformation
------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------					

transformation Persons2FamilyPlans(person:PersonsMM, family:FamiliesMM, plan:FamilyPlansMM) { 

	attribute PREFER_EXISTING_FAMILY_TO_NEW : Boolean[1] = 'true';
	attribute PREFER_CREATING_PARENT_TO_CHILD : Boolean[1] = 'true';
	
	query getSurname(person : PersonsMM::Person[1]) : String[1] {
		let safeName = '' + person.name							-- workaround Bug 550602
		in let index = safeName.indexOf(', ')
		in safeName.substring(1, index-1)
	}
	
	top relation R_PersonRegister2FamilyPlanning
	{		
	  	checkonly domain person pr : PersonRegister;
	  	checkonly domain family fr : FamilyRegister;	    
		enforce domain plan fp : FamilyPlanning;
	}
	
	relation P0_Surname2SurnamePlan
	{		
	  	primitive domain surname : String[?];
	  	enforce domain plan sp : SurnamePlan {
			name = surname
		};
	}
	
	top relation P1_Person2FamilyPlanning
	{		
	  	sp : FamilyPlansMM::SurnamePlan;
	  	checkonly domain person pr : PersonRegister {
	  		persons = p : Person
	  	};
	  	checkonly domain family fr : FamilyRegister;	    
		enforce domain plan fp : FamilyPlanning {
	  		surnamePlans = sp
		};
		when {
			R_PersonRegister2FamilyPlanning(pr, fr, fp);
			P0_Surname2SurnamePlan(getSurname(p), sp);
		}
		where {
			P2_Person2SurnamePlan(p, sp);
		}
	}
	
	abstract relation P2_Person2SurnamePlan
	{		
	  	checkonly domain person p : Person[1];
	  	enforce domain plan sp : SurnamePlan;
	}
	
	relation P2_Female2SurnamePlan overrides P2_Person2SurnamePlan
	{		
	  	checkonly domain person p : Female[1];
	  	enforce domain plan sp : SurnamePlan {
	  		females = p
	  	};
	  	where {
	  		P3_Female2FamilyPlan(p, sp);
	  	}
	}
	
	relation P2_Male2SurnamePlan overrides P2_Person2SurnamePlan
	{		
	  	checkonly domain person p : Male[1];
	  	enforce domain plan sp : SurnamePlan {
	  		males = p
	  	};
	  	where {
	  		P3_Male2FamilyPlan(p, sp);
	  	}
	}
	
 	abstract relation P3_Female2FamilyPlan
	{		
	  	checkonly domain person p : Female[1];
	  	enforce domain plan sp : SurnamePlan;
	}
	
 	relation P3_Mother2NewFamilyPlan overrides P3_Female2FamilyPlan
	{		
	  	checkonly domain person p : Female[1];
	  	enforce domain plan sp : SurnamePlan {
	  		familyPlans = fp : FamilyPlan {
	  			familyMemberPlans = sonPlan : FemaleMotherPlan {
	  				person = p
	  			}
	  		}
	  	};
	  	when {
	  		not this.PREFER_EXISTING_FAMILY_TO_NEW;
	  		this.PREFER_CREATING_PARENT_TO_CHILD;
	  	}
	}
 	relation P3_Daughter2NewFamilyPlan overrides P3_Female2FamilyPlan
	{		
	  	checkonly domain person p : Female[1];
	  	enforce domain plan sp : SurnamePlan {
	  		familyPlans = fp : FamilyPlan {
	  			familyMemberPlans = sonPlan : FemaleDaughterPlan {
	  				person = p
	  			}
	  		}
	  	};
	  	when {
	  		not this.PREFER_EXISTING_FAMILY_TO_NEW;
	  		not this.PREFER_CREATING_PARENT_TO_CHILD;
	  	}
	}
	
 	abstract relation P3_Male2FamilyPlan
	{		
	  	checkonly domain person p : Male[1];
	  	enforce domain plan sp : SurnamePlan;
	}
	
 	relation P3_Father2NewFamilyPlan overrides P3_Male2FamilyPlan
	{		
	  	checkonly domain person p : Male[1];
	  	enforce domain plan sp : SurnamePlan {
	  		familyPlans = fp : FamilyPlan {
	  			familyMemberPlans = sonPlan : MaleFatherPlan {
	  				person = p
	  			}
	  		}
	  	};
	  	when {
	  		not this.PREFER_EXISTING_FAMILY_TO_NEW;
	  		this.PREFER_CREATING_PARENT_TO_CHILD;
	  	}
	}
 	relation P3_Son2NewFamilyPlan overrides P3_Male2FamilyPlan
	{		
	  	checkonly domain person p : Male[1];
	  	enforce domain plan sp : SurnamePlan {
	  		familyPlans = fp : FamilyPlan {
	  			familyMemberPlans = sonPlan : MaleSonPlan {
	  				person = p
	  			}
	  		}
	  	};
	  	when {
	  		not this.PREFER_EXISTING_FAMILY_TO_NEW;
	  		not this.PREFER_CREATING_PARENT_TO_CHILD;
	  	}
	}
	
	relation F0_Family2SurnamePlan
	{		
	  	checkonly domain family f : Family[1] ;
	  	enforce domain plan sp : SurnamePlan {
	  		families = f
	  	};
	}
		
	top relation F1_Family2FamilyPlan
	{		
	  	checkonly domain family fy : Family;
	  	enforce domain plan fp : FamilyPlan {
	  		surnamePlan = sp : SurnamePlan
	  	};
	  	when {
	  		F0_Family2SurnamePlan(fy, sp);
	  	}
	}
	
	top relation F1_Family2SurnamePlanContainment
	{		
	  	sp : FamilyPlansMM::SurnamePlan[?];
	  	checkonly domain person pr : PersonRegister;
	  	checkonly domain family fr : FamilyRegister {
	  		families = f : Family
	  	};    
		enforce domain plan fp : FamilyPlanning {
	  		surnamePlans = sp
		};
		when {
			R_PersonRegister2FamilyPlanning(pr, fr, fp);
			P0_Surname2SurnamePlan(f.name, sp);
		}
		where {
			F0_Family2SurnamePlan(f, sp);
		}
	}
	
	top relation F2_Daughter2DaughterPlan
	{		
	  	checkonly domain family p : FamilyMember[1] {
	  		daughtersInverse = fy : Family
	  	};
	  	enforce domain plan fp : FamilyPlan {
	  		familyMemberPlans = dp : DaughterPlan {
	  			familyMember = p
	  		}
	  	};
	  	when {
	  		F1_Family2FamilyPlan(fy, fp);
	  	}
	}
		
	top relation F2_Father2FatherPlan
	{		
	  	checkonly domain family p : FamilyMember[1] {
	  		fatherInverse = fy : Family
	  	};
	  	enforce domain plan fp : FamilyPlan {
	  		familyMemberPlans = sp : FatherPlan {
	  			familyMember = p
	  		}
	  	};
	  	when {
	  		F1_Family2FamilyPlan(fy, fp);
	  	}
	}
		
	top relation F2_Mother2MotherPlan
	{		
	  	checkonly domain family p : FamilyMember[1] {
	  		motherInverse = fy : Family
	  	};
	  	enforce domain  plan fp : FamilyPlan {
	  		familyMemberPlans = sp : MotherPlan {
	  			familyMember = p
	  		}
	  	};
	  	when {
	  		F1_Family2FamilyPlan(fy, fp);
	  	}
	}
		
	top relation F2_Son2SonPlan
	{		
	  	checkonly domain family p : FamilyMember[1] {
	  		sonsInverse = fy : Family
	  	};
	  	enforce domain  plan fp : FamilyPlan {
	  		familyMemberPlans = sp : SonPlan {
	  			familyMember = p
	  		}
	  	};
	  	when {
	  		F1_Family2FamilyPlan(fy, fp);
	  	}
	}
}	
}