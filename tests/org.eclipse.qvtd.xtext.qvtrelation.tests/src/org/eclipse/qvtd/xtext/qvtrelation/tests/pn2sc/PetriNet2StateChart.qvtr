/*******************************************************************************
 * Copyright (c) 2016 Willink Transformations and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     E.D.Willink - initial implementation for ModelMorf
 *******************************************************************************/
import pnMM : 'PetriNets.ecore'::PetriNet; 
import scMM : 'StateCharts.ecore'::statecharts; 

package org::eclipse::qvtd::xtext::qvtrelation::tests::pn2sc {
/**
 * Transform a PetriNet into a StateChart.
 * See: https://github.com/louismrose/ttc_pn2sc/ and https://arxiv.org/pdf/1312.0342.pdf
 */
	transformation PetriNet2StateChart(pn:pnMM, sc:scMM)
	{
		top relation Init_Net2StateChart {
			domain pn net : Net {};	   
			enforce domain sc statechart : Statechart {
				topState = ts : AND {
					name = 'top'
				}
			};
		}

		top relation Init_Place2Basic {
			sc : scMM::Statechart;
			topState : scMM::AND;
			placeName : String;
			domain pn p : Place {
				cnet = net : Net{} ,
				name = placeName
			};	   
			enforce domain sc b : Basic {
				name = placeName,
				rcontains = o : OR {
					name = placeName.replaceFirst('E','O'),
					rcontains = topState
				}
				{ topState = sc.topState }
			};
			when {
				Init_Net2StateChart(net, sc);
			}
		}
	    
/*	    relation PlaceSet2BasicSet
	    {
	        pnRest: OrderedSet(pnMM::Place);
	        scRest: OrderedSet(scMM::Basic);
	        
	        domain pn
	            pnSet:OrderedSet(Place) {
	            	pnVar:Place {} ++ pnRest
	            };
	        enforce domain sc
	            scSet:OrderedSet(Basic) {
	        	   scVar:Basic {} ++ scRest
	            };
	        where {
	            Place2Basic(pnVar, scVar);
	            if (pnRest->isEmpty())
	            then
	                scRest = OrderedSet{}
	            else
	                PlaceSet2BasicSet(pnRest, scRest)
	            endif;
	        }
	    } */

		top relation Init_Transition2HyperEdge {
			sc : scMM::Statechart;
			topState : scMM::AND;
			transitionName : String;
			domain pn t : Transition {
				cnet = net : Net{} ,
				name = transitionName
			};	   
			enforce domain sc e : HyperEdge {
				name = transitionName,
				rcontains = topState
			}{ topState = sc.topState };
			when {
				Init_Net2StateChart(net, sc);
			}
		}

		top relation Init_Transition2HyperEdge_Post {
			domain pn prep:Place {
				postt = t:Transition{}
			};	   
			enforce domain sc rnext:State {
				next = e:HyperEdge{}
			};
			when {
				Init_Place2Basic(prep, rnext);
				Init_Transition2HyperEdge(t, e);
			}
		}

		top relation Init_Transition2HyperEdge_Pre {
			domain pn postp:Place {
				pret = t:Transition{}
			};	   
			enforce domain sc next:State {
				rnext = e:HyperEdge{}
			};
			when {
				Init_Place2Basic(postp, next);
				Init_Transition2HyperEdge(t, e);
			}
		}

/*retype Place to Basic
migrate Place {
	var container = new SC!OR;
	container.name = original.name.replace("P", "O");
	container.contains.add(migrated);
	original.cnet.equivalent().topstate.contains.add(container);
}

retype Transition to HyperEdge
migrate Transition {
	migrated.rnext = original.prep.equivalent();
	migrated.next = original.postp.equivalent();
}*/	}
}