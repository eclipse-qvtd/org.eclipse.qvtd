import 'Environment.ecore'
import 'Classes.ecore'
import 'ClassesCS.ecore'

package ocl 

-- Default Environment related functionality
context OclElement
	
--def : env() : env::Environment =
--	_env(null)

def : _env(child : OclElement) : env::Environment =
	parentEnv()
	
def : parentEnv() : env::Environment =
	let parent = oclContainer() in if parent = null then env::Environment { } else parent._env(self) endif
endpackage 

package env

-- Lookup operations
context Environment
-- Epsilon can't deal with this. The property is needed in the meta-model
-- def : namedElements : OrderedSet(classes::NamedElement) = OrderedSet{}
-- def : parentEnv : Environment = null

-- General Environment configuration operations
def : addElement(element : classes::NamedElement) : Environment =
	Environment{
		namedElements = namedElements->asSequence() -- FIXME bug 460682
			->including(element)
	}
	
def : addElements(elements : Collection(classes::NamedElement)) : Environment =
	Environment{
		namedElements = namedElements->asSequence() -- FIXME bug 460682
			->includingAll(elements)
	}
	
def : nestedEnv() : Environment = 
	Environment {
		parentEnv = self
	}
	
def : mergEnv(env : Environment) : Environment =
	Environment {
		namedElements = namedElements->includingAll(env.namedElements)
	}

-- General Environment access operations
def : getNamedElements(name : String) : OrderedSet(classes::NamedElement) =
	namedElements->select(x | x.name = name)
	
-- Specific Environment access operations	
def : lookupPackage(path : classescs::PathElementCS) : classes::Package =
	namedElements->selectByKind(classes::Package)->select(name = path.name)->first()
		
def : lookupPackage(pathSeq : OrderedSet(classescs::PathElementCS)) : classes::Package =
	if pathSeq->size() = 1 
	then lookupPackage(pathSeq->first())
	else lookupPackage(pathSeq->subOrderedSet(1,pathSeq->size()-1)).env().lookupPackage(pathSeq->last())
	endif
	
def : lookupClass(path : classescs::PathElementCS) : classes::Class =
	namedElements->selectByKind(classes::Class)->select(name = path.name)->first()
	
def : lookupClass(classPathName : classescs::PathNameCS) : classes::Class = 
	let pathSeq = classPathName.path
	in
		if pathSeq->size() = 1
		then lookupClass(pathSeq->first())
		else lookupPackage(pathSeq->subOrderedSet(1,pathSeq->size()-1)).env().lookupClass(pathSeq->last())
		endif
	
endpackage

package classes

context Package
def : _env(child : ocl::OclElement) : env::Environment =
	-- FIXME this doesn't work in the editor. Discuss with ED
	--_env_Class(child).mergeEnv(
	--_env_Package(child))
	env::Environment {
		namedElements = _env_Class(child).namedElements->asSequence() -- FIXME bug 460682
				->includingAll(_env_Package(child).namedElements)
	}

def : _env_Class(child : ocl::OclElement) : env::Environment =
	parentEnv().nestedEnv().
		addElements(self.ownedClasses)

def : _env_Package(child : ocl::OclElement) : env::Environment =
	parentEnv().nestedEnv().
		addElements(self.ownedPackages)
		
context Root
def : _env(child : ocl::OclElement) : env::Environment =
	_env_Package(child)

def : _env_Package(child : ocl::OclElement) : env::Environment =
	parentEnv().nestedEnv().
		addElements(self.ownedPackages)

-- Inlining
-- FIXME study
context Class
def : env() : env::Environment =
	let parent = oclContainer() in
	-- Classes can only be contained in Packages	
	parent.oclAsType(Package)._env(self) 
	
context Package
def : env() : env::Environment =
	let parent = oclContainer() in
	if parent.oclIsKindOf(Package)
	then parent.oclAsType(Package)._env(self)
	-- It needs to be root
	else parent.oclAsType(Root)._env(self)
	endif

endpackage
