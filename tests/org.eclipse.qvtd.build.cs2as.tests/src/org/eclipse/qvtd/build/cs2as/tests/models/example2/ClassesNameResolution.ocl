import 'EnvExample2.ecore'
import 'Classes.ecore'
import 'ClassesCS.ecore'

package ocl 
--
-- Default Environment related functionality
context OclElement

--
--def : env() : env::Environment =
--	_env(null)
--
def : _env(child : OclElement) : env::Environment =
	parentEnv()
	
--
def : parentEnv() : env::Environment =
	let parent = oclContainer() in if parent = null then env::Environment { } else parent._env(self) endif
endpackage 

package env

-- Lookup operations
context Environment
-- Epsilon can't deal with this. The property is needed in the meta-model
-- def : namedElements : OrderedSet(classes::NamedElement) = OrderedSet{}
-- def : parentEnv : Environment = null

-- General Environment configuration operations

def : mergEnv(env : Environment) : Environment =
	Environment {
		namedElements = namedElements->asSequence() -- FIXME bug 460682
			->includingAll(env.namedElements),
		parentEnv = parentEnv
	}
		
def : nestedEnv() : Environment = 
	Environment {
		parentEnv = self
	}


-- General Environment access operations
def : getNamedElements(name : String) : OrderedSet(classes::NamedElement) =
	namedElements->select(x | x.name = name)
	
-- Specific Environment access operations	
def : lookupPackage(path : classescs::PathElementCS) : classes::Package =
	-- namedElements->selectByKind(classes::Package)->select(name = path.name)->first()
	let foundPackages = namedElements->selectByKind(classes::Package)->select(name = path.name) 
	in
		if foundPackages->isEmpty()
		then if parentEnv.oclIsUndefined()
			then null
			else parentEnv.lookupPackage(path)
			endif
		else foundPackages->first()
		endif
		
def : lookupPackage(pathSeq : OrderedSet(classescs::PathElementCS)) : classes::Package =
	if pathSeq->size() = 1 
	then lookupPackage(pathSeq->first())
	else lookupPackage(pathSeq->subOrderedSet(1,pathSeq->size()-1)).env().lookupPackage(pathSeq->last())
	endif
	
def : lookupClass(path : classescs::PathElementCS) : classes::Class =
	-- namedElements->selectByKind(classes::Class)->select(name = path.name)->first()
	let foundClasses = namedElements->selectByKind(classes::Class)->select(name = path.name) 
	in
		if foundClasses->isEmpty()
		then if parentEnv.oclIsUndefined()
			then null
			else parentEnv.lookupClass(path)
			endif
		else foundClasses->first()
		endif
	
def : lookupClass(classPathName : classescs::PathNameCS) : classes::Class = 
	let pathSeq = classPathName.path
	in
		if pathSeq->size() = 1
		then lookupClass(pathSeq->first())
		else lookupPackage(pathSeq->subOrderedSet(1,pathSeq->size()-1)).env().lookupClass(pathSeq->last())
		endif
	
endpackage

package classes

context Package
def : _env(child : ocl::OclElement) : env::Environment =
--	-- FIXME this doesn't work in the editor. Discuss with ED
--	--_env_Class(child).mergeEnv(
--	--_env_Package(child))
--	let _env_Package = _env_Package(child), _env_Class = _env_Class(child)
--	in
--		_env_Package.mergEnv(_env_Class)
-- FIXME LookupVisitor doesn't handle any other operation called from this one. Inline here, for the time being
	parentEnv().nestedEnv()
		.addElements(self.ownedClasses)
		.addElements(self.ownedPackages)
		

--def : _env_Class(child : ocl::OclElement) : env::Environment =
--	parentEnv().nestedEnv().
--		addElements(self.ownedClasses)
--
--def : _env_Package(child : ocl::OclElement) : env::Environment =
--	parentEnv().nestedEnv().
--		addElements(self.ownedPackages)
		
context Root
def : _env(child : ocl::OclElement) : env::Environment =
--	_env_Package(child)
-- FIXME LookupVisitor doesn't handle any other operation called from this one. Inline here, for the time being
	parentEnv().nestedEnv().
		addElements(self.ownedPackages)
--def : _env_Package(child : ocl::OclElement) : env::Environment =
--	parentEnv().nestedEnv().
--		addElements(self.ownedPackages)

-- FIXME 
-- Inlining, because a generic operations (OclElement::env(), OclElement::parentEnv()) create troubles to the CG

context Root
def : env() : env::Environment =
	self._env(null)
	
def : parentEnv() : env::Environment =
	env::Environment {}
	
context Package
def : env() : env::Environment =
	self._env(null)
	
def : parentEnv() : env::Environment =
	let parent = oclContainer() in
	if parent.oclIsKindOf(Package)
	then parent.oclAsType(Package)._env(self)
	else parent.oclAsType(Root)._env(self)
	endif
	
context Class
def : env() : env::Environment =
	-- Class doesn't contribute elements no the environment, start from its container
	parentEnv()
	
def : parentEnv() : env::Environment =
	let parent = oclContainer() in	
	parent.oclAsType(Package)._env(self) -- Classes can only be contained in Packages 

endpackage
