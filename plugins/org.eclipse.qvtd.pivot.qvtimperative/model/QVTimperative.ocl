import 'http://www.eclipse.org/qvt/0.9/QVTimperative'
import 'http://www.eclipse.org/qvt/0.9/QVTcoreBase'
import 'http://www.eclipse.org/qvt/0.9/QVTbase'
--import 'http://www.eclipse.org/ocl/3.1.0/Pivot'

package ocl
context Element
def: joinNames(names : Set(String)) : String = '{' + names->sortedBy(n | n)->iterate(n; s : String = '' | if s = '' then n else s + ';' + n endif) + '}'

endpackage

package qvtimperative

context Mapping
def: allAreas : Set(qvtcorebase::Area) = self.domain.oclAsType(qvtcorebase::Area)->asSet()->including(self)
def: allGuardPatterns : Set(qvtcorebase::GuardPattern) = allAreas.guardPattern->asSet()
def: isToMiddle : Boolean = not domain->exists(isEnforceable) 
def: isFromMiddle : Boolean = domain->forAll(isEnforceable) 
def: guardVariables : Set(ocl::Variable) = allGuardPatterns.variable->asSet()
def: boundGuardVariables : Set(ocl::Variable) = allGuardPatterns.predicate->selectByKind(VariablePredicate).targetVariable->asSet()
/* Mapping guard variables that are assigned  */
--def: boundGuardVariables : Set(ocl::Variable) = guardVariables->select(initExpression <> null)
def: unboundGuardVariables : Set(ocl::Variable) = guardVariables - boundGuardVariables
-- def: noInheritance : Boolean = self.refinement->isEmpty()
-- def: noParents : Boolean = self.specification->isEmpty()
/* Mappings are either L to M or M to R, but not both */
inv ViaMiddle: isToMiddle xor isFromMiddle
/* No mapping refinement */
-- inv NoRefinement: noInheritance and noParents

context MappingCall
def: referredNames : Set(String) = referredMapping.unboundGuardVariables.name->asSet()
def: referringNames : Set(String) = binding.boundVariable.name->asSet()
inv MatchingCallBindings('Mismatched bindings ' + referredMapping.name + joinNames(referredNames) + ' <= ' + joinNames(referringNames)): referredNames = referringNames
inv UniqueCallBindings: binding->isUnique(boundVariable)

context MappingCallBinding
inv CompatibleScalarBinding: if not isLoop then value.type.conformsTo(boundVariable.type) or boundVariable.type.conformsTo(value.type) else true endif
inv CompatibleLoopBinding: isLoop implies value.type.oclIsKindOf(ocl::CollectionType) --and let eleType : ocl::Type = value.type.oclAsType(ocl::CollectionType).elementType in true --eleType.conformsTo(boundVariable.type) or boundVariable.type.conformsTo(eleType)

context MiddlePropertyAssignment
inv IsMiddleProperty: true --TODO

context MiddlePropertyCallExp
inv IsMiddleProperty: true --TODO

endpackage

package qvtcorebase

context Area
def: mapping : qvtimperative::Mapping = if oclIsKindOf(qvtimperative::Mapping) then self else oclAsType(CoreDomain).rule endif.oclAsType(qvtimperative::Mapping)
def: isSource : Boolean = mapping.isToMiddle and oclIsKindOf(CoreDomain)
def: isTarget : Boolean = mapping.isFromMiddle and oclIsKindOf(CoreDomain)

--context BottomPattern
--inv UniquePropertyAssignments: assignment->select(PropertyAssignment)->isUnique(a : PropertyAssignment | a.targetProperty)	-- FIXME redundant "a : PropertyAssignment | a."

context CoreDomain
def: mapping : qvtimperative::Mapping = rule.oclAsType(qvtimperative::Mapping)
inv NoCheckable: not isCheckable

context PropertyAssignment
inv IsNotReadOnly: not targetProperty.isReadOnly
inv PropertyOfSlot(slotExpression.type.name + ' must conform to ' + targetProperty.owningType.name): slotExpression.type.conformsTo(targetProperty.owningType)
inv CompatibleType(value.type.name + ' must conform to ' + targetProperty.type.name): value.type.conformsTo(targetProperty.type)

context RealizedVariable
def: isBottom : Boolean = oclContainer().oclIsKindOf(BottomPattern)
def: isGuard : Boolean = oclContainer().oclIsKindOf(GuardPattern)
inv IsBottom('RealizedVariable ' + name + ' must be in a BottomPattern'): isBottom
inv IsEnforced('RealizedVariable ' + name + ' must be in an enforceable Area'): if isBottom then let area = oclContainer().oclAsType(BottomPattern).area, mapping = area.mapping in
	if mapping.isToMiddle then area = mapping else area.oclAsType(CoreDomain).isEnforceable endif
	else true endif

--context Variable
--inv IsInGuard: oclContainer().oclIsKindOf(GuardPattern)
--inv IsEnforced: let area = oclContainer().oclAsType(GuardPattern).area, mapping = area.mapping in
--	if mapping.isToMiddle then area = mapping else area.oclAsType(CoreDomain).isEnforceable endif

context VariableAssignment
inv NoVariableAssignmentsInSourceDomain: bottomPattern.area.isTarget
inv CompatibleType: value.type.conformsTo(targetVariable.type)

endpackage
