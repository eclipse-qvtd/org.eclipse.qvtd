/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "InterMappingDependencies.eol";
import "MappingDataDependencies.eol";
import "../helpers/OCLExpressionAnalysis.eol";


/****l* org.eclipse.qvtd.build.etl/dependence/QVTiDependenceAnalysis
 * NAME
 *  QVTiDependenceAnalysis -- Perform data dependence analysis on a QVTm
 *  (partitioned) transformation.
 * MODELS
 *  Required models to run the script:
 *      - NAME      ALIASES METAMODEL               ROL SOD
 *      - qvti      QVT     QVTCore                  X          The QVTm (partitioned) AST
 *      - config            QVTcConfig               X          The transformation configuration
 *      - ocllib            Pivot                    X          The OCL standard library (http://www.eclipse.org/ocl/3.1.0/OCL.oclstdlib.oclas)
 *      - lTree     tree    ECoreContainmentTree     X          The left metamodel containment tree
 *      - mTree     tree    ECoreContainmentTree     X          The middle metamodel containment tree
 *      - rTree     tree    ECoreContainmentTree     X          The right metamodel containment tree
 *      - imGraph   ddg     QVTcDataDependencyGraph      X      The inter-mapping dependence graph
 *      - ddGraph   ddg     QVTcDataDependencyGraph      X      The data dependence graph
 *      - mdGraph   ddg     QVTcDataDependencyGraph      X      The merged data dependece graph
 *      - rdGraph   ddg     QVTcDataDependencyGraph      X      The reduced data dependece graph
 *
 * SEE ALSO
 *    
 ******
 * You can use this space for remarks that should not be included
 * in the documentation.
 */

var varMap : Map;       // (Variable, tree!Node)
var inputVarMap : Map;  // (mapping, Set{variable})
var outputVarMap : Map; // (mapping, Set{realizedVariable})
var dataTypeAssignments : Map;    // (mapping, Sequence{Type, Attribute})
var nodeMap : Map;      // (mapping, graph!Node)
var dataNodeMap : Map;      // (??, graph!Node)

// For each mapping get the set of input and output vars.
for (r in qvti!Transformation.all().first().rule) {
    //r.name.println();
    inputVarMap.put(r, r.getInputVars());
    outputVarMap.put(r, r.getOutputVars());
    dataTypeAssignments.put(r, r.getDataTypeAssignments());
}

// 1. Inter-mapping dependencies
var img = new imGraph!Graph;
img.name = "InterMapping";
qvti!Transformation.all().first().interMappingDependencies(img, inputVarMap, outputVarMap, dataTypeAssignments);

// 2. Mapping data dependendence
var mdd = new ddGraph!Graph;
mdd.name = "MappingDataDependences";
qvti!Transformation.all().first().mappingDataDependencies(mdd, inputVarMap, outputVarMap, dataTypeAssignments);


// 3. Merge Data dependencies
// Visit the data dependence graph ir ordered mode: start with mappings with
// the least number of inputs
var mdg = new mdGraph!Graph;
// Create the map of containment trees from the config?
var containmentTrees : Map;
containmentTrees.put("l", lTree!Node.all());
containmentTrees.put("m", mTree!Node.all());
containmentTrees.put("r", rTree!Node.all());
mdd.mergedMappingDataDependencies(mdg, containmentTrees);


//4. Reduced data dependencies
//var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
var rdg = new rdGraph!Graph;

// Analize the dependencies to identify which input variables can be derived from others
// primaryInputs are only the ones that don't have a containment relation or a 
// middle relation with other input vars
mdd.reducedMergedMappingDataDependencies(rdg, containmentTrees);

"Done".println();

/* ==================================================================== */







operation ddGraph!Graph getNodeForVar(v : QVT!Variable) : ddGraph!Node {
    var n;
    if (varMap.containsKey(v)) {
        n = varMap.get(v);
    } else {
        n = new ddGraph!Node;
        n.label = v.type.name;
        n.qvtAstNode = v;
        varMap.put(v, n);
        if (v.oppositePattern().area.name == "middle") {
            n.type = ddGraph!NodeType#middle;
        } else if(v.oppositePattern().area.isInputDomain()) {
            n.type = ddGraph!NodeType#input;
        } else if(v.oppositePattern().area.isOutputDomain()) {
            n.type = ddGraph!NodeType#output;        
        } 
        self.element.add(n);
    }
    return n;
}


operation visitR(roots : Collection, ddg : ddGraph!Graph, rootDd : ddGraph!Node) {
    for (root in roots) {
        var gn = root.getGraphNode();
        var e = new ddGraph!Edge;
        e.source = rootDd;
        e.target = gn;
        ddg.element.add(e);
        dfsR(root);
    }
}

operation dfsR(rootNode : tree!Node) {
    for (child in rootNode.children) {
        outputVarDFS(child, outputVarMap);
    }
}

operation outputVarDFS(node : tree!Node, outputVarMap : Map) {
    // 1. Look for all mappings that have a realized variable of this Node Type
    for (m in outputVarMap.keySet()) {
        for (v in outputVarMap.get(m)) {
            if (v.type == node.type) {
                
            }
        }
    }
}


//////

operation qvti!Mapping getGraphNode() : ddGraph!Node  {
    if (dataNodeMap.containsKey(self)) {
        return dataNodeMap.get(self);
    } else {
        var gn = new ddGraph!Node;
	    gn.label = self.type;
	    gn.qvtAstNode = self;
	    gn.color = ddGraph!Color#orange;
	    ddg.element.add(gn); 
	    dataNodeMap.put(self, gn);
    }
}

operation qvti!CoreDomain getGraphNode() : ddGraph!Node  {
    if (dataNodeMap.containsKey(self)) {
        return dataNodeMap.get(self);
    } else {
        var gn = new ddGraph!Node;
        gn.label = self.type;
        gn.qvtAstNode = self;
        gn.color = ddGraph!Color#orange;
        ddg.element.add(gn);
        dataNodeMap.put(self, gn); 
    }
}

operation rTree!Node getGraphNode() : ddGraph!Node  {
    if (dataNodeMap.containsKey(self)) {
        return dataNodeMap.get(self);
    } else {
        var gn = new ddGraph!Node;
        gn.label = self.type;
        gn.color = ddGraph!Color#orange;
        ddg.element.add(gn); 
        dataNodeMap.put(self, gn);
    }
}


operation visitL(roots : Collection, ddg : ddGraph!Graph, rootDd : ddGraph!Node) {
    for (root in roots) {
        var gn = new ddGraph!Node;
        gn.label = root.elementName;
        ddg.element.add(gn);
        var e = new ddGraph!Edge;
        e.source = rootDd;
        e.target = gn;
        ddg.element.add(e);
        dfsL(root);
    }
}



// Root nodes don't have mappings associated
operation dfsL(rootNode : tree!Node) {
    for (child in rootNode.children) {
        depthSearchL(child, new Set, qvti!Transformation.all().first().rule);
    }
}


operation depthSearchL(node : tree!Node, hierarchySpace : Collection, searchSpace : Collection) : Collection {
    // 1. Search for mappings in my hierarchy
    var hierarchyMapps = node.getLMapps(hierarchySpace);
    var unused = hierarchySpace.excludingAll(hierarchyMapps);
    // 2. Search for mappings outside my hierarchy
    var searchSpaceMapps = node.getLMapps(searchSpace);
    // The new hierarchy is the old plus the new
    hierarchyMapps = hierarchyMapps.includingAll(searchSpaceMapps);
    // The seearch space can't contain the new hierarchy
    searchSpace = searchSpace.excludingAll(hierarchyMapps);
    // My children should look into my hierarchy and the rest;
    for (child in node.children) {
        hierarchyMapps = depthSearchL(child, hierarchyMapps, searchSpace);
    }
    if(tNodeMapping.containsKey(node)) {
        hierarchyMapps = hierarchyMapps.includingAll(tNodeMapping.get(node));
    }
    tNodeMapping.put(node, hierarchyMapps);
    return unused;
}

operation depthSearchR(node : tree!Node, hierarchySpace : Collection, searchSpace : Collection) : Collection {
    // 1. Search for mappings in my hierarchy
    var hierarchyMapps = node.getRMapps(hierarchySpace);
    var unused = hierarchySpace.excludingAll(hierarchyMapps);
    // 2. Search for mappings outside my hierarchy
    var searchSpaceMapps = node.getRMapps(searchSpace);
    // The new hierarchy is the old plus the new
    hierarchyMapps = hierarchyMapps.includingAll(searchSpaceMapps);
    // The seearch space can't contain the new hierarchy
    searchSpace = searchSpace.excludingAll(hierarchyMapps);
    // My children should look into my hierarchy and the rest;
    for (child in node.children) {
        hierarchyMapps = depthSearchR(child, hierarchyMapps, searchSpace);
    }
    if(tNodeMapping.containsKey(node)) {
        hierarchyMapps = hierarchyMapps.includingAll(tNodeMapping.get(node));
    }
    tNodeMapping.put(node, hierarchyMapps);
    return unused;
}

operation tree!Node getLMapps(mapps : Collection) : Collection {
    // Find the predicates that use variables of the node's and its parent's type,
    // and that are containment opposite tests
    return mapps.select(m | m.testMappingL(self));    
}

operation tree!Node getRMapps(mapps : Collection) : Collection {
    // Find the predicates that use variables of the node's and its parent's type,
    // and that are containment opposite tests
    return mapps.select(m | m.testMappingR(self));    
}

// L type nodes are tested for predicates or single input var 
operation qvti!Rule testMappingL(tNode : tree!Node) : Boolean {
    // Once the partition is done, this should only look for predicates in the guard patterns
    
    var prediactes =  self.guardPattern.predicate
            .includingAll(self.domain.collect(d | d.guardPattern).flatten().collect(gp | gp.predicate).flatten())
            .includingAll(self.domain.collect(d | d.bottomPattern).flatten().collect(gp | gp.predicate).flatten());
    if (prediactes.isEmpty()) {
        // The mapping has no predicates??
        // It must have only 1 input variable, and the variable must be
        // of he same type of the tree Node
        if (inputVarMap.get(self).size() == 1) {
            return inputVarMap.get(self).exists(v | v.type.name == tNode.elementName);
        }
    }
    else {
        for (p in prediactes) {
            //p.conditionExpression.toString().println();
            if (p.conditionExpression.isSimpleAttributeNavigation()) {
                // Does the predicate is single "domained", all variables belong to the same domain
                if (p.conditionExpression.isSingleDomained()) {
                    // Are both the node's and its parent's type used in the predicate
                    if (p.conditionExpression.findReferencedVariables()
                            .forAll(v | v.type.name == tNode.elementName or v.type.name == tNode.parent.elementName)) {
                        // Find if the navigated property is a containment opposite.
                        var prop = p.conditionExpression.getNavigatedProperty();
                        if (prop.opposite.isDefined() and prop.opposite.isComposite()) {
                            return true;
                        }
                    }
                    
                }
            }
        }
    }
    return false;
}

// R type nodes are tested for assignments or single input realized vars
operation qvti!Rule testMappingR(tNode : tree!Node) : Boolean {
    // Once the partition is done, this should only look for assignments in the R domain's bottom pattern
    //self.name.println("testMappingR ");
    var assignments =  self.domain.select(d | d.isEnforceable).collect(d | d.bottomPattern).flatten().collect(gp | gp.assignment).flatten();
    if (assignments.isEmpty()) {
        // The bottom pattern has no predicates
        // It must have only 1 realize variable, and the variable must be
        // of he same type of the tree Node
        if (outputVarMap.get(self).size() == 1) {
            return outputVarMap.get(self).exists(v | v.type.name == tNode.elementName);
        }
    }
    else {
        for (a in assignments) {
            //a.toString().println();
            if (a.isSimpleAttributeNavigation()) {
                // Does the predicate is single "domained", all variables belong to the same domain
                if (a.isSingleDomained()) {
                    // Are both the node's and its parent's type used in the predicate
                    if (a.findReferencedVariables()
                            .forAll(v | v.type.name == tNode.elementName or v.type.name == tNode.parent.elementName)) {
                        // Find if the navigated property is a containment opposite.
                        var prop = a.targetProperty;
                        if (prop.opposite.isDefined() and prop.opposite.isComposite()) {
                            // Check that there are none realized variables of my parent's type
                            return not outputVarMap.get(self).exists(v | v.type.name == tNode.parent.elementName);
                            //return true;
                        }
                    }
                    
                }
            } else if (a.isPrimitiveVarAssignemnt()) {
                if (a.targetVariable.oppositePattern().area.isOutputDomain()) {
                    return a.targetVariable.type.name == tNode.elementName;   
                }
            }
        }
    }
    return false;
}


// Create a Dada Dependence graph of just the mappings. 
// For each node of a mm tree, craete a node for each mapping.
// Create an Edge from this node, to the node created for the
// maping of each of its nodes.

operation createDomainTreeMappingDependence(roots : Collection, ddg : ddGraph!Graph, rootDd : ddGraph!Node) {
    for (root in roots) {
        var gn = new ddGraph!Node;
        gn.label = root.elementName;
        ddg.element.add(gn);
        var e = new ddGraph!Edge;
        e.source = rootDd;
        e.target = gn;
        ddg.element.add(e);
        dfs(root);
    }
}


operation TypedModel getMetaModel() : EmfModel {
    
}
