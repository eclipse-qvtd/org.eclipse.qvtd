import "Helpers.eol";

main();

operation main() {
	// Prune PropertyAssignment
	for (cd in QVTc!CoreDomain.all) {
	    if (not isInputDomain(cd)) {
	        for (pa in cd.bottomPattern.assignment.select(a : QVTc!PropertyAssignment | true)) {
	            pa.del();
	        }
	    }
	}
	for (m in QVTc!Mapping.all) {
	    for (pa in m.bottomPattern.assignment.select(a : QVTc!PropertyAssignment | true)) {
	        pa.del();
	    }
	}
}

operation QVTc!PropertyAssignment del() {
    
    // Output domain to middle assignments are removed, iif the value 
    // expression is not a variable
    var d = isMiddleDomain(self.slotExpression.getArea())
        and not self.value.isTypeOf(QVTc!VariableExp)
        and not isInputDomain(self.value.getArea());
    if (d) {
        delete self;
    } else {
        // Middle domian to input assigments are removed
        d = isInputDomain(self.slotExpression.getArea())
        and isMiddleDomain(self.value.getArea());
        if (d) {
            delete self;
        }
        
    }
}

// How to find the domain of an OCL expression? It depends on the expression.. but it can get nasty
operation QVTc!OCLExpression getArea() : QVTc!Area {
    var area : QVTc!Area;
    if (self.isTypeOf(QVTc!VariableExp)) {
        area = self.referredVariable.oppositePattern().area;
    } else if (self.isTypeOf(QVTc!PropertyCallExp)) {
        area = self.source.getArea();
    } else {
        throw "Error! Add getArea for " + self.type();
    }
    return area;
}