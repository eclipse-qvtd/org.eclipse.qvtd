/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "../helpers/DataDependenceGraphHelpers.eol";

/**
 * Mapping Data Dependencies. A set of EOL operations to perform mapping data
 * dependence analysis for a QVT transformation.
 *
 * @cond ddg  A data dependence graph
 * @cond QVT  A QVTx AST model
 * @cond config The QVT transformation configuration
 */

/**
 * Analysis of the data dependencies of mappings. Creates a directed graph in
 * which nodes are mappings and variable types. An edge is created between a
 * Type and a mapping if there is either an input or output variable of the
 * Type in the mapping. Additional edges are created bewteen Types to represent
 * containment relations in the metamodel that owns the Type. Each mapping is
 * analyzed individualy.
 *
 * @context QVT!Transformation  The transformation being analyzed
 * @param graph The graph to populate
 * @param inputVarMap   The map of mapings to input variables
 * @param outputVarMap  The map of mapings to output variables
 */
operation QVT!Transformation mappingDataDependencies(graph : ddg!Graph, inputVarMap : Map, outputVarMap : Map) {
    var ruleMap : Map;  //!< Cache nodes for mappings nodes (AST, graph!Node)
    var varMap : Map;  //!< Cache nodes for mappings nodes (AST, graph!Node)
    
    for (r in self.rule.select(r | not r.context.isDefined())) {
        var ruleNode = graph.getNodeForQvtAstNode(r, ruleMap);
        varMap.clear();
        //r.println();
	    // Input variables relations
	    for (vA in inputVarMap.get(r)) {
	        //vA.println("vA ");
	        var e = graph.owningModel().createInstance("Edge");
	        var vaNode = graph.getNodeForQvtAstNode(vA, varMap); 
	        e.source = vaNode;
	        e.target = ruleNode;
	        //e.type = graph.owningModel().getEnumerationValue("EdgeType", "primaryInput");
	        e.type = ddg!EdgeType#primaryInput;   
	        graph.element.add(e);   
            vA.variableRelations(graph, inputVarMap.get(r).excluding(vA), varMap);
	    }
	    // Output variables relations
	    for (vA in outputVarMap.get(r)) {
	        //vA.println("vA ");
	        var vaNode = graph.getNodeForQvtAstNode(vA, varMap);
	        var e = graph.owningModel().createInstance("Edge");
	        e.source = ruleNode;
	        e.target = vaNode;
	        e.type = graph.owningModel().getEnumerationValue("EdgeType", "output");
	        //e.type = ddg!EdgeType#output;   
	        graph.element.add(e);       
	        vA.variableRelations(graph, outputVarMap.get(r).excluding(vA), varMap);
	    }
        // Input to Output variable relations
	    for (vIn in inputVarMap.get(r)) {
	        //vA.println("vA ");
	        vIn.variableRelations(graph, outputVarMap.get(r), varMap);
	    }
	}
}


/**
 * Merge the data dependencies of mappings. The merged dependencies takes into
 * consideration the containment relations of variables (from the metamodels
 * containment trees) and merges all the dependencies into a connected graph.
 *
 * @see mappingDataDependencies
 * @context ddg!Graph  The data dependencies graph being merged
 * @param mergeGraph The graph (merged) to populate
 * @param containmentTrees   The map of domains (metamodels) and their containment trees
 */
operation ddg!Graph mergedMappingDataDependencies(mergeGraph : ddg!Graph, containmentTrees : Map) {
    
    // Import the tree nodes to the merged graph
    var mergeMap : Map;  // //!< Cache nodes for nodes (AST, graph!Node)(x, Node)
    for(key in containmentTrees.keySet()) {
        mergeGraph.importContainmentTree(containmentTrees.get(key), key, mergeMap);
    }
    for (m in self.element.select(n | n.type == self.owningModel().getEnumerationValue("NodeType", "mapping")).sortBy(n | n.incoming.size())) {
	    var outputVarNodes = m.outgoing.collect(e | e.target).flatten();
	    var inputVarNodes = m.incoming.collect(e | e.source).flatten();
	    
	    // For each variable, find the corresponding type in the domain containment tree
	    // and make the connection. For input variables, if the type is abstrac (does 
	    //  not exist in the tree), connect it to all its subtypes.
	    var mappingNode = mergeGraph.getNodeCopy(m, mergeMap);
	    for (vN in inputVarNodes) {
	        var sources : Collection;
	        for(key in containmentTrees.keySet()) {
		        sources = containmentTrees.get(key).select(n | (n.EClassifierName == vN.label) or n.superTypes.includes(vN.label)); 
		        if (not sources.isEmpty()) {
                    break;
		        }
		    }
	        if (sources.isEmpty()) {
	            vN.errln("Not valid type found for: "); // Error. WE should never get here!
	        }
	        for (s in sources) {
	            var e = mergeGraph.owningModel().createInstance("Edge");
	            // If there is another edge to the input, is a double input
	            if (mergeGraph.element.exists(e : ddg!Edge| e.source == mergeMap.get(s) and e.target == mappingNode)) {
                    //e.type = mergeGraph.owningModel().getEnumerationValue("EdgeType", "doublePrimaryInput");
	                e.type = ddg!EdgeType#doublePrimaryInput;
	            } else {
	                //e.type = mergeGraph.owningModel().getEnumerationValue("EdgeType", "primaryInput");
	                e.type = ddg!EdgeType#primaryInput;
	            }
	            e.source = mergeMap.get(s);
	            e.target = mappingNode;
	            mergeGraph.element.add(e);
	        }
	    }
	    for (vN in outputVarNodes) {
	        var targets : Collection;
	        for(key in containmentTrees.keySet()) {
                targets = containmentTrees.get(key).select(n | (n.EClassifierName == vN.label)); 
                if (not targets.isEmpty()) {
                    break;
                }
            }
	        if (targets.isEmpty()) {
	            vN.errln("Not valid type found for: ");    // Error. WE should never get here!
	        }
	        for (t in targets) {
	            var e = mergeGraph.owningModel().createInstance("Edge");
	            //e.type = mergeGraph.owningModel().getEnumerationValue("EdgeType", "output");
	            e.type = ddg!EdgeType#output;
	            e.source = mappingNode;
	            e.target = mergeMap.get(t);
	            mergeGraph.element.add(e);
	        }
	    }
	}
}

/****o* org.eclipse.qvtd.build.etl/dependence/MappingDataDependencies/reducedMergedMappingDataDependencies
 * NAME
 *  reducedMergedMappingDataDependencies - Do a reduction of data dependencies
 *  to identify derivable variables . 
 * SYNOPSIS
 *   
 * FUNCTION
 *  Reduced [merged] data dependencies of mappings. The reduced dependencies   
 *  takes the same considerations as the merged data dependencies and 
 *  additionally analyses the maping predicates to identfy variables that can 
 *  be derived from other variables.
 *
 *  All outgoing edges in the data dependence graph are navigable, hence all
 *  targets of such edges are derivable. For incoming edges, it is necesary to
 *  analyze the relation represented by the edge and identify navigable
 *  opposites (upper bound = 1).
 * CONTEXT
 *  ddg!Graph   The data dependence graph   
 * PARAMETERS
 *  reduceGraph The graph to populate
 *  containmentTrees The containment trees of the candidate and middle meta-
 *  models
 * RESULT
 *  A graph representing the reduced dependencies
 * SEE ALSO
 *
 */
operation ddg!Graph reducedMergedMappingDataDependencies(reduceGraph : ddg!Graph, containmentTrees : Map) {
    // Import the tree nodes to the merged graph
    var mergeMap : Map;  // //!< Cache nodes for nodes (AST, graph!Node)(x, Node)
    for(key in containmentTrees.keySet()) {
        reduceGraph.importContainmentTree(containmentTrees.get(key), key, mergeMap);
    }
    for (m in self.element.select(n | n.type == ddg!NodeType#mapping).sortBy(n | n.incoming.size())) {
        var inputVarNodes = m.incoming.collect(e | e.source).flatten();
        m.label.println("Mapping ");
        // For each input node, get the set of variables that can be derived from it.
        var derivedVars = new Map;
        for (vN in inputVarNodes) {
            var derived = new Set;
		    derived.addAll(vN.outgoing.select(e | inputVarNodes.includes(e.target)).collect(e | e.target));
		    for (ie in vN.incoming) {
                if (ie.referredProperty.getOpposite().isDefined() and not ie.referredProperty.getOpposite().isMany()) {
                        derived.add(ie.source);
                }
            }
            derivedVars.put(vN, derived);
        }
        // No find the variable that provides the most derived variables = the union of 
        // its derived variables and the ones that can be derived from them.
        var derivedVarsUnion = new Map;
        for (key in derivedVars.keySet()) {
            var derivedUnion = new Set;
            derivedUnion.addAll(derivedVars.get(key));
            for (d in derivedVars.get(key)) {
                for (du in derivedVars.get(d)) {
                    if (du <> key) {
                        derivedUnion.add(du);
                    }
                }
            }
            derivedVarsUnion.put(key, derivedUnion);
        }
        // From the one with the most, find which are missing and create the appropriate
        // edges between the vars and the mapping
        var mappingNode = reduceGraph.getNodeCopy(m, mergeMap);
        for (key in derivedVars.keySet().sortBy(k | derivedVars.get(k).size()).invert()) {
            var missing = inputVarNodes.excludingAll(derivedVars.get(key)).excluding(key);
            key.println("key ");
            missing.println("missing ");
            var e = reduceGraph.owningModel().createInstance("Edge");
            // If there is another edge to the input, is a double input
            if (reduceGraph.element.exists(e : ddg!Edge| e.source == mergeMap.get(key) and e.target == mappingNode)) {
                e.type = ddg!EdgeType#doublePrimaryInput;
            } else {
                e.type = ddg!EdgeType#primaryInput;
            }
            e.source = mergeMap.get(key);
            e.target = mappingNode;
            reduceGraph.element.add(e);
            for (d in derivedVars.get(key)) {
                var e = reduceGraph.owningModel().createInstance("Edge");
	            // If there is another edge to the input, is a double input
	            if (reduceGraph.element.exists(e : ddg!Edge| e.source == mergeMap.get(d) and e.target == mappingNode)) {
	                e.type = ddg!EdgeType#doubleDerivedInput;
	            } else {
	                e.type = ddg!EdgeType#derivedInput;
	            }
	            e.source = mergeMap.get(d);
	            e.target = mappingNode;
	            reduceGraph.element.add(e);
            }
            for (mis in missing) {
                // Add them if not already added
            }
        }
    }
}

/*
public boolean isMany() {
        Type type = getType();
        if (type instanceof CollectionType) {
            CollectionType collectionType = (CollectionType)type;
            IntegerValue upperValue = collectionType.getUpperValue();
            return !(upperValue instanceof UnlimitedValue) && (upperValue.intValue() > 1);
        }
        return false;
    }
*/