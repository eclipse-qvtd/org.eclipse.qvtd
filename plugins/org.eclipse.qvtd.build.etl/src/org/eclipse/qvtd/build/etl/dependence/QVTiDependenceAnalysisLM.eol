/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "OCLExpressionAnalysis.eol";

/** The input models */
// lTree    - Left containment tree
// mTree    - Left containment tree

/** The output models */
// imGraph  - The inter-mapping dependence graph
// ddGraph  - The data dependence graph
// mdGraph  - The merged data dependece graph
// rdGraph  - The reduced data dependece graph

var varMap : Map;       // (Variable, tree!Node)
var inputVarMap : Map;  // (mapping, Set{variable})
var outputVarMap : Map; // (mapping, Set{realizedVariable})
var nodeMap : Map;      // (mapping, graph!Node)
var dataNodeMap : Map;      // (??, graph!Node)

// For each mapping get the set of input and out put vars.
for (r in qvti!Transformation.all().first().rule) {
    //r.name.println();
    inputVarMap.put(r, r.getInputVars());
    outputVarMap.put(r, r.getOutputVars());
}

// 1. Inter-mapping dependencies
var img = new imGraph!Graph;
img.name = "InterMapping";
qvti!Transformation.all().first().interMappingDependencies(img, inputVarMap, outputVarMap);

// b. Create a directed graph in which an edge is created between a node
// (mapping) A and B, if an input var in B has the same type as an output
// var on A
var x = new Native("org.eclipse.qvtd.build.etl.PivotUtil");
for (rB in qvti!Transformation.all().first().rule) {
    //rB.name.println("From ");
    for (vB in inputVarMap.get(rB)) {
        //vB.name.println();
        // Search for compatible output vars (by type) in same side mappings (LM or MR))
        for (rA in qvti!Transformation.all().first().rule.excluding(rB)/* .select(
                r | r.domain.collect(d | d.typedModel).flatten()
                    .includesAll(rB.domain.collect(d | d.typedModel).flatten())
                )*/
            ) {
            for (vA in outputVarMap.get(rA)) {
                if (x.isKindOf(vA.type, vB.type)) {
                    //vA.name.println("to " + rA.name + " var ");
                    var e = new imGraph!Edge;
                    e.source = nodeMap.get(rA);
                    e.target = nodeMap.get(rB);
                    img.element.add(e);
                }
            }
        }
    }
}

// 2. Mapping data dependendence
var ddg = new ddGraph!Graph;
var varMap : Map;   // (var, ddGraph!Node) 

for (r in qvti!Transformation.all().first().rule.select(r | not r.context.isDefined())) {
    var mapN = new ddGraph!Node;
    mapN.label = r.name;
    //mapN.qvtAstNode = r;
    ddg.element.add(mapN);
    r.name.println();
    // a. Containment relations
    // i) input-input
    varMap.clear();
    for (vA in inputVarMap.get(r)) {
        //vA.println("vA ");
        var inputN = ddg.getNodeForVar(vA);
        var e = new ddGraph!Edge;
        e.source = inputN;
        e.target = mapN;
        e.type = ddGraph!EdgeType#primaryInput;   
        ddg.element.add(e);       
        for (vB in inputVarMap.get(r).excluding(vA)) {
            //vB.println("vB ");
            if (vA.hasContainmentRelation(vB)) {
                var inputN2 = ddg.getNodeForVar(vB);
                var ce = new ddGraph!Edge;
                if (vB.oppositePattern().area.name == "middle") {
                    ce.type = ddGraph!EdgeType#middleCont;    
                } else if(isInputDomain(vB.oppositePattern().area)) {
                    ce.type = ddGraph!EdgeType#inputCont;        
                } else if(isOutputDomain(vB.oppositePattern().area)) {
                    ce.type = ddGraph!EdgeType#outputCont;     
                }
                ce.source = inputN;
			    ce.target = inputN2;
			    ddg.element.add(ce);
            }
            if (vA.hasContainmentRelation(vB)) {
                var inputN2 = ddg.getNodeForVar(vB);
                var ce = new ddGraph!Edge;
                if (vB.oppositePattern().area.name == "middle") {
                    ce.type = ddGraph!EdgeType#middleCont;    
                } else if(isInputDomain(vB.oppositePattern().area)) {
                    ce.type = ddGraph!EdgeType#inputCont;        
                } else if(isOutputDomain(vB.oppositePattern().area)) {
                    ce.type = ddGraph!EdgeType#outputCont;     
                }
                ce.source = inputN;
			    ce.target = inputN2;
			    ddg.element.add(ce);
            }
            if (vA.hasMiddleRelation(vB)) {
                var inputN3 = ddg.getNodeForVar(vB);
                var re = new ddGraph!Edge;
                re.type = ddGraph!EdgeType#relation;
                re.source = inputN;
                re.target = inputN3;
                ddg.element.add(re);
            }
        }
    }
    // Output vars
    for (vA in outputVarMap.get(r)) {
        //vA.println("vA ");
        var outputN = ddg.getNodeForVar(vA);
        var e = new ddGraph!Edge;
        e.source = mapN;
        e.target = outputN;
        e.type = ddGraph!EdgeType#output;   
        ddg.element.add(e);       
        for (vB in outputVarMap.get(r).excluding(vA)) {
            //vB.println("vB ");
            if (vA.hasContainmentRelation(vB)) {
                var outputN2 = ddg.getNodeForVar(vB);
                var ce = new ddGraph!Edge;
                if (vB.oppositePattern().area.name == "middle") {
                    ce.type = ddGraph!EdgeType#middleCont;    
                } else if(isInputDomain(vB.oppositePattern().area)) {
                    ce.type = ddGraph!EdgeType#inputCont;        
                } else if(isOutputDomain(vB.oppositePattern().area)) {
                    ce.type = ddGraph!EdgeType#outputCont;        
                }
                ce.source = outputN;
                ce.target = outputN2;
                ddg.element.add(ce);
            }
        }
    }
    // Input to Output relations
    for (vIn in inputVarMap.get(r)) {
        //vA.println("vA ");
        var inputN = ddg.getNodeForVar(vIn);
        for (vOut in outputVarMap.get(r)) {
            //vB.println("vB ");
            if (vIn.hasContainmentRelation(vOut)) {
                var inputN2 = ddg.getNodeForVar(vOut);
                var ce = new ddGraph!Edge;
                if (vOut.oppositePattern().area.name == "middle") {
                    ce.type = ddGraph!EdgeType#middleCont;    
                } else if(isInputDomain(vOut.oppositePattern().area)) {
                    ce.type = ddGraph!EdgeType#inputCont;        
                } else if(isOutputDomain(vOut.oppositePattern().area)) {
                    ce.type = ddGraph!EdgeType#outputCont;        
                }
                ce.source = inputN;
                ce.target = inputN2;
                ddg.element.add(ce);
            }
            if (vIn.hasMiddleRelation(vOut)) {
                var inputN3 = ddg.getNodeForVar(vOut);
                var re = new ddGraph!Edge;
                re.type = ddGraph!EdgeType#middleRelation;
                re.source = inputN;
                re.target = inputN3;
                ddg.element.add(re);
            }
        }
    }
}

// 3. Merge Data dependencies
// Visit the data dependence graph ir ordered mode: start with mappings with
// the least number of inputs
var mdg = new mdGraph!Graph;
var mergeMap : Map;  // (x, Node)
// Copy all the containment trees to the mdGraph
importContainmentTree(mdg, lTree!Node.all(), mdGraph!NodeType#input, mdGraph!EdgeType#inputCont);
importContainmentTree(mdg, mTree!Node.all(), mdGraph!NodeType#middle, mdGraph!EdgeType#middleCont);
//importContainmentTree(mdg, rTree!Node.all(), mdGraph!NodeType#output, mdGraph!EdgeType#outputCont);

for (m in ddGraph!Node.all().select(n | n.type == ddGraph!NodeType#mapping).sortBy(n | n.incoming.size())) {
    // If an output var is abstract (i.e., doesn't exist in any of the containment
    // trees) don't add the mapping to the merged graph. Input abstract variables
    // are allowed because searching for elements of a type returns elements of the
    // type and all its sub-types.
    var outputVarNodes = m.outgoing.collect(e | e.target).flatten();
    
    
    var inputVarNodes = m.incoming.collect(e | e.source).flatten();
    // For each input variable, find the corresponding type in the domain
    // containment tree and make the connection. If the type is abstrac (does not 
    // exist in the tree), connect it to all its subtypes.
    //m.println("m" + loopCount + " ");
    var mappingNode = getNodeForNode(mdg, m);
    for (vN in inputVarNodes) {
        var sources = lTree!Node.all().select(n | (n.EClassifierName == vN.label) or n.superTypes.includes(vN.label)); 
        if (sources.isEmpty()) {
            sources = mTree!Node.all().select(n | (n.EClassifierName == vN.label) or n.superTypes.includes(vN.label));
        }
        if (sources.isEmpty()) {
            // Error. WE should never get here!
            vN.errln("Merge input Not valid type found for: ");
        }
        for (s in sources) {
            var e = new mdGraph!Edge;
            // If there is another edge to the input, is a double input
            if (mdGraph!Edge.all().exists(e | e.source == mergeMap.get(s) and e.target == mappingNode)) {
                e.type = mdGraph!EdgeType#doublePrimaryInput;
            } else {
                e.type = mdGraph!EdgeType#primaryInput;
            }
            e.source = mergeMap.get(s);
            e.target = mappingNode;
            mdg.element.add(e);
        }
    }
    for (vN in outputVarNodes) {
        var targets = lTree!Node.all().select(n | (n.EClassifierName == vN.label) or n.superTypes.includes(vN.label)); 
        if (targets.isEmpty()) {
            targets = mTree!Node.all().select(n | (n.EClassifierName == vN.label) or n.superTypes.includes(vN.label));
        }
        
        if (targets.isEmpty()) {
            // Error. WE should never get here!
            vN.errln("Merge output Not valid type found for: ");
        }
        for (t in targets) {
            var e = new mdGraph!Edge;
            e.type = mdGraph!EdgeType#output;
            e.source = mappingNode;
            e.target = mergeMap.get(t);
            mdg.element.add(e);
        }
    }
}


//4. Reduced data dependencies
var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
var rdg = new rdGraph!Graph;
// Analize the dependencies to identify which input variables can be derived from others
// primaryInputs are only the ones that don't have a containment relation or a 
// middle relation with other input vars
mergeMap.clear();
// Copy all the containment trees to the mdGraph
importContainmentTree(rdg, lTree!Node.all(), rdGraph!NodeType#input, rdGraph!EdgeType#inputCont);
importContainmentTree(rdg, mTree!Node.all(), rdGraph!NodeType#middle, rdGraph!EdgeType#middleCont);
//importContainmentTree(rdg, rTree!Node.all(), rdGraph!NodeType#output, rdGraph!EdgeType#outputCont);

for (m in ddGraph!Node.all().select(n | n.type == ddGraph!NodeType#mapping).sortBy(n | n.incoming.size())) {
    // If an output var is abstract (i.e., doesn't exist in any of the containment
    // trees) don't add the mapping to the merged graph. Input abstract variables
    // are allowed because searching for elements of a type returns elements of the
    // type and all its sub-types.
    
    var outputVarNodes = m.outgoing.collect(e | e.target).flatten();
    
    //if (not outputVarNodes.forAll(vN | lTree!Node.all().exists(n | n.type == vN.label)
    //       or mTree!Node.all().exists(n | n.type == vN.label)
    //        or rTree!Node.all().exists(n | n.type == vN.label))
    //        ) {
    //        continue;
    //    }
    
    var inputVarNodes = m.incoming.collect(e | e.source).flatten();
    // For each input variable, find the corresponding type in the domain
    // containment tree and make the connection. If the type is abstrac (does not 
    // exist in the tree), connect it to all its subtypes.
    //m.println("m" + loopCount + " ");
    var mappingNode = getNodeForNode(rdg, m);
    for (vN in inputVarNodes) {
        var sources = lTree!Node.all().select(n | (n.EClassifierName == vN.label) or n.superTypes.includes(vN.label)); 
        if (sources.isEmpty()) {
            sources = mTree!Node.all().select(n | (n.EClassifierName == vN.label) or n.superTypes.includes(vN.label));
        }
        if (sources.isEmpty()) {
            // Error. WE should never get here!
            vN.errln("Reduced input Not valid type found for: ");
        }
        for (s in sources) {
            var e = new rdGraph!Edge;
            var double : Boolean = false;   // If there is another edge to the input, is a double input
            var derived : Boolean = false;
            
            // Identify derived input variables. Derived variables are variables that can be assigned
            // from other variables, e.g. ownership or middle model reference
            // 1. 1st candidates are variables that don't have outgoing edges to other variable (the
            // same as if all the edges go to the  mapping)
            //if (vN.outgoing.exists(o | o.target = m)) {
            //    // 2. From these, look for any predicates that can help resolve them
            //    var mapping = qvti!Mapping.all().selectOne(om | om.name == m.label );
            //    // a. Get all the simple attribute navigation predicates
            //    for (p in mapping.guardPattern.predicate.
            //            includingAll(m.domain.collect(d | d.guardPattern).flatten()).
            //                select(p | p.isSimpleAttributeNavigation() and p.isArgumentVariable())) {
            //        //for (vN.outgoing.exists(o | o.target = m))
            //    }
            //} else {
            //    derived = true;
            // }
            if (rdGraph!Edge.all().exists(e | e.source == mergeMap.get(s) and e.target == mappingNode)) {
                if (rdGraph!Edge.all().select(e | e.source == mergeMap.get(s) and e.target == mappingNode)
                        .exists(o | o.type == mdGraph!EdgeType#derivedInput)) {
                    e.type = rdGraph!EdgeType#doubleDerivedInput;
                } else {
                    e.type = rdGraph!EdgeType#doublePrimaryInput;
                }
            } else {
                // Differentiate between primary and derived
                if (vN.outgoing.exists(o | inputVarNodes.includes(o.target))) {
                    e.type = rdGraph!EdgeType#derivedInput;
                } else {
                    e.type = rdGraph!EdgeType#primaryInput;
                }
            }
            e.source = mergeMap.get(s);
            e.target = mappingNode;
            rdg.element.add(e);
        }
    }
    for (vN in outputVarNodes) {
        var targets = lTree!Node.all().select(n | (n.EClassifierName == vN.label) or n.superTypes.includes(vN.label)); 
        if (targets.isEmpty()) {
            targets = mTree!Node.all().select(n | (n.EClassifierName == vN.label) or n.superTypes.includes(vN.label));
        }
        if (targets.isEmpty()) {
            // Error. WE should never get here!
            vN.errln("Reduced output Not valid type found for: ");
        }
        for (t in targets) {
            var e = new rdGraph!Edge;
            e.type = rdGraph!EdgeType#output;
            e.source = mappingNode;
            e.target = mergeMap.get(t);
            rdg.element.add(e);
        }
    }
}

"Done".println();

/* ==================================================================== */

operation importContainmentTree(graph, treeNodes, type, relation) {
    for (tn in treeNodes) {
        var n = graph.owningModel().createInstance("Node");
        n.label = tn.EClassifierName;
        n.type = type;
        mergeMap.put(tn, n);
        graph.element.add(n);
    }
    // Edges
    for (tn in treeNodes) {
        for (c in tn.children) {
            var e = graph.owningModel().createInstance("Edge");
            e.type = relation;
            e.source = mergeMap.get(tn);
            e.target = mergeMap.get(c);
            graph.element.add(e);
        }
    }  
}


operation getNodeForNode(graph, x : ddGraph!Node) : mdd!Node {
    var n;
    if (mergeMap.containsKey(x)) {
        n = mergeMap.get(x);
    } else {
        n = graph.owningModel().createInstance("Node");
        n.label = x.label;
        switch (x.type) {
	        case mdd!NodeType#mapping : n.type = mdGraph!NodeType#mapping;
	        case mdd!NodeType#input : n.type = mdGraph!NodeType#input;
	        case mdd!NodeType#middle : n.type = mdGraph!NodeType#middle;
	        case mdd!NodeType#output : n.type = mdGraph!NodeType#output;
	    }
        mergeMap.put(x, n);
        graph.element.add(n);
    }
    return n;
}


operation ddGraph!Graph getNodeForVar(v : QVT!Variable) : ddGraph!Node {
    var n;
    if (varMap.containsKey(v)) {
        n = varMap.get(v);
    } else {
        n = new ddGraph!Node;
        n.label = v.type.name;
        //n.qvtAstNode = v;
        varMap.put(v, n);
        if (v.oppositePattern().area.name == "middle") {
            n.type = ddGraph!NodeType#middle;
        } else if(isInputDomain(v.oppositePattern().area)) {
            n.type = ddGraph!NodeType#input;
        } else if(isOutputDomain(v.oppositePattern().area)) {
            n.type = ddGraph!NodeType#output;        
        } 
        self.element.add(n);
    }
    return n;
}


operation visitR(roots : Collection, ddg : ddGraph!Graph, rootDd : ddGraph!Node) {
    for (root in roots) {
        var gn = root.getGraphNode();
        var e = new ddGraph!Edge;
        e.source = rootDd;
        e.target = gn;
        ddg.element.add(e);
        dfsR(root);
    }
}

operation dfsR(rootNode : tree!Node) {
    for (child in rootNode.children) {
        outputVarDFS(child, outputVarMap);
    }
}

operation outputVarDFS(node : tree!Node, outputVarMap : Map) {
    // 1. Look for all mappings that have a realized variable of this Node Type
    for (m in outputVarMap.keySet()) {
        for (v in outputVarMap.get(m)) {
            if (v.type == node.type) {
                
            }
        }
    }
}


//////

operation qvti!Mapping getGraphNode() : ddGraph!Node  {
    if (dataNodeMap.containsKey(self)) {
        return dataNodeMap.get(self);
    } else {
        var gn = new ddGraph!Node;
	    gn.label = self.type;
	    //gn.qvtAstNode = self;
	    gn.color = ddGraph!Color#orange;
	    ddg.element.add(gn); 
	    dataNodeMap.put(self, gn);
    }
}

operation qvti!CoreDomain getGraphNode() : ddGraph!Node  {
    if (dataNodeMap.containsKey(self)) {
        return dataNodeMap.get(self);
    } else {
        var gn = new ddGraph!Node;
        gn.label = self.type;
        //gn.qvtAstNode = self;
        gn.color = ddGraph!Color#orange;
        ddg.element.add(gn);
        dataNodeMap.put(self, gn); 
    }
}

operation rTree!Node getGraphNode() : ddGraph!Node  {
    if (dataNodeMap.containsKey(self)) {
        return dataNodeMap.get(self);
    } else {
        var gn = new ddGraph!Node;
        gn.label = self.type;
        gn.color = ddGraph!Color#orange;
        ddg.element.add(gn); 
        dataNodeMap.put(self, gn);
    }
}


operation visitL(roots : Collection, ddg : ddGraph!Graph, rootDd : ddGraph!Node) {
    for (root in roots) {
        var gn = new ddGraph!Node;
        gn.label = root.elementName;
        ddg.element.add(gn);
        var e = new ddGraph!Edge;
        e.source = rootDd;
        e.target = gn;
        ddg.element.add(e);
        dfsL(root);
    }
}



// Root nodes don't have mappings associated
operation dfsL(rootNode : tree!Node) {
    for (child in rootNode.children) {
        depthSearchL(child, new Set, qvti!Transformation.all().first().rule);
    }
}


operation depthSearchL(node : tree!Node, hierarchySpace : Collection, searchSpace : Collection) : Collection {
    // 1. Search for mappings in my hierarchy
    var hierarchyMapps = node.getLMapps(hierarchySpace);
    var unused = hierarchySpace.excludingAll(hierarchyMapps);
    // 2. Search for mappings outside my hierarchy
    var searchSpaceMapps = node.getLMapps(searchSpace);
    // The new hierarchy is the old plus the new
    hierarchyMapps = hierarchyMapps.includingAll(searchSpaceMapps);
    // The seearch space can't contain the new hierarchy
    searchSpace = searchSpace.excludingAll(hierarchyMapps);
    // My children should look into my hierarchy and the rest;
    for (child in node.children) {
        hierarchyMapps = depthSearchL(child, hierarchyMapps, searchSpace);
    }
    if(tNodeMapping.containsKey(node)) {
        hierarchyMapps = hierarchyMapps.includingAll(tNodeMapping.get(node));
    }
    tNodeMapping.put(node, hierarchyMapps);
    return unused;
}

operation depthSearchR(node : tree!Node, hierarchySpace : Collection, searchSpace : Collection) : Collection {
    // 1. Search for mappings in my hierarchy
    var hierarchyMapps = node.getRMapps(hierarchySpace);
    var unused = hierarchySpace.excludingAll(hierarchyMapps);
    // 2. Search for mappings outside my hierarchy
    var searchSpaceMapps = node.getRMapps(searchSpace);
    // The new hierarchy is the old plus the new
    hierarchyMapps = hierarchyMapps.includingAll(searchSpaceMapps);
    // The seearch space can't contain the new hierarchy
    searchSpace = searchSpace.excludingAll(hierarchyMapps);
    // My children should look into my hierarchy and the rest;
    for (child in node.children) {
        hierarchyMapps = depthSearchR(child, hierarchyMapps, searchSpace);
    }
    if(tNodeMapping.containsKey(node)) {
        hierarchyMapps = hierarchyMapps.includingAll(tNodeMapping.get(node));
    }
    tNodeMapping.put(node, hierarchyMapps);
    return unused;
}

operation tree!Node getLMapps(mapps : Collection) : Collection {
    // Find the predicates that use variables of the node's and its parent's type,
    // and that are containment opposite tests
    return mapps.select(m | m.testMappingL(self));    
}

operation tree!Node getRMapps(mapps : Collection) : Collection {
    // Find the predicates that use variables of the node's and its parent's type,
    // and that are containment opposite tests
    return mapps.select(m | m.testMappingR(self));    
}

// L type nodes are tested for predicates or single input var 
operation qvti!Rule testMappingL(tNode : tree!Node) : Boolean {
    // Once the partition is done, this should only look for predicates in the guard patterns
    
    var prediactes =  self.guardPattern.predicate
            .includingAll(self.domain.collect(d | d.guardPattern).flatten().collect(gp | gp.predicate).flatten())
            .includingAll(self.domain.collect(d | d.bottomPattern).flatten().collect(gp | gp.predicate).flatten());
    if (prediactes.isEmpty()) {
        // The mapping has no predicates??
        // It must have only 1 input variable, and the variable must be
        // of he same type of the tree Node
        if (inputVarMap.get(self).size() == 1) {
            return inputVarMap.get(self).exists(v | v.type.name == tNode.elementName);
        }
    }
    else {
        for (p in prediactes) {
            //p.conditionExpression.toString().println();
            if (p.conditionExpression.isSimpleAttributeNavigation()) {
                // Does the predicate is single "domained", all variables belong to the same domain
                if (p.conditionExpression.isSingleDomained()) {
                    // Are both the node's and its parent's type used in the predicate
                    if (p.conditionExpression.findRreferencedVariables()
                            .forAll(v | v.type.name == tNode.elementName or v.type.name == tNode.parent.elementName)) {
                        // Find if the navigated property is a containment opposite.
                        var prop = p.conditionExpression.getNavigatedProperty();
                        if (prop.opposite.isDefined() and prop.opposite.isComposite()) {
                            return true;
                        }
                    }
                    
                }
            }
        }
    }
    return false;
}

// R type nodes are tested for assignments or single input realized vars
operation qvti!Rule testMappingR(tNode : tree!Node) : Boolean {
    // Once the partition is done, this should only look for assignments in the R domain's bottom pattern
    //self.name.println("testMappingR ");
    var assignments =  self.domain.select(d | d.isEnforceable).collect(d | d.bottomPattern).flatten().collect(gp | gp.assignment).flatten();
    if (assignments.isEmpty()) {
        // The bottom pattern has no predicates
        // It must have only 1 realize variable, and the variable must be
        // of he same type of the tree Node
        if (outputVarMap.get(self).size() == 1) {
            return outputVarMap.get(self).exists(v | v.type.name == tNode.elementName);
        }
    }
    else {
        for (a in assignments) {
            //a.toString().println();
            if (a.isSimpleAttributeNavigation()) {
                // Does the predicate is single "domained", all variables belong to the same domain
                if (a.isSingleDomained()) {
                    // Are both the node's and its parent's type used in the predicate
                    if (a.findRreferencedVariables()
                            .forAll(v | v.type.name == tNode.elementName or v.type.name == tNode.parent.elementName)) {
                        // Find if the navigated property is a containment opposite.
                        var prop = a.targetProperty;
                        if (prop.opposite.isDefined() and prop.opposite.isComposite()) {
                            // Check that there are none realized variables of my parent's type
                            return not outputVarMap.get(self).exists(v | v.type.name == tNode.parent.elementName);
                            //return true;
                        }
                    }
                    
                }
            } else if (a.isPrimitiveVarAssignemnt()) {
                if (isOutputDomain(a.targetVariable.oppositePattern().area)) {
                    return a.targetVariable.type.name == tNode.elementName;   
                }
            }
        }
    }
    return false;
}


// Create a Dada Dependence graph of just the mappings. 
// For each node of a mm tree, craete a node for each mapping.
// Create an Edge from this node, to the node created for the
// maping of each of its nodes.

operation createDomainTreeMappingDependence(roots : Collection, ddg : ddGraph!Graph, rootDd : ddGraph!Node) {
    for (root in roots) {
        var gn = new ddGraph!Node;
        gn.label = root.elementName;
        ddg.element.add(gn);
        var e = new ddGraph!Edge;
        e.source = rootDd;
        e.target = gn;
        ddg.element.add(e);
        dfs(root);
    }
}


operation TypedModel getMetaModel() : EmfModel {
    
}
