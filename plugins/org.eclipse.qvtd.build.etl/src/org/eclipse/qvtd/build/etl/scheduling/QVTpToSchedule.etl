/*******************************************************************************
 * Copyright (c) 2014 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "../helpers/QVTHelpers.eol";
import "../helpers/QVTsHelpers.eol";
//import "Scheduler.eol";
 
/****t* /org.eclipse.qvtd.build.etl/scheduling/QVTpToSchedule
 * NAME
 *  QVTpToSchedule -- Craetes the base schedule from a partitioned (QVTp)
  * transformation
 * FUNCTION
 *  Extract the basic Schedule information from the QVTp trnasformation. The QVTp
 *  trasnformation must conform to QVTi. The basic schedule craetes the Class and
 *  Parameter information but does not reduce the DistinctData information (i.e.
 *  does not perform derivation analysis.
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/scheduling/DerivationAnalysis
 *    
 */

/****u* QVTpToSchedule/TransformationToSchedule
 * NAME
 *  TransformationToSchedule - Transform the trnsformation
 * FUNCTION
 *  Just creates the place holder for datums and actions
 * FROM
 *  QVTp!Transformation
 * TO
 *  QVTs!Schedule
 */
rule TransformationToSchedule
    transform t : QVTp!Transformation
    to s : QVTs!Schedule {
        
    }

/****u* QVTpToSchedule/MappingToMappingAction
 * NAME
 *  MappingToMappingAction - A mapping genereates a mapping action and its datums
 * FUNCTION
 *  Visit the mapping input/ouput variables to create the appropriate results and
 *  arguments.
 * FROM
 *  QVTp!Mapping
 * TO
 *  QVTs!MappingAction
 */
rule MappingToMappingAction
    transform m : QVTp!Mapping
    to ma : QVTs!MappingAction {
        
        --m.name.println();
        ma.schedule ::= m.transformation;
        ma.mapping = m;
        ma.results.addAll(m.getOutputVariables().collect(v | v.type).equivalent());
        ma.distinctArguments.addAll(m.getInputVariables().equivalents().collect(e | e.first()));
        ma.arguments.addAll(ma.getDistinctDataClassDatums());
    }

/****u* QVTpToSchedule/VariableToDataParameter
 * NAME
 *  VariableToDataParameter - Variables and RealizedVariables are transformed
 *  into a DistinctData and a DataParameter.
 * FUNCTION
 *  All Variables are treated as initialy treated as primary arguments. Analysis
 *  of derivation is done in a later stage.
 * FROM
 *  QVTp!Variable
 * TO
 *  QVTs!DistinctData, QVTs!DataParameter
 * ANNOTATIONS
 *  lazy        Lazy variables from iterators and not automatically transformed
 *  greedy      Greedy so we also transform RealizedVariables
 */
@lazy
@greedy
rule VariableToDataParameter
    transform v : QVTp!Variable
    to dd : QVTs!DistinctData, dp : QVTs!DataParameter {
        
        --v.name.println("var ");
        dp.variable = v;
        dp.datum ::= v.type;       
        dd.primaryArguments.add(dp);
            
    }

// Only types in the TypedModel pacakges and that are used by a variable
@lazy
@greedy
rule TypeToClassDatum
    transform t : QVTp!Type
    to d : QVTs!ClassDatum {
                         
        guard : t.producesDatums()
        
        var domain;
        if (t.existsCorePatternVariable()) {
        	// FIXME What if we have different variables belonging to different domains ?
        	domain = t.getCorePatternVariables().first().oppositePattern().area;
        } else {
        	domain = null; 
        }
         
        --t.name.println("TypeToDatum ");
        d.type = t;
        d.super.addAll(t.superClasses.equivalent());
 		d.domain = domain;
 		d.schedule ::= QVTp!Transformation.all.first();
    }

@greedy 
rule PropertyCallExpToPropertyDatum
    transform pCallExp : QVTp!PropertyCallExp
    to pDatum : QVTs!PropertyDatum{
       
		guard { 
			var propContext = pCallExp.getContextType();
			var refProperty = pCallExp.referredProperty;
			return pCallExp.isContainedInAnArea() and refProperty.propertyDatumNotCreated(propContext);
		}
		var propContext = pCallExp.getContextType();
		var refProperty = pCallExp.referredProperty;
		pDatum.updatePropertyDatum(propContext,refProperty);
		pDatum.createOppositePropDatum(false);
	}

-- greedy to also consider MiddlePropertyCallExp
@greedy
rule OppositePropertyCallExpToPropertyDatum
    transform oPropCallExp : QVTp!OppositePropertyCallExp
    to pDatum : QVTs!PropertyDatum{
       
		guard { 
			var propContext = oPropCallExp.getContextType();
			var refProperty = oPropCallExp.referredProperty.opposite;
       		return pCallExp.isContainedInAnArea() and refProperty.propertyDatumNotCreated(propContext);
		}
		var propContext = oPropCallExp.getContextType();
		var refProperty = oPropCallExp.referredProperty.opposite;
		pDatum.updatePropertyDatum(propContext,refProperty);
		// With OppositePropertyCallExps we don't need to create oppositePropDatum
		// because there is no opposite property 
	}


-- greedy to also consider MiddlePropertyAssignment
@greedy    
rule PropertyAssignmentToPropertyDatum 
    transform pAssign : QVTp!PropertyAssignment
    to pDatum : QVTs!PropertyDatum {
       
		guard { 
			var propContext = pAssign.getContextType();
			var refProperty = pAssign.targetProperty;
			var isOpposite = pAssign.isKindOf(QVTp!MiddlePropertyAssignment);
       		return refProperty.propertyDatumNotCreated(propContext);
		}
     	var propContext = pAssign.getContextType();
		var refProperty = pAssign.targetProperty;
     	pDatum.updatePropertyDatum(propContext, refProperty);
		pDatum.createOppositePropDatum(true);
	}

--
-- Since operations might have other PropertyCallExp and OperationCallExp of interest, they have
-- to be individually analyzed. We will start the analysis from OperationCallExps which are used
-- from expression which belong to the mapping (or any of their CorePatterns)
--
-- Note that the original context type on which the operation is called, needs to be carried on
-- through the anlysis, so the proper PropertyDatums are accordingly created
--
rule OperationCallExpToPropertyDatums
	transform opCall : QVTp!OperationCallExp
	to pDatums : OrderedSet(QVTs!PropertyDatum) {

	// We are only interested in operation call expressions made from expressions
	// belonging to the mappings (or any of their CorePatterns)
	guard : opCall.isContainedInAnArea()
	
	var context = opCall.getContextType();
	pDatums.addAll(opCall.analyseOCLExpression(context, Map{}).println("Analysis result: "));
}

operation QVTp!OperationCallExp analyseOCLExpression(context : QVTp!Type, type2VisitedOperations : Map) : OrderedSet(QVTp!PropertyDatum) {
		
	var visitedOps = type2VisitedOperations.get(context);
	if (visitedOps = null) {
		visitedOps = Set{};
		type2VisitedOperations.put(context, visitedOps);
	}
	
	var result = OrderedSet{};
	var op = self.referredOperation;
	
	if (not visitedOps.contains(op)) {
		context.name.print("Op analised: ");
		op.name.println("::");
		visitedOps.add(op);
		// If is oclContainer() 		
		var expInOCL = op.getBodyExpression();
		if (expInOCL <> null) {
			var oclExp = expInOCL.getOwnedBody();
			for (eObject in oclExp.getAllContentsIncludingSelf()) {
				if (eObject.isKindOf(QVTp!PropertyCallExp) or eObject.isKindOf(QVTp!OperationCallExp)) { // Fixme Opposite ? 
					result.addAll(eObject.analyseOCLExpression(eObject.getContextType(context), type2VisitedOperations));
				}
			}
		}
	}
	return result;
}


operation QVTp!PropertyCallExp analyseOCLExpression(context : QVTp!Type, type2VisitedOperations) : OrderedSet(QVTp!PropertyDatum) {

	var refProperty = self.referredProperty;
	if (refProperty.propertyDatumNotCreated(context)) {
		var pDatum = new QVTs!PropertyDatum;
		pDatum.updatePropertyDatum(context,refProperty);
		pDatum.createOppositePropDatum(false);
		return pDatum.asOrderedSet();
	} else {
		return OrderedSet{};
	}
}

--
-- PropertyDatums can be created either via an ETL rule or 'new' statment. Whereas PropertyDatums can 
-- be differently created, this common subroutine will accordignly update the properties of those PropertyDatums.
--
operation QVTs!PropertyDatum updatePropertyDatum(context: QVTp!Type, prop : QVTp!Property) {

	var classDatum ::= context;
	--context.name.print("Updating property for ");
	--prop.name.println("::");
	self.domain = classDatum.domain;
	self.property = prop;
    self.classDatum = classDatum;
    if (context <> prop.owningClass) { // Propagate to supertypes as long as the context is not the property owner
	    for (superClass in context.superClasses) {
	    	if (superClass.producesDatums() and prop.propertyDatumNotCreated(superClass)) {
		    	var superPropDatum = new QVTs!PropertyDatum;
		    	self.super.add(superPropDatum);    	    	
		    	superPropDatum.updatePropertyDatum(superClass, prop);
	    	}
	    }
    }
}

operation QVTs!PropertyDatum createOppositePropDatum(relationToOpposite : Boolean) {
	var oppProp = self.property.opposite;
    if (oppProp.isDefined()) {
    	var oppPropContext = oppProp.owningClass;
    	if (oppPropContext.producesDatums()) {
	    	var oppositePropDatum = oppProp.getPropertyDatum(oppPropContext);
	    	if (oppositePropDatum.isUndefined()) {
	    		oppositePropDatum = new QVTs!PropertyDatum;
		    	oppositePropDatum.updatePropertyDatum(oppPropContext, oppProp);
	    	}
	    	if (relationToOpposite) {
	    		self.opposite = oppositePropDatum;
	    	} else {
	    		oppositePropDatum.opposite = self;
	    	}
    	}
    }
}

operation QVTp!Property propertyDatumNotCreated(context : QVTp!Type) : Boolean {
    return self.getPropertyDatum(context).isUndefined();
}

operation QVTp!Property getPropertyDatum(context : QVTp!Type) {
	var classDatum = context.equivalent();
    if (classDatum.isUndefined()) {
    	return null;
    } else {
    	return classDatum.propertyDatums.selectOne(x | x.property = self);
    }
}

operation QVTp!PropertyCallExp getPropertyDatum() : QVTs!PropertyDatum {
	return self.referredProperty.getPropertyDatum(self.ownedSource.type);
} 

operation QVTp!OppositePropertyCallExp getPropertyDatum() : QVTs!PropertyDatum {
	return self.referredProperty.opposite.getPropertyDatum(self.ownedSource.type);
}

operation QVTp!PropertyAssignment getPropertyDatum() : QVTs!PropertyDatum {
	return self.targetProperty.getPropertyDatum(self.slotExpression.type);
}

@cached
operation QVTp!Type producesDatums() : Boolean {
	return self.existsCorePatternVariable() or self.hasUsedProperties();
}

@cached
operation QVTp!Type existsCorePatternVariable() : Boolean {
	return self.getCorePatternVariables().notEmpty();
}

@cached
operation QVTp!Type getCorePatternVariables() : OrderedSet(QVTp!Variable) {
	return QVTp!Variable.all().asOrderedSet().select(v | v.eContainer().isKindOf(QVTp!CorePattern) 
		and self.getAllSuperTypes().select(x | x.existsCorePatternVariable()).including(v.type).includes(self));
}

@cached
operation QVTp!Type getAllSuperTypes() : OrderedSet {
	return self.asSequence().closure(x | x.superClasses).asOrderedSet();
}

@cached
operation QVTp!Type hasUsedProperties() : Boolean {
	return self.getUsedProperties().notEmpty();
}

@cached 
operation QVTp!Type getUsedProperties() : OrderedSet(QVTp!Property) {
	var allSuperTypes = self.asSequence().closure(x | x.superClasses).asOrderedSet();
	// TODO Using all() ->  might bring properties from PropCallExp unused operation. Improve analysis
	var allForwardPropCalls = QVTp!PropertyCallExp.all();
	var allForwardPropAssigns = QVTp!PropertyAssignment.all();
	var allUsedForwardProps = allForwardPropCalls.collect(x | x.referredProperty).asOrderedSet();
	allUsedForwardProps.addAll(allForwardPropAssigns.collect(x | x.targetProperty));
	
	var allOppositePropCalls = QVTp!OppositePropertyCallExp.all();
	var allUsedOppositeProps = allOppositePropCalls.collect(x | x.referredProperty).asOrderedSet();
	
	return
		allUsedForwardProps.select(x | allSuperTypes.including(self).includes(x.owningClass)).includingAll(
		allUsedOppositeProps.select(x | self = x.type));
}

@cached
operation QVTp!OCLExpression getSourceVariable() : QVTp!Variable {
    -- return self.asSequence().closure(x | if x.isKindOf(QVTp!CallExp) x.ownedSource else Collection{}).one(x | x.isKindOf(QVTp!VariableExp).variable;
    var exp = self;
	while (true) {
		if (exp.isKindOf(QVTp!VariableExp)) {
			return exp.referredVariable;
		}
		if (not exp.isKindOf(QVTp!CallExp)) {
			return null;
		}
		exp = exp.ownedSource;
	}
}

@cached
operation QVTp!PropertyAssignment getSourceVariable() : QVTp!Variable { 
	return self.slotExpression.getSourceVariable(); 
}

@cached
operation QVTp!Mapping getPropertyAssignments() : Sequence { 
	return self.asSequence().closure(x | x.eContents()).select(x | x.isKindOf(QVTp!PropertyAssignment));
}

@cached
operation QVTp!Mapping getPropertyAccesses() : Sequence { 
	return self.asSequence().closure(x | x.eContents()).select(x | x.isKindOf(QVTp!PropertyCallExp) or x.isKindOf(QVTp!OppositePropertyCallExp));
}

@cached
operation QVTp!CallExp getContextType() : QVTp!Type {
	return self.ownedSource.type;
}


-- This is needed when analysing Property/Operation call exps so that they exploit the statically computed context 
-- carried on through the analysis. When ever self variable is referred, the provided context will be the returned
-- context type 
@cached
operation QVTp!CallExp getContextType(context : QVTp!Type) : QVTp!Type {
	var source = self.ownedSource;
	if (source.isTypeOf(QVTp!VariableExp) and source.referredVariable.name = "self") {
		return context;
	} else {
		return source.type;
	}
}

@cached
operation QVTp!PropertyAssignment getContextType() : QVTp!Type {
	return self.slotExpression.type;
}

@cached 
operation QVTp!OCLExpression isContainedInAnArea() : Boolean {

	var container = self.eContainer();
	while (container <> null) {
		if (container.isKindOf(QVTp!Area)) {
			return true;
		}
		container = container.eContainer();
	}
	return false;
}

@cached 
operation QVTp!OCLExpression getAllContents() : Sequence {
	return self.asSequence().closure(x | x.eContents());
}

operation QVTp!OCLExpression getAllContentsIncludingSelf() : Sequence {
	var initSeq = self.asSequence(); 
	return initSeq.includingAll(initSeq.closure(x | x.eContents()));
}

post{
	// Traces can't be used because only one pDatum access/assignment is associated with the pDatum via traces
	// Therefore, update the arguments/results at the end
	for (ma in  QVTs!MappingAction.all) {
		var m = ma.mapping;
		var consumedPDatums = m.getPropertyAccesses().collect(x | x.getPropertyDatum());
		var producedPDatums = m.getPropertyAssignments().collect(x | x.getPropertyDatum()).asOrderedSet();
		producedPDatums.addAll(producedPDatums.opposite.select(x | x.isDefined())); // We want all the opposite produced by them
		ma.results.addAll(producedPDatums);
		ma.arguments.addAll(consumedPDatums);
	} 
	
	
    "QVTpToSchedule Done".println();
}    
