/*******************************************************************************
 * Copyright (c) 2014 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "../helpers/QVTHelpers.eol";
import "../helpers/QVTsHelpers.eol";
//import "Scheduler.eol";
 
/****t* /org.eclipse.qvtd.build.etl/scheduling/QVTpToSchedule
 * NAME
 *  QVTpToSchedule -- Craetes the base schedule from a partitioned (QVTp)
  * transformation
 * FUNCTION
 *  Extract the basic Schedule information from the QVTp trnasformation. The QVTp
 *  trasnformation must conform to QVTi. The basic schedule craetes the Class and
 *  Parameter information but does not reduce the DistinctData information (i.e.
 *  does not perform derivation analysis.
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/scheduling/DerivationAnalysis
 *    
 */

/****u* QVTpToSchedule/TransformationToSchedule
 * NAME
 *  TransformationToSchedule - Transform the trnsformation
 * FUNCTION
 *  Just creates the place holder for datums and actions
 * FROM
 *  QVTp!Transformation
 * TO
 *  QVTs!Schedule
 */
rule TransformationToSchedule
    transform t : QVTp!Transformation
    to s : QVTs!Schedule {
        
    }

/****u* QVTpToSchedule/MappingToMappingAction
 * NAME
 *  MappingToMappingAction - A mapping genereates a mapping action and its datums
 * FUNCTION
 *  Visit the mapping input/ouput variables to create the appropriate results and
 *  arguments.
 * FROM
 *  QVTp!Mapping
 * TO
 *  QVTs!MappingAction
 */
rule MappingToMappingAction
    transform m : QVTp!Mapping
    to ma : QVTs!MappingAction {
        
        //m.name.println();
        ma.schedule ::= m.transformation;
        ma.mapping = m;
        ma.results.addAll(m.getOutputVariables().collect(v | v.type).equivalent());
        ma.results.addAll(m.getPropertyAssignments().equivalent());
        ma.distinctArguments.addAll(m.getInputVariables().equivalents().collect(e | e.first()));
		ma.arguments.addAll(ma.getDistinctDataClassDatums());
		ma.arguments.addAll(m.getPropertyAccesses().equivalent());        
    }

/****u* QVTpToSchedule/VariableToDataParameter
 * NAME
 *  VariableToDataParameter - Variables and RealizedVariables are transformed
 *  into a DistinctData and a DataParameter.
 * FUNCTION
 *  All Variables are treated as initialy treated as primary arguments. Analysis
 *  of derivation is done in a later stage.
 * FROM
 *  QVTp!Variable
 * TO
 *  QVTs!DistinctData, QVTs!DataParameter
 * ANNOTATIONS
 *  lazy        Lazy variables from iterators and not automatically transformed
 *  greedy      Greedy so we also transform RealizedVariables
 */
@lazy
@greedy
rule VariableToDataParameter
    transform v : QVTp!Variable
    to dd : QVTs!DistinctData, dp : QVTs!DataParameter {
        
        //v.name.println("v ");
        dp.variable = v;
        dp.datum ::= v.type;
        dd.primaryArguments.add(dp);
    }

// Only types in the TypedModel pacakges and that are used by a variable
@lazy
@greedy
rule TypeToClassDatum
    transform t : QVTp!Type
    to d : QVTs!ClassDatum {
        
        guard : QVTp!Variable.all().exists(v | v.type == t)
        
        var domain = t.getVariableForType().oppositePattern().area; 
        //t.name.println("TypeToDatum ");
        d.type = t;
        d.super.addAll(t.superClass.equivalent());
        d.domain = domain;
        d.schedule ::= domain.`rule`.transformation;    
    }

-- greedy to also consider MiddlePropertyCallExp
@greedy 
rule PropertyCallExpToPropertyDatum
    transform pCallExp : QVTp!PropertyCallExp
    to pDatum : QVTs!PropertyDatum{
       
		guard { 
			var propContext = pCallExp.getContextType();
			var refProperty = pCallExp.referredProperty;
       		return refProperty.propertyDatumNotCreated(propContext);
		}
     	pDatum.updatePropertyDatum(null, 
     		pCallExp.getContextType(), 
     		pCallExp.referredProperty);     		
    }


-- greedy to also consider MiddlePropertyAssignment
@greedy    
rule PropertyAssignmentToPropertyDatum 
    transform pAssign : QVTp!PropertyAssignment
    to pDatum : QVTs!PropertyDatum {
       
		guard { 
			var propContext = pAssign.getContextType();
			var refProperty = pAssign.targetProperty;
       		return refProperty.propertyDatumNotCreated(propContext);
		}
     	pDatum.updatePropertyDatum(null, 
     		pAssign.getContextType(), 
     		pAssign.targetProperty);
     	     	
	}

operation QVTs!PropertyDatum updatePropertyDatum(domain : QVTp!Domain, context: QVTp!Type, prop : QVTp!Property ) {

	self.domain = domain;
	self.property = prop;
    self.classDatum ::= context;
    for (superClass in context.superClass) {
    	if (prop.propertyDatumNotCreated(superClass)) {
	    	var superPropDatum = new QVTs!PropertyDatum;
	    	self.super.add(superPropDatum);    	    	
	    	superPropDatum.updatePropertyDatum(domain, superClass, prop);
    	}
    }
}

operation QVTp!Property propertyDatumNotCreated(context : QVTp!Type) : Boolean {
    var classDatum = context.equivalent();
    if (classDatum.isUndefined()) {
    	return false;
    } else {
    	return not classDatum.propertyDatums.exists(x | x.property = self);
    }
}

/*
operation QVTp!PropertyCallExp getCorrespondingDomain() : QVTp!Domain {
	var source = self.source;
	while (true) {
		if (source.isKindOf(QVTp!VariableExp)) {
			return source.referredVariable.getContainingDomain();
		}
		if (source.isKindOf(QVTp!CallExp)) {
			source = source.source;
		} else {
			return null;
		}
	}
} 
 
 
operation QVTp!Element getContainingDomain() : QVTp!Domain {
	var container = self.eContainer();
	while (container.isDefined()) {
		if (container.isKindOf(QVTp!Domain)) {
			return container;
		}
		container = container.eContainer();
	}
	return null;
}*/

@cached
operation QVTp!Type getVariableForType() : QVTp!Variable {
    return QVTp!Variable.all().selectOne(v | v.type == self or v.type.superClass.includes(self)); -- FIXME what about superClasses of superClasses ?
}

@cached
operation QVTp!OCLExpression getSourceVariable() : QVTp!Variable {
    -- return self.asSequence().closure(x | if x.isKindOf(QVTp!CallExp) x.source else Collection{}).one(x | x.isKindOf(QVTp!VariableExp).variable;
    var exp = self;
	while (true) {
		if (exp.isKindOf(QVTp!VariableExp)) {
			return exp.referredVariable;
		}
		if (not exp.isKindOf(QVTp!CallExp)) {
			return null;
		}
		exp = exp.source;
	}
}

@cached
operation QVTp!PropertyAssignment getSourceVariable() : QVTp!Variable { 
	return self.slotExpression.getSourceVariable(); 
}

@cached
operation QVTp!Mapping getPropertyAssignments() : Collection { 
	return self.asSequence().closure(x | x.eContents()).select(x | x.isKindOf(QVTp!PropertyAssignment));
}

@cached
operation QVTp!Mapping getPropertyAccesses() : Collection { 
	return self.asSequence().closure(x | x.eContents()).select(x | x.isKindOf(QVTp!PropertyCallExp));
}

@cached
operation QVTp!PropertyCallExp getContextType() : QVTp!Type {
	return self.source.type;
}

@cached
operation QVTp!PropertyAssignment getContextType() : QVTp!Type {
	return self.slotExpression.type;
}

post{
    "QVTpToSchedule Done".println();
}    