/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/

/****l* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers
 * NAME
 *  QVTiDependenceAnalysis -- A set of operations to query, format, interpret, 
 *  etc., information from a QVTc model. 
 * NOTES
 *  Some of this operations can/should be moved to the QVTcore model/code 
 * SEE ALSO
 *    
 */

/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isInputDomain
 * NAME
 *  isInputDomain - Returns true if the area is of type QVT!CoreDomain and it's 
 *  TypedModel is the input domain.
 *
 * CONTEXT
 *  QVT!Area  The are under test
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isMiddleDomain
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isOutputDomain
 */
@chached
operation QVT!Area isInputDomain() : Boolean {
    return self.isTypeOf(QVT!CoreDomain) and
        config!Configuration.all.first().inputDirection.name == self.typedModel.name;
}

/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isMiddleDomain
 * NAME
 *  isMiddleDomain - Returns true if the area belongs to the middle domain, i.e.
 *  it is a QVT!Mapping.
 *
 * CONTEXT
 *  QVT!Area  The are under test
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isInputDomain
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isOutputDomain
 */
@chached
operation QVT!Area isMiddleDomain() : Boolean {
    return self.isTypeOf(QVT!Mapping);
}

/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isOutputDomain
 * NAME
 *  isOutputDomain - Returns true if the area is of type QVT!CoreDomain and it's 
 *  TypedModel is the output domain.
 *
 * CONTEXT
 *  QVT!Area  The are under test
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isInputDomain
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isMiddleDomain
 */
@chached
operation QVT!Area isOutputDomain() : Boolean {
    return self.isTypeOf(QVT!CoreDomain) and
        config!Configuration.all.first().outputDirection.collect(od | od.name).includes(self.typedModel.name);
}

/**
 * Returns true if the transformation is invoked in check mode.
 */
operation isCheckMode() : Boolean {
    return config!Configuration.all.first().mode == config!Mode#checking;
}

/**
 * Returns true if the transformation is invoked in enforce mode.
 */
operation isEnforceMode() : Boolean {
    return config!Configuration.all.first().mode == config!Mode#enforcement;
}



/**
 * Returns the typed model of a tranformation that corresponds to the middle
 * model.
 */
operation QVT!Transformation getMiddleTypedModel() : QVT!TypedModel {

    return self.modelParameter.selectOne(tm | tm.name = config!Configuration.all.first().middle.name);
}

/**
 * Returns the pattern to which a variable belongs.
 * <p>
 * The operation is @chached to improve performance.
 */
@cached
operation QVT!Variable oppositePattern() : QVT!CorePattern  {
    
    if(self.isTypeOf(QVT!Variable)) {
        return QVT!CorePattern.all.selectOne(p |p.variable.includes(self));
    } else if (self.isTypeOf(QVT!RealizedVariable)) {
        return QVT!BottomPattern.all.selectOne(p |p.realizedVariable.includes(self));
    }
}

/**
 * Returns the area that defines the environment of an OCL expression. The results
 * depends on the type of the OCL expression. 
 * <p>
 * The operation is @chached to improve performance.
 */
@cached
operation QVT!OCLExpression getArea() : QVT!Area {
    if (self.isTypeOf(QVT!VariableExp)) {
        if (self.referredVariable.type() == null) {
            return null;
        }
        return self.referredVariable.oppositePattern().area;
    } else if (self.isKindOf(QVT!CallExp)) {
        return self.source.getArea();
    } else if (self.isTypeOf(QVT!IfExp)) {
        return self.condition.getArea();
    } else if (self.isKindOf(QVT!LiteralExp)) {
        return null;
    } else {
        self.println();
        throw "Error! Add getArea for " + self.type();
    }
    return null;
}



/**
 * Returns the set of variables used in the assignemnt 
 */
operation QVT!Assignment findReferencedVariables() : Set {
    
    var varRefs : Set();
    varRefs = self.value.findReferencedVariables();
    if (self.isTypeOf(QVT!PropertyAssignment)) {
        varRefs.addAll(self.slotExpression.findReferencedVariables());
    } else if (self.isTypeOf(QVT!VariableAssignment)) {
        varRefs.add(self.targetVariable);
    }
    return varRefs;
}


 
/**
 * Retypes a variable to the less abstract type of all variables in the patterns
 * with the same name.
 *
 * @param patterns the patterns to look for variables with the same name 
 */  
operation QVT!Variable retypeVar(pattern : QVT!Pattern) {
    var refinedVars = pattern.variable.select(
                    v | v.name == self.name
                    );
    if (refinedVars.size() > 0) {
        var x = new Native("org.eclipse.qvtd.build.etl.PivotUtil");
        var lrv = x.getLowestRankVariable(refinedVars.including(self));
        self.type = lrv.type;
    }
}

/**
 * Retypes a realized variable to the less abstract type of all variables in the
 * bottom patterns with the same name.
 *
 * @param patterns the patterns to look for variables with the same name 
 */  
operation QVT!Variable retypeRealizedVar(pattern : QVT!Pattern) {
    var refinedVars = pattern.realizedVariable.select(
                    v | v.name == self.name
                    );
    if (refinedVars.size() > 0) {
        var x = new Native("org.eclipse.qvtd.build.etl.PivotUtil");
        var lrv = x.getLowestRankVariable(refinedVars.including(self));
        self.type = lrv.type;
    }
}

operation QVT!GuardPattern fixPredicateVarReferences() {
    for (predicate in self.predicate) {
        //predicate.println("Predicate ");
        var refVars =  predicate.findReferencedVariables();
        //refVars.println("refVars ");
        // Find variables and fix references
        for (v in refVars) {
            //v.println("Fixing ");
            var targetVar = v.findReferencesInPatterns(self.asSequence());
            if (targetVar == null) {
                var searchPatterns;
                if (self.area.isTypeOf(QVT!CoreDomain)) {
                    // Domain guard patterns depend on guard patterns of domains with depending typed models
                    searchPatterns = self.area.rule.domain.select(d | d.typedModel.dependsOn.includes(self.area.typedModel)).collect(d | d.guardPattern).flatten();
                } else if (self.area.isTypeOf(QVT!Mapping)) {
                    // 1. Mapping's domain guard patterns
                    searchPatterns = self.area.domain.collect(d | d.guardPattern).flatten();
                }
                targetVar = v.findReferencesInPatterns(searchPatterns);
                if (targetVar == null) {
                    // Search in the context
                    searchPatterns = self.area.getContextMappingPatterns();
                    targetVar = v.findReferencesInPatterns(searchPatterns);
                }
            }
            if (targetVar == null) {
                if (self.area.isTypeOf(QVT!Mapping)) {
                    throw "Error! not able to find a local reference for variable " + v + " in predicate " + predicate + " in GuardPattern of Mapping " + self.area;  
                } else if(self.area.isTypeOf(QVT!CoreDomain)) {
                    throw "Error! not able to find a local reference for variable " + v + " in predicate " + predicate + " in GuardPattern of Domain " + self.area;  
                }  
            }
            //targetVar.println("local ");
            predicate.conditionExpression.fixVarReferences(targetVar);
        }
    }
}


operation QVT!BottomPattern fixPredicateVarReferences() {
    
    for (predicate in self.predicate) {
        //predicate.println("Predicate ");
        var refVars =  predicate.findReferencedVariables();
        //refVars.println("refVars ");
        // Find variables and fix references
        for (v in refVars) {
            //v.println("Fixing ");
            // MiddleGuard Pattern depends on domain guard patterns
            var targetVar = v.findReferencesInPatterns(self.asSequence());
            if (targetVar == null) {
                var searchPatterns : Sequence;
                if (self.area.isTypeOf(QVT!CoreDomain)) {
                    // 1. Guard Pattern of the Domain
                    searchPatterns = self.area.rule.domain.collect(d | d.guardPattern).flatten();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Bottom Pattern of domains with depending typed models
                    if (targetVar == null) {
                        searchPatterns = self.area.rule.domain.select(d | d.typedModel.dependsOn.includes(self.area.typedModel)).collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                    }
                    
                } else if (self.area.isTypeOf(QVT!Mapping)) {
                    // 1. Guard Pattern of the Mapping
                    searchPatterns = self.area.guardPattern.asSequence();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Mapping's domain bottom pattern
                    if (targetVar == null) {
                        searchPatterns = self.area.domain.collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                        if (targetVar == null) {
                            // 3. Mapping's domain guard patterns
                            searchPatterns = self.area.domain.collect(d | d.guardPattern).flatten();
                            targetVar = v.findReferencesInPatterns(searchPatterns); 
                        }
                    }
                }
                if (targetVar == null) {
                    // Search in the context
                    searchPatterns = self.area.getContextMappingPatterns();
                    targetVar = v.findReferencesInPatterns(searchPatterns);
                }
            }
            if (targetVar == null) {
                if (self.area.isTypeOf(QVT!Mapping)) {
                    throw "Error! not able to find a local reference for variable " + v + " in predicate " + predicate + "in BottomPattern of Mapping " + self.area;  
                } else if(self.area.isTypeOf(QVT!CoreDomain)) {
                    throw "Error! not able to find a local reference for variable " + v + " in predicate " + predicate + "in BottomPattern of Domain " + self.area;  
                }  
            }
            predicate.conditionExpression.fixVarReferences(targetVar);
        }
    }
}



operation QVT!BottomPattern fixAssignmentVarReferences() {
    for (assignment in self.assignment) {
        //assignment.println("Assignment ");
        var refVars =  assignment.findReferencedVariables();
        //refVars.println("refVars ");
        // Find variables and fix references
        for (v in refVars) {
            //v.println("Fixing ");
            // MiddleGuard Pattern depends on domain guard patterns
            var targetVar = v.findReferencesInPatterns(self.asSequence());
            if (targetVar == null) {
                var searchPatterns;
                if (self.area.isTypeOf(QVT!CoreDomain)) {
                    // 1. Guard Pattern of the Domain
                    searchPatterns = self.area.rule.domain.collect(d | d.guardPattern).flatten();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Bottom Pattern of domains with depending typed models
                    if (targetVar == null) {
                        searchPatterns = self.area.rule.domain.select(d | d.typedModel.dependsOn.includes(self.area.typedModel)).collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                    }
                } else if (self.area.isTypeOf(QVT!Mapping)) {
                    // 1. Guard Pattern of the Mapping
                    searchPatterns = self.area.guardPattern.asSequence();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Mapping's domain bottom pattern
                    if (targetVar == null) {
                        searchPatterns = self.area.domain.collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                        if (targetVar == null) {
                            // 3. Mapping's domain guard patterns
                            searchPatterns = self.area.domain.collect(d | d.guardPattern).flatten();
                            targetVar = v.findReferencesInPatterns(searchPatterns); 
                        }
                    }
                }
                if (targetVar == null) {
                    // Search in the context
                    searchPatterns = self.area.getContextMappingPatterns();
                    targetVar = v.findReferencesInPatterns(searchPatterns);
                }
            }
            if (targetVar == null) {
                if (self.area.isTypeOf(QVT!Mapping)) {
                    throw "Error! not able to find a local reference for variable " + v + " in assignemnt " + assignment + "in BottomPattern of Mapping " + self.area;  
                } else if(self.area.isTypeOf(QVT!CoreDomain)) {
                    throw "Error! not able to find a local reference for variable " + v + " in assignment " + assignment + "in BottomPattern of Domain " + self.area;  
                }  
            }
            assignment.value.fixVarReferences(targetVar);
            if (assignment.isTypeOf(QVT!PropertyAssignment)) {
                assignment.slotExpression.fixVarReferences(targetVar);
            } else if (assignment.isTypeOf(QVT!VariableAssignment)) {
                if (assignment.targetVariable.name = targetVar.name) {
                    assignment.targetVariable = targetVar;
                }
            }
        }
    }
}

operation QVT!BottomPattern fixOperationCallReferences() {
    for (o in self.enforcementOperation) {
        //predicate.println("Predicate ");
        var refVars =  o.operationCallExp.findReferencedVariables();
        //refVars.println("refVars ");
        // Find variables and fix references
        for (v in refVars) {
            //v.println("Fixing ");
            // MiddleGuard Pattern depends on domain guard patterns
            var targetVar = v.findReferencesInPatterns(self.asSequence());
            if (targetVar == null) {
                var searchPatterns;
                if (self.area.isTypeOf(QVT!CoreDomain)) {
                    // 1. Guard Pattern of the Domain
                    searchPatterns = self.area.rule.domain.collect(d | d.guardPattern).flatten();
                    searchPatterns.println();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Bottom Pattern of domains with depending typed models
                    if (targetVar == null) {
                        searchPatterns = self.area.rule.domain.select(d | d.typedModel.dependsOn.includes(self.area.typedModel)).collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                    }
                } else if (self.area.isTypeOf(QVT!Mapping)) {
                    // 1. Guard Pattern of the Mapping
                    searchPatterns = self.area.guardPattern.asSequence();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Mapping's domain bottom pattern
                    if (targetVar == null) {
                        searchPatterns = self.area.domain.collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                        if (targetVar == null) {
                            // 3. Mapping's domain guard patterns
                            searchPatterns = self.area.domain.collect(d | d.guardPattern).flatten();
                            targetVar = v.findReferencesInPatterns(searchPatterns); 
                        }
                    }
                }
                if (targetVar == null) {
                    // Search in the context
                    searchPatterns = self.area.getContextMappingPatterns();
                    targetVar = v.findReferencesInPatterns(searchPatterns);
                }
            }
            if (targetVar == null) {
                if (self.area.isTypeOf(QVT!Mapping)) {
                    throw "Error! not able to find a local reference for variable " + v + " in operation " + o + "in BottomPattern of Mapping " + self.area;  
                } else if(self.area.isTypeOf(QVT!CoreDomain)) {
                    throw "Error! not able to find a local reference for variable " + v + " in operation " + o + "in BottomPattern of Domain " + self.area;  
                }  
            }
            o.operationCallExp.fixVarReferences(targetVar);
        }
    }
}

/**
 * Finds all variables referenced in a set of Pattern by finding all references
 * each of the patterns.
 */
operation QVT!Variable findReferencesInPatterns(patterns : Sequence) {
    
    var targetVar = null;
    for (p in patterns) {
        targetVar = p.findVariable(self);
        if (targetVar <> null) {
           return targetVar;
        }
    }
}


/**
 * Finds all variables referenced in a Preicate.
 */
@cached
operation QVT!Predicate findReferencedVariables() : Collection {
    return self.conditionExpression.findReferencedVariables();
}


@cached
operation QVT!GuardPattern findVariableByName(variable : QVT!TypedElement) {
    
    return self.variable.selectOne(lv | lv.name == variable.name);
}

@cached
operation QVT!BottomPattern findVariableByName(variable : QVT!TypedElement) {
    
    return self.variable.includingAll(self.realizedVariable).selectOne(lv | lv.name == variable.name);
}



@cached
operation QVT!Property isContainer() : Boolean {
    if (self.getOpposite().isDefined()) {
        return self.getOpposite().isComposite();
    } else {
        return false;
    }
}

operation QVT!Property hasNavigableOpposite() : Boolean {
    self.println("hasNavigableOpposite ");
    if (self.getOpposite().isDefined()) {
        self.getOpposite().println("oposite ");
        self.getOpposite().getType().getUpperValue().println("uppervalue ");
        if (self.getOpposite().getType().getUpperValue().isDefined()) {
            // TODO Also check for numbers > 1
             
            return not (self.getOpposite().getType().getUpperValue().asString() == "*");
        }
        return true;
    } else {
        return false;
    }
}

/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/getDataTypeUses
 * NAME
 *  getDataTypeUses - Returns a sequence of {Type, Attribtye} pairs whos
 *  value is assigned from a DataType.
 * FUNCTION
 *  Identifies all the assignments in which the value part is a variable whos type
 *  is a DataType and for each, it creates a {Type, Attribtye} pair that saves the 
 *  information about what attribute of what Type was being assigned. 
 * CONTEXT
 *  QVT!Mapping  The mapping under test
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *
 */    
operation QVT!Mapping hasDataTypeUse(values : Sequence) : Boolean {
    var pivotUtil = new Native("org.eclipse.qvtd.build.etl.PivotUtil");
    //self.name.println();
    // Get all the assignments that hava a value that is a PropertyCallExp in which
    // the source is of the type and the referredProperty is the same
    if (self.getAllAssignments().exists(a | a.value.isTypeOf(QVT!PropertyCallExp)
            and a.value.source.isTypeOf(QVT!VariableExp) and pivotUtil.isKindOf(values.first(), a.value.source.type) 
            and a.value.referredProperty == values.last())) {
        return true;        
    }
    for (p in self.getAllPredicates()) {
        // Any of the arguments can be the use
        if (p.conditionExpression.isKindOf(QVT!OperationCallExp)) {
            //p.conditionExpression.toString().println();
            for (a in p.conditionExpression.argument.select(a | a.isTypeOf(QVT!PropertyCallExp))) {
                if (a.source.type == values.first() and a.referredProperty == values.last()) {
                    return true;
                }
            }
            if (pivotUtil.isKindOf(values.first(), p.conditionExpression.source.source.type ) and p.conditionExpression.source.referredProperty == values.last()) {
                return true;
            }
        }
    }
    return false;
}    


// ========================================================= move to qvtimperative model

/** 
 * Returns the tranformation of a mapping. Does a bottom up recursive search
 */
operation QVT!Mapping getTransforamtion() : QVT!Transformation {
    if (self.transformation.isDefined()) {
        return self.transformation;
    } else if (self.context.isDefined()) {
        return self.context.getTransforamtion();
    } else {
        self.err("Cotextless mapping ");
    }
}
 /* this can be getAllPatterns, see how is is called for all atributes with super classes */
@cached
operation QVT!Area getContextMappingPatterns() : Sequence {

    var mapping;
    if (self.isTypeOf(QVT!CoreDomain)) {
        mapping = self.rule;
    } else if (self.isTypeOf(QVT!Mapping)) {
        mapping = self;
    }
    var searchPatterns = new Sequence;
    if (mapping.context.isDefined()) {
        searchPatterns.addAll(mapping.context.domain.collect(d | d.guardPattern).flatten());
        searchPatterns.addAll(mapping.context.domain.collect(d | d.bottomPattern).flatten());
        searchPatterns.add(mapping.context.guardPattern);
        searchPatterns.add(mapping.context.bottomPattern);
        searchPatterns.addAll(mapping.context.getContextMappingPatterns());
    }
    return searchPatterns;

}

/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/getInputVariables
 * NAME
 *  getInputVariables - Returns the input variables of the Mapping, excluding DataType
 *  variables
 *
 * CONTEXT
 *  QVT!Rule  The mapping
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/getOutputVariables
 */
@cached
operation QVT!Rule getInputVariables() : Sequence {
    
    var vars: Sequence;
    vars = self.guardPattern.variable
        .includingAll(self.domain.collect(d | d.guardPattern).flatten().collect(gp | gp.variable).flatten()
        .select(v | not v.type.isTypeOf(QVT!PrimitiveType))).asSequence();
    //for (l in self.local) {
    //    vars = vars.includingAll(l.getInputVars());
    //}
    // QVTc, QVTu, QVTm: Do the same for all refined rules
    //for (r in self.refinement) {
    //    vars = vars.includingAll(r.getInputVars());
    //}
    return vars;
}

/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/getOutputVariables
 * NAME
 *  getOutputVariables - Returns the output variables of the Mapping, excluding 
 *  DataType variables
 *
 * CONTEXT
 *  QVT!Rule  The mapping
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/getInputVariables
 */
@cached
operation QVT!Rule getOutputVariables() : Sequence {
    
    var vars: Sequence;
    vars = self.bottomPattern.realizedVariable
        .includingAll(self.domain.collect(d | d.bottomPattern).flatten().collect(gp | gp.realizedVariable).flatten()
        .select(v | not v.type.isTypeOf(QVT!PrimitiveType))).asSequence();
    //for (l in self.local) {
    //    vars = vars.includingAll(l.getInputVars());
    //}
    // QVTc, QVTu, QVTm: Do the same for all refined rules
    //for (r in self.refinement) {
    //    vars = vars.includingAll(r.getInputVars());
    //}
    return vars;
}

/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/getAllAssignments
 * NAME
 *  getAllAssignments - Returns all the assignments of the mapping
 *
 * CONTEXT
 *  QVT!Mapping  The mapping
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/
 */
 /* TODO Added the commented code to add it to QVTc/u/m model */
@cached
operation qvti!Mapping getAllAssignments() : Sequence {
    var asgs : Sequence;
    asgs.addAll(self.bottomPattern.assignment);
    for (d in self.domain) {
        asgs.addAll(d.bottomPattern.assignment);
    }
    //for (l in self.local) {
    //    asgs.addAll(l.getAllAssignments());
    //}
    return asgs;
}


/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/getAllPredicates
 * NAME
 *  getAllPredicates - Returns all the predicates of the mapping
 *
 * CONTEXT
 *  QVT!Mapping  The mapping
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/
 */
/* TODO Added the commented code to add it to QVTc/u/m model */
@cached
operation qvti!Mapping getAllPredicates() : Sequence {
    var pdcts : Sequence;
    pdcts.addAll(self.bottomPattern.predicate);
    pdcts.addAll(self.guardPattern.predicate);
    for (d in self.domain) {
        pdcts.addAll(d.bottomPattern.predicate);
        pdcts.addAll(d.guardPattern.predicate);
    }
    //for (l in self.local) {
    //    pdcts.addAll(l.getAllPredicates());
    //}
    return pdcts;
}

/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/getPrimitiveDataTypeAssignemnts
 * NAME
 *  getPrimitiveDataTypeAssignemnts - Returns all the property assignments of 
 *  the mapping were the value is a variable with a primitive data type, i.e.,
 *    varA.property = 'PrimitiveDataType'
 *
 * CONTEXT
 *  QVT!Mapping  The mapping
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isPrimitivePropertyAssignemnt
 */
@cached
operation QVT!Mapping getPrimitiveDataTypeAssignemnts() : Sequence {
	
	return self.getAllAssignments()
		.select(a | a.isPrimitivePropertyAssignemnt());
}


/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isSimpleAttributeNavigation
 * NAME
 *  getAllPredicates - Determine if the Assignemnts is of the form 
 *    varA.attribute := varB
 *  1. The Assignment must be an Attribute assignment
 *  2. The slot operation must be a VariableExp
 *  3. The value must be VariableExp
 * 
 * CONTEXT
 *  QVT!Assignment  The assignement to test
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/
 */
operation QVT!Assignment isSimpleAttributeNavigation() : Boolean {

	return self.isTypeOf(QVT!PropertyAssignment)
		and self.slotExpression.isTypeOf(QVT!VariableExp)
		and self.value.isTypeOf(QVT!VariableExp);
}

/****o* /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isPrimitivePropertyAssignemnt 
 * NAME
 *  isPrimitivePropertyAssignemnt - Determine if the Assignemnts assigns a primitive
 *  data type
 *  
 * CONTEXT
 *  QVT!Assignment  The assignement to test
 * ANNOTATIONS
 *  cached
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/helpers/QVTHelpers/isSimpleAttributeNavigation
 */
operation QVT!Assignment isPrimitivePropertyAssignemnt() : Boolean {
    
    return self.isSimpleAttributeNavigation()
    	and self.value.type.isTypeOf(QVT!PrimitiveType);
}
 
/**
 * Returns the comment added to state the direction in which the transformation
 * was invoked.
 *
 */  
operation getUnidirComment() : String {
    var comment : String = "/* ";
    if (config!Configuration.all.first().mode == config!Mode#enforcement) {
        comment = comment + "Enforce ";
    } else {
        comment = comment + "Check ";
    }
    comment = comment + config!Configuration.all.first().inputDirection.name + " to ";
    comment = comment + config!Configuration.all.first().outputDirection.collect(d | d.name).concat(",") + " */";
    return comment; 
}