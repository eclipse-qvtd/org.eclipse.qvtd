/*******************************************************************************
 * Copyright (c) 2014 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "../helpers/QVTHelpers.eol";
import "../helpers/QVTsHelpers.eol";

pre {
    var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
}

//=============== QVTp to QVTi (just copy)  ===============

rule ImperativeModel
    transform mIn : QVTp!ImperativeModel
    to mOut : QVTi!ImperativeModel
    {
        
        mOut.externalURI = mIn.externalURI.replace(".qvtp.qvti", ".qvti");
        mOut.ownedImports ::= mIn.ownedImports;
        mOut.ownedPackages.addAll(mIn.ownedPackages.equivalent());
        // Copy the OCL types package
        //mOut.ownedPackages.add(emfTool.getEcoreUtil().copy(mIn.ownedPackages.selectOne(p | p.isTypeOf(QVTp!Package))));
    }

rule Imports
	transform s : QVTp!Import
	to t : QVTi!Import
	extends NamedElements
	{
	
	t.importedNamespace = s.importedNamespace;
}

rule Packages 
	transform s : QVTp!Package
	to t : QVTi!Package 
	extends NamedElements
	{
	
	-- We only want to copy the package containing the transformation
	guard : s.ownedClasses.exists(x | x.isKindOf(QVTp!Transformation))
	 
	t.nsPrefix = s.nsPrefix;
	t.URI = s.URI;
	t.ownedClasses ::= s.ownedClasses;
}

@abstract
rule NamedElements
    transform eIn : QVTp!NamedElement
    to eOut : QVTi!NamedElement
    {
        eOut.name = eIn.name;
    }

rule TypedModels
    transform tmIn : QVTp!TypedModel
    to tmOut : QVTi!TypedModel
    extends NamedElements
    {
        tmOut.usedPackage = tmIn.usedPackage;
        tmOut.dependsOn.addAll(tmIn.dependsOn.equivalent());    
    }
    
rule Transformations
    transform tIn : QVTp!Transformation
    to tOut : QVTi!Transformation
    extends NamedElements
    {
        tOut.ownedTag = emfTool.getEcoreUtil().copyAll(tIn.ownedTag);
        tOut.modelParameter.addAll(tIn.modelParameter.equivalent());
        tOut.`rule`.addAll(tIn.`rule`.equivalent());
        tOut.`extends` ::= tIn.`extends`;
    }

@abstract
rule Rules
    transform rIn : QVTp!Rule
    to rOut : QVTi!Rule
    extends NamedElements
    {
        rOut.domain.addAll(rIn.domain.equivalent());
        rOut.overrides ::= rIn.overrides;
        rOut.overridden.addAll(rIn.overridden.equivalent());
    }

@abstract
rule Areas
    transform aIn : QVTp!Area
    to aOut : QVTi!Area
    {
        aOut.guardPattern ::= aIn.guardPattern;
        aOut.bottomPattern ::= aIn.bottomPattern;
    }

rule Mappings
    transform mIn : QVTp!Mapping
    to mOut : QVTi!Mapping
    extends Rules, Areas
    {
        
        mIn.name.println("Mappings " );
        var ma = QVTs!MappingAction.all().selectOne(ma | ma.mapping.name == mIn.name); 
        if (not ma.children.isEmpty()) {
            mOut.mappingStatement = new QVTi!MappingSequence;
            mOut.mappingStatement.mappingStatements.addAll(ma.children
            		.select(c | not c.parameterDerivations.exists(pd | pd.secondaryParameter.isLoop)).equivalent());
            //mOut.mappingStatement.mappingStatements.addAll(ma.children.equivalent());
            /*
            // Add loops of mapping calls accordingly... hard!
            if (ma.parent.mapping) {
                // Add only the loops of the PrimaryArguments with the most secondary arguments
                // The other DistinctData loops will be nested inside these
                mOut.mappingStatement.mappingStatements.addAll(ma.children
                    .collect(ma | ma.getMainDistinctData())
                    .flatten().equivalent());
            } else {
                mOut.mappingStatement.mappingStatements.addAll(ma.children.equivalent());
            }
			*/
        }
    }

@abstract
rule Domains
    transform dIn : QVTp!Domain
    to dOut : QVTi!Domain
    extends NamedElements
    {
        dOut.isCheckable = dIn.isCheckable;
        dOut.isEnforceable = dIn.isEnforceable;
        dOut.typedModel ::= dIn.typedModel;
    } 

rule CoreDomains
    transform cdIn : QVTp!CoreDomain
    to cdOut : QVTp!CoreDomain
    extends Domains, Areas
    {
    }

@abstract        
rule Patterns
    transform pIn : QVTp!Pattern
    to pOut : QVTi!Pattern
    {
        pOut.predicate.addAll(pIn.predicate.equivalent());
        pOut.bindsTo.addAll(pIn.bindsTo.equivalent());
    }

@abstract
rule CorePatterns
    transform cpIn : QVTp!CorePattern
    to cpOut : QVTi!CorePattern
    extends Patterns
    {
    
        cpOut.variable.addAll(cpIn.variable.equivalent());
    }        
    
rule BottomPatterns
    transform bpIn : QVTp!BottomPattern
    to bpOut : QVTi!BottomPattern
    extends CorePatterns
    {
        bpOut.assignment.addAll(bpIn.assignment.equivalent());
        bpOut.enforcementOperation.addAll(bpIn.enforcementOperation.equivalent());
        bpOut.variable.addAll(bpIn.variable.equivalent());
        bpOut.realizedVariable.addAll(bpIn.realizedVariable.equivalent());
    }

 rule GuardPatterns
    transform gpIn : QVTp!GuardPattern
    to gpOut : QVTi!GuardPattern
    extends CorePatterns
    {
        
    }

@abstract
rule Assignments
    transform aIn : QVTp!Assignment
    to aOut : QVTi!Assignemnt
    {
        aOut.isDefault = aIn.isDefault;
        aOut.value = emfTool.getEcoreUtil().copy(aIn.value);
        var vars;
        if (aIn.bottomPattern.area.isTypeOf(QVTi!CoreDomain)) {
            vars = aIn.bottomPattern.area.`rule`.getAllVariables().equivalent();
        } else {
            vars = aIn.bottomPattern.area.getAllVariables().equivalent();
        }
        for (vFix in vars) {
            aOut.value.fixVarReferences(vFix);
        }
    }

rule PropertyAssignments
    transform paIn : QVTp!PropertyAssignment
    to paOut : QVTi!PropertyAssignment
    extends Assignments
    {
        paOut.slotExpression = emfTool.getEcoreUtil().copy(paIn.slotExpression);
        paOut.targetProperty = paIn.targetProperty;
        var vars;
        if (paIn.bottomPattern.area.isTypeOf(QVTi!CoreDomain)) {
            vars = paIn.bottomPattern.area.`rule`.getAllVariables().equivalent();
        } else {
            vars = paIn.bottomPattern.area.getAllVariables().equivalent();
        }
        for (vFix in vars) {
            paOut.slotExpression.fixVarReferences(vFix);
        }
    }

rule MiddlePropertyAssignments 
	transform mpaIn : QVTp!MiddlePropertyAssignment
	to mpaOut : QVTi!MiddlePropertyAssignment
	extends PropertyAssignments
	{
	
	}

rule VariableAssignments
    transform vaIn : QVTp!VariableAssignment
    to vaOut : QVTi!VariableAssignment
    extends Assignments
    {
        vaOut.targetVariable ::= vaIn.targetVariable;
    }

rule Predicates
    transform pIn : QVTp!Predicate
    to pOut : QVTi!Predicate
    {
        pOut.conditionExpression = emfTool.getEcoreUtil().copy(pIn.conditionExpression);
        var vars;
        if (pIn.pattern.area.isTypeOf(QVTi!CoreDomain)) {
            vars = pIn.pattern.area.`rule`.getAllVariables().equivalent();
        } else {
            vars = pIn.pattern.area.getAllVariables().equivalent();
        }
        for (vFix in vars) {
            pOut.conditionExpression.fixVarReferences(vFix);
        }
        
    }
     
rule Variables
    transform vIn : QVTp!Variable
    to vOut : QVTi!Variable
    extends NamedElements
    {
    	-- We want to prevent re-creation of variables which are cloned 
    	-- from OCL expressions (via EcoreUtil). Let's excludes all those
    	-- directly contained in an OCLExpression (IteratorExp, LetExp, etc.)
    	-- ExpressionInOCL containers are also removed, in case the QVTp transformation
    	-- redfers to other OCL resources 
        guard { var varContainer = vIn.eContainer();
        		return (not varContainer.isKindOf(QVTp!OCLExpression)) and
        			   (not varContainer.isKindOf(QVTp!ExpressionInOCL));
        }
        vOut.isImplicit = vIn.isImplicit;
        vOut.type = vIn.type;
    }
    
rule RealizedVariables
    transform vIn : QVTp!RealizedVariable
    to vOut : QVTi!RealizedVariable
    extends NamedElements
    {

        vOut.isImplicit = vIn.isImplicit;
        vOut.type = vIn.type;
    }

//=============== QVTs to QVTi (add mapping calls)  ===============

rule RootMappingAction
	transform ma : QVTs!MappingAction
    to m : QVTi!Mapping
    {
    	guard : ma.parent.isUndefined() and ma.order = 0
    	
    	m.name = "__root__";
    	m.transformation ::= QVTp!Transformation.all.first();
    	m.name.println("Mappings " );
    	m.guardPattern = new QVTi!GuardPattern;
    	m.bottomPattern = new QVTi!BottomPattern;
        //if (not ma.children.isEmpty()) {
            m.mappingStatement = new QVTi!MappingSequence;
            m.mappingStatement.mappingStatements.addAll(ma.children
            		.select(c | not c.parameterDerivations.exists(pd | pd.secondaryParameter.isLoop)).equivalent());
            //mOut.mappingStatement.mappingStatements.addAll(ma.children.equivalent());
            /*
            // Add loops of mapping calls accordingly... hard!
            if (ma.parent.mapping) {
                // Add only the loops of the PrimaryArguments with the most secondary arguments
                // The other DistinctData loops will be nested inside these
                mOut.mappingStatement.mappingStatements.addAll(ma.children
                    .collect(ma | ma.getMainDistinctData())
                    .flatten().equivalent());
            } else {
                mOut.mappingStatement.mappingStatements.addAll(ma.children.equivalent());
            }
			*/
        //}
    }


rule MappingActions
    transform ma : QVTs!MappingAction
    to mc : QVTi!MappingCall
    {
        guard : ma.parent.isDefined()
        
        mc.referredMapping ::= QVTp!Mapping.all().selectOne(m | ma.mapping.name == m.name);
        mc.binding.addAll(ma.parameters.equivalent());
        //for (binding in mc.binding.select(b | b.value.isTypeOf(QVTi!VariableExp) and b.value.referredVariable.isUndefined())) {
        //	binding.value.referredVariable ::= ma.getContextDataParameters().selectOne(dp | dp.variable.type == binding.boundVariable.type).variable;
        //	binding.value.type = binding.value.referredVariable.type;
        //}
    }


// Non loop variables can be bound directly from the primary parameter
rule DerivedDataParameter
    transform dp : QVTs!DataParameter
    to cb : QVTi!MappingCallBinding
    {
        guard : dp.secondaryParameter.isDefined()
        	and not dp.secondaryParameter.isLoop
        	and dp.secondaryParameter.derivation.primaryParameter.isDefined()
        	 
        var paramVar = dp.variable.getSameVariable();
        var primaryVar = dp.secondaryParameter.derivation.primaryParameter.variable.getSameVariable();
        var prop = dp.secondaryParameter.derivationProperty;
        var refVar = primaryVar.equivalent();
        
        //primaryVar.name.println("primaryVar ");
        //paramVar.name.println("paramVar ");
        //prop.name.println("prop ");
        //refVar.name.println("refVar ");
        cb.boundVariable ::= paramVar;
        cb.value = new QVTi!PropertyCallExp;
        cb.value.referredProperty = prop;
        cb.value.type = prop.type;
        cb.value.ownedSource = new QVTi!VariableExp;
        cb.value.ownedSource.referredVariable = refVar;
        cb.value.ownedSource.type = refVar.type;   
        //cb.mappingCall ::= dp.secondaryDistinctData.target;
    }

// Loop variables need to be derived form the loop iterator
rule DerivedLoopDataParameter
    transform dp : QVTs!DataParameter
    to cb : QVTi!MappingCallBinding
    {
        guard : dp.secondaryParameter.isDefined()
        	and dp.secondaryParameter.isLoop
        	and dp.secondaryParameter.derivation.primaryParameter.isDefined()
        	 
        var paramVar = dp.variable.getSameVariable();
        var prop = dp.secondaryParameter.derivationProperty;
        var refVar = dp.secondaryParameter.equivalent().ownedIterators.first();
        
        //primaryVar.name.println("primaryVar ");
        //paramVar.name.println("paramVar ");
        //prop.name.println("prop ");
        //refVar.name.println("refVar ");
        cb.boundVariable ::= paramVar;
        cb.value = new QVTi!VariableExp;
        cb.value.referredVariable = refVar;
        cb.value.type = refVar.type;
        //cb.mappingCall ::= dp.secondaryDistinctData.target;
    }


rule PrimaryDataParameter
    transform dp : QVTs!DataParameter
    to cb : QVTi!MappingCallBinding
    {
        guard : not dp.secondaryParameter.isDefined()
        
        //var refVar = ??
        //refVar.name.println("primaryVar ");
        cb.boundVariable ::= dp.variable.getSameVariable();
        cb.value = new QVTi!VariableExp;
        // refferedVariable assigned by the invoking mapping
        //cb.value.referredVariable = refVar;
        //cb.value.type = refVar.type;
        //cb.mappingCall ::= dp.primaryDistinctData.target;
    }
    
rule BindingLoops
	transform sp : QVTs!SecondaryParameter
	to loop : QVTi!MappingLoop
	{
		guard : sp.isLoop
		
		sp.dataParameter.variable.name.println("BindingLoops ");
        if (sp.derivation.primaryParameter.isUndefined()) {
        	// for dp.v : <dp.v.type> in <dp.v.type>.allInstances()
        	var it = new QVTi!Variable;
	        it.name = sp.dataParameter.variable.name;
	        it.type = sp.dataParameter.variable.type;
	        loop.ownedIterators.add(it);
        	var exp = new QVTi!OperationCallExp;
        	exp.referredOperation = getOclElementAllInstancesOp();
	        exp.ownedSource = new QVTi!TypeExp;
	        exp.ownedSource.referredType = it.type;
	        exp.ownedSource.type = it.type;
	        exp.type = exp.referredOperation.type;
	        loop.ownedSource = exp;
        } else {
        	var sourceVar ::= sp.derivation.target.getContextDataParameters()
        			.selectOne(dp | dp.variable.type == sp.derivation.primaryParameter.variable.type).variable.getSameVariable();
        	// The containement property may be the exact type or a supertype of the variable we are binding
        	// The property must be a collection, so we need to check the elements type
        	if (sp.derivationProperty.type.elementType == sp.dataParameter.variable.type) {
        		// for dp.v in pp.property 
        		var it = new QVTi!Variable;
		        it.name = sp.dataParameter.variable.name;
		        it.type = sp.dataParameter.variable.type;
		        loop.ownedIterators.add(it);
		        var exp = new QVTi!PropertyCallExp;
	        	exp.type = sp.derivationProperty.type;
	        	exp.ownedSource = new QVTi!VariableExp;
		        exp.ownedSource.referredVariable = sourceVar;
		        exp.ownedSource.type = sourceVar.type;
	        	exp.referredProperty = sp.derivationProperty;
		        loop.ownedSource = exp;
        	} else {
        		//for child in pp.property->select(e | e.oclIsTypeOf(dp.v.type))
        		var it = new QVTi!Variable;
		        it.name = "child";
		        it.type = sp.dataParameter.variable.type;
		        loop.ownedIterators.add(it);
		        
        		var exp = new QVTi!IteratorExp;
	        	exp.type = sp.derivationProperty.type;
	        	
	        	exp.ownedSource = new QVTi!PropertyCallExp;
	        	exp.ownedSource.type = sp.derivationProperty.type;
	        	exp.ownedSource.ownedSource = new QVTi!VariableExp;
		        exp.ownedSource.ownedSource.referredVariable = sourceVar;
		        exp.ownedSource.ownedSource.type = sourceVar.type;
	        	exp.ownedSource.referredProperty = sp.derivationProperty;
		        
		        exp.ownedBody = new QVTi!OperationCallExp;
		        exp.ownedBody.type = getPrimitiveTypeByName("Boolean");
		        var bodyIt = new QVTi!Variable;
		        bodyIt.name = sp.derivationProperty.name.charAt(0).asString();
		        bodyIt.type = sp.derivationProperty.type.elementType;
		        exp.ownedBody.ownedSource = new QVTi!VariableExp;
		        exp.ownedBody.ownedSource.referredVariable = bodyIt;
		        exp.ownedBody.ownedSource.type = bodyIt.type;
		        var argument = new QVTi!TypeExp;
		        argument.type = getClassByName("Class");
		        argument.referredType = it.type;
		        exp.ownedBody.ownedArguments.add(argument);
		        exp.ownedBody.referredOperation = exp.ownedBody.type.getOperationByName("oclIsTypeOf");
		        
		        exp.ownedIterators.add(bodyIt);
		        exp.referredIteration = getSelectIterator();
		        loop.ownedSource = exp;
				
       		}
        }
        // TODO what happens with multiple Distinct Datas?
        loop.ownedBody = new QVTi!MappingSequence;
        loop.ownedBody.mappingStatements.add(sp.derivation.target.equivalent());
        // To make loops nest, only one loop can be added. Which? The next one with the most secondary arguments
        // FIXME
        //var nextDD = dd.getNextDistinctData();
        //if (nextDD <> null) {
        //    loop.ownedBody.mappingStatements.add(nextDD.equivalent());
        //}
                
		
	}

@cached
operation QVTs!Variable getSameVariable() : QVTp!Variable {
    return QVTp!Variable.all.selectOne(v | QVTp.getElementId(v) == QVTs.getElementId(self));
} 


operation QVTs!MappingAction hasLoopVariable() : Boolean {
    
    // This is the actual operation that finds the nesting
    return true;
}


post {
	-- FIXME By some reason making the rule Imports be lazy, makes the transformation strangely behave. Investigate
	-- For the time being, I don't make the rule lazy and I remove the orphane elements at the end'
	delete QVTi!Import.all.select(x | x.eContainer().isUndefined());
    "QVTp+s to QVTi Done".println();
}    