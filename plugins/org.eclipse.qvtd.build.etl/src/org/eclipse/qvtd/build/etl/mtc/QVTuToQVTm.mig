/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "../helpers/QVTHelpers.eol";
import "../helpers/OclLibHelper.eol";

pre {
    var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
}

/****f* /org.eclipse.qvtd.build.etl/mtc/QVTuToQVTm
 * NAME
 *  QVTuToQVTm -- Flock migration script from QVTu to QVTm
 *
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/mtc/QVTcToQVTu  
 ******
 */

/****d* QVTuToQVTm/Mapping
 * CONTEXT
 *  Mapping
 * WHEN
 *  The mapping is nested
 * FUNCTION
 *  Delete all nested mappings, i.e., flatten the mappings
 * TODO
 *  Revise this if flock os fixed and correctly cascade deletes the mapping
 ******
 */
@cascade 
delete Mapping
    when : original.context.isDefined()

/****d* QVTuToQVTm/CorePattern
 * CONTEXT
 *  CorePattern
 * WHEN
 *  The Pattern is in a nested mapping
 * FUNCTION
 *  Delete patterns in nested mappings
 ******
 */
@cascade 
delete CorePattern
    when : original.area.isTypeOf(QVT!Mapping) and original.area.context.isDefined()
    
/****d* QVTuToQVTm/Assignment
 * CONTEXT
 *  Assignment
 * WHEN
 *  The assignemnt's bottom pattern is in a nested mapping
 * FUNCTION
 *  Delete assignments in nested mappings' patterns
 ******
 */
@cascade
delete Assignment
    when : original.bottomPattern.area.isTypeOf(QVT!Mapping) and original.bottomPattern.area.context.isDefined()

/****d* QVTuToQVTm/Predicate
 * CONTEXT
 *  Predicate
 * WHEN
 *  The assignemnt's pattern is in a nested mapping
 * FUNCTION
 *  Delete assignments in nested mappings' doamins' patterns
 ******
 */
@cascade
delete Predicate
    when : original.pattern.area.isTypeOf(QVT!Mapping) and original.pattern.area.context.isDefined()

/****d* QVTuToQVTm/CoreDomain
 * CONTEXT
 *  CoreDomain
 * WHEN
 *  The CoreDomain is in a nested mapping
 * FUNCTION
 *  Delete domains in nested mappings
 ******
 */
@cascade 
delete CoreDomain
    when : original.rule.context.isDefined()    

/****d* QVTuToQVTm/Mapping
 * CONTEXT
 *  Mapping
 * WHEN
 *  The mapping is nested
 * FUNCTION
 *  Delete all nested mappings, i.e., flatten the mappings
 ******
 */
@cascade 
delete CorePattern
    when : original.area.isTypeOf(QVT!CoreDomain) and original.area.rule.context.isDefined()

/****d* QVTuToQVTm/Assignment
 * CONTEXT
 *  Assignment
 * WHEN
 *  The assignemnt's bottom pattern is in domain that is in a nested mapping
 * FUNCTION
 *  Delete assignments in nested mappings' doamins' patterns
 ******
 */
@cascade
delete Assignment
    when : original.bottomPattern.area.isTypeOf(QVT!CoreDomain) and original.bottomPattern.area.rule.context.isDefined()

/****d* QVTuToQVTm/Predicate
 * CONTEXT
 *  Predicate
 * WHEN
 *  The predicate's pattern is in a domain that is in a nested mapping
 * FUNCTION
 *  Delete assignments in nested mappings' doamins' patterns
 ******
 */
@cascade
delete Predicate
    when : original.pattern.area.isTypeOf(QVT!CoreDomain) and original.pattern.area.rule.context.isDefined()

/****d* QVTuToQVTm/Variable
 * CONTEXT
 *  Predicate
 * WHEN
 *  The predicate's pattern is in a domain that is in a nested mapping
 * FUNCTION
 *  Delete assignments in nested mappings' doamins' patterns
 ******
 */
delete Variable
    when {
        if (original.oppositePattern().isDefined()) {
            return (original.oppositePattern().area.isTypeOf(QVT!CoreDomain) and original.oppositePattern().area.rule.context.isDefined())
                or (original.oppositePattern().area.isTypeOf(QVT!Mapping) and original.oppositePattern().area.context.isDefined());
        } else {
            // Is it a var in an operation/query?
            return false;
        }
    }

/****m* QVTuToQVTm/CoreModel
 * ORIGINAL
 *  CoreModel
 * FUNCTION
 *  Fix the name and the external URI of the migrated model
 *    
 ******
 */  
migrate CoreModel
    {
        migrated.externalURI = original.externalURI.replace(".qvtu.qvtc", ".qvtm.qvtc");
    }

/****m* QVTuToQVTm/Mapping
 * ORIGINAL
 *  Mapping
 * IGNORING
 *  nested (local) mappings as we are flattening
 * WHEN
 *  The mapping is not nested and doesn't refine other mappings
 * FUNCTION
 *  Migrate all content from the original mapping's nested mappings to the
 *  migrated one. 
 *    
 ******
 */ 
migrate Mapping
    ignoring local
    when : not original.context.isDefined()
            and original.refinement.isEmpty()
    {
        //original.println("ContextMapping ");
        original.flattenNestedMappings(migrated);
        migrated.fixReferences();
    }

/****m* QVTuToQVTm/Mapping
 * ORIGINAL
 *  Mapping
 * IGNORING
 *  nested (local) mappings as we are flattening
 * WHEN
 *  The mapping is not nested and refines other mappings
 * FUNCTION
 *  Migrate all content from the original mapping's nested mappings to the
 *  migrated one. Copy all domains and patterns from the refined mapping(s)
 *  and then merge all the resulting domains.
 *    
 ******
 */ 
migrate Mapping
    ignoring local
    when : not original.context.isDefined() and not original.refinement.isEmpty()  
    {
        //original.println("RefinnedMapping ");
        original.flattenNestedMappings(migrated);
        
        //var olm = original.local.select(m | m.domain.isEmpty());
        //if (olm.size() > 1) {
        //    var lm = new QVTm!Mapping;
        //    lm.guardPattern = new QVTm!GuardPattern;
        //    lm.bottomPattern = new QVTm!BottomPattern;
        //    lm.bottomPattern.assignment.addAll(emfTool.getECoreUtil().copyAll(olm.collect(l | l.bottomPattern).flatten().collect(gp | gp.assignment).flatten()));
        //    lm.bottomPattern.realizedVariable.addAll(emfTool.getECoreUtil().copyAll(olm.collect(l | l.bottomPattern).flatten().collect(gp | gp.realizedVariable).flatten()));
        //    migrated.local.add(lm);
        //}
        for (refined in original.refinement) {
            //refined.println("refined ");
            // For each domain in the refined mapping, if it doesn't exist, copy it. If it does exist, merge it.
            // Domains added first so nested mappings can find them
            for (d in refined.collect(r | r.domain).flatten()) {
                if (not migrated.domain.exists(ed | ed.name == d.name)) {
                    //d.println("Copy ");
                    migrated.domain.add(emfTool.getECoreUtil().copy(d.equivalent()));
                    
                } else {
                    //d.println("Merge ");
                    var local = migrated.domain.selectOne(ed | ed.name == d.name);
                    local.guardPattern.mergeGuardPatterns(d.equivalent().guardPattern);
                    local.bottomPattern.mergeBottomPatterns(d.equivalent().bottomPattern);
                }
            }
            // Merge middle patterns
            migrated.guardPattern.mergeGuardPatterns(refined.equivalent().guardPattern);
            migrated.bottomPattern.mergeBottomPatterns(refined.equivalent().bottomPattern);
            // Copy the contents of the local mappings of the refined mapping
            for (m in refined.collect(r | r.local).flatten()) {
                m.flattenNestedMappings(migrated);
            }
            
        }
        migrated.fixReferences();
    }

/****o* QVTuToQVTm/fixReferences
 * NAME
 *  fixReferences -- Fix trailing references in the output model to variables in
 *  the input model that result from using emf copy utilities.   
 * CONTEXT
 *  QVT!Mapping
 */
operation QVT!Mapping fixReferences() {
    self.guardPattern.fixPredicateVarReferences();
    self.bottomPattern.fixPredicateVarReferences();
    self.bottomPattern.fixOperationCallReferences();
    self.bottomPattern.fixAssignmentVarReferences();
    for (d in self.domain) {
        d.guardPattern.fixPredicateVarReferences();
        d.bottomPattern.fixPredicateVarReferences();
        d.bottomPattern.fixOperationCallReferences();
        d.bottomPattern.fixAssignmentVarReferences();
    }
    for (m in self.local) {
        m.guardPattern.fixPredicateVarReferences();
        m.bottomPattern.fixPredicateVarReferences();
        m.bottomPattern.fixOperationCallReferences();
        m.bottomPattern.fixAssignmentVarReferences();
    }
}

/****o* QVTuToQVTm/mergeGuardPatterns
 * NAME
 *  mergeGuardPatterns -- Merge this patterns with the other one. This operation
 *  is to be used when flattening a mapping to compose domains and nested mappings.
 * CONTEXT
 *  QVT!Mapping
 * PARAMETERS
 *  other  the other pattern
 */
operation QVT!GuardPattern mergeGuardPatterns(other : QVT!GuardPattern) {

    // Variables. Search for variables in the refined mapping. Copy all variables that have
    // different names as the local variables. If there is any with the same name, re-type it
    var localVarNames = self.variable.collect(v | v.name); 
    
    // TODO this should be an OCL constraint: if mapping refines, and there is
    // a variable with the same name, then its type should be the same or extend
    // it
    //var refinedPatterns = self.getRefinedPatterns(other, "guard");
    //refinedPatterns.println("refined patterns ");
    for (localVar in self.variable) {
        localVar.retypeVar(other);
    }
    
    // Straight copy non-refined variables
    self.variable.addAll(emfTool.getECoreUtil().copyAll(other.variable.select(v | not localVarNames.includes(v.name))));
    // Copy predicates
    self.predicate.addAll(emfTool.getECoreUtil().copyAll(other.predicate));
}

/****o* QVTuToQVTm/mergeBottomPatterns
 * NAME
 *  mergeBottomPatterns -- Merge this patterns with the other one. This operation
 *  is to be used when flattening a mapping to compose domains and nested mappings.
 * CONTEXT
 *  QVT!Mapping
 * PARAMETERS
 *  other  the other pattern
 */  
operation QVT!BottomPattern mergeBottomPatterns(other : QVT!BottomPattern) {

    // Variables. Search for variables in the refined mapping. Copy all variables that have
    // different names as the local variables. If there is any with the same name, re-type it
    var localVarNames = self.variable.collect(v | v.name);
        
    // Perhaps this shuold be done after all the refinements have been done
    //var refinedPatterns = self.getRefinedPatterns(other, "bottom");
    for (localVar in self.variable) {
        localVar.retypeVar(other);
    }
    
    
    // Straight copy non-refined variables
    self.variable.addAll(emfTool.getECoreUtil().copyAll(other.variable.select(v | not localVarNames.includes(v.name))));
    
    // The same for realized variables
    var localRealizedVarNames = self.realizedVariable.collect(v | v.name);
    
    for (localVar in self.realizedVariable) {
        localVar.retypeRealizedVar(other);
    }
    
    // Straight copy non-refined realized variables
    self.realizedVariable.addAll(emfTool.getECoreUtil().copyAll(other.realizedVariable.select(v | not localRealizedVarNames.includes(v.name))));
    // Copy predicates
    self.predicate.addAll(emfTool.getECoreUtil().copyAll(other.predicate));
    // Copy assignments
    self.assignment.addAll(emfTool.getECoreUtil().copyAll(other.assignment));
    // Copy operations
    self.enforcementOperation.addAll(emfTool.getECoreUtil().copyAll(other.enforcementOperation));
}

/****o* QVTuToQVTm/getRefinedPatterns
 * NAME
 *  getRefinedPatterns -- Retruns a Collection of patterns related this pattern
 * FUNCTION
 *  The related patterns are searched in the orginial pattern and its refinement's areas.
 * CONTEXT
 *  QVT!CorePattern
 * PARAMETERS
 *  orig    the original pattern in which the search is done
 *  pattern A string that indicates what pattern are we looking for:
 *      * "guard" = GuardPatterns
 *      * "bottom" = BottomPattern
 */ 
@cached
operation QVT!CorePattern getRefinedPatterns(orig : QVT!CorePattern, pattern : String) : Collection {
    
    var refinedAreas;
    if (orig.area.isTypeOf(QVT!Mapping)) {
        refinedAreas = orig.area.refinement;
    } else if (orig.area.isTypeOf(QVT!CoreDomain)) {
        refinedAreas = orig.area.rule.refinement.collect(m | m.domain).flatten().select(d | d.typedModel == orig.area.typedModel);
    }
    if (pattern = "guard") {
        return refinedAreas.collect(r | r.guardPattern);
    } else if (pattern = "bottom") {
        return refinedAreas.collect(r | r.bottomPattern);
    }
}

/****o* QVTuToQVTm/flattenNestedMappings
 * NAME
 *  flattenNestedMappings -- Copy all attributes and references from a this
 *  mapping to the target mapping.
 * FUNCTION
 *  First, all nested mappings are promoted to this mapping, and then the copy
 *  is done. The difference with moveMappingContents, is that flattenNestedMappings
 *  copies, while moveMappingContents moves.
 * CONTEXT
 *  QVT!Mapping
 * PARAMETERS
 *    target    The maping to copy the nested mappings to
 */
operation QVT!Mapping flattenNestedMappings(target : QVT!Mapping) {
    
    //self.name.println("flattenNestedMappings ");
    for (l in self.local) {
        for (ll in l.local) {
            ll.moveMappingContents(l);
        }
        target.guardPattern.variable.addAll(emfTool.getECoreUtil().copyAll(l.guardPattern.variable));
	    target.guardPattern.predicate.addAll(emfTool.getECoreUtil().copyAll(l.guardPattern.predicate));
	    target.bottomPattern.variable.addAll(emfTool.getECoreUtil().copyAll(l.bottomPattern.variable));
	    target.bottomPattern.realizedVariable.addAll(emfTool.getECoreUtil().copyAll(l.bottomPattern.realizedVariable));
	    target.bottomPattern.predicate.addAll(emfTool.getECoreUtil().copyAll(l.bottomPattern.predicate));
	    target.bottomPattern.assignment.addAll(emfTool.getECoreUtil().copyAll(l.bottomPattern.assignment));
	    target.bottomPattern.enforcementOperation.addAll(emfTool.getECoreUtil().copyAll(l.bottomPattern.enforcementOperation));
	    for (d in l.domain) {
	        var td = target.domain.selectOne(od | od.name == d.name);
	        td.guardPattern.variable.addAll(emfTool.getECoreUtil().copyAll(d.guardPattern.variable));
	        td.guardPattern.predicate.addAll(emfTool.getECoreUtil().copyAll(d.guardPattern.predicate));
	        td.bottomPattern.variable.addAll(emfTool.getECoreUtil().copyAll(d.bottomPattern.variable));
	        td.bottomPattern.realizedVariable.addAll(emfTool.getECoreUtil().copyAll(d.bottomPattern.realizedVariable));
	        td.bottomPattern.predicate.addAll(emfTool.getECoreUtil().copyAll(d.bottomPattern.predicate));
	        td.bottomPattern.assignment.addAll(emfTool.getECoreUtil().copyAll(d.bottomPattern.assignment));
	        td.bottomPattern.enforcementOperation.addAll(emfTool.getECoreUtil().copyAll(d.bottomPattern.enforcementOperation));
	    }
        
    }
}


/****o* QVTuToQVTm/moveMappingContents
 * NAME
 *  moveMappingContents -- Move all attributes and references from a this
 *  mapping to the target mapping.
 * FUNCTION
 *  Movement is done recursively for nested mappings in this one. The difference
 *  with flattenNestedMappings, is that flattenNestedMappings
 *  copies, while moveMappingContents moves.
 * CONTEXT
 *  QVT!Mapping
 * PARAMETERS
 *    target    The maping to copy the nested mappings to
 */
operation QVT!Mapping moveMappingContents(target : QVT!Mapping) {
    
    //self.name.println("moveMappingContents ");
    for (local in self.local) {
        local.moveMappingContents(self);
    }
    target.guardPattern.variable.addAll(self.guardPattern.variable);
    target.guardPattern.predicate.addAll(self.guardPattern.predicate);
    target.bottomPattern.variable.addAll(self.bottomPattern.variable);
    target.bottomPattern.realizedVariable.addAll(self.bottomPattern.realizedVariable);
    target.bottomPattern.predicate.addAll(self.bottomPattern.predicate);
    target.bottomPattern.assignment.addAll(self.bottomPattern.assignment);
    target.bottomPattern.enforcementOperation.addAll(self.bottomPattern.enforcementOperation);
    for (d in self.domain) {
        var td = target.domain.selectOne(od | od.typedModel == d.typedModel);
        td.guardPattern.variable.addAll(d.guardPattern.variable);
        td.guardPattern.predicate.addAll(d.guardPattern.predicate);
        td.bottomPattern.variable.addAll(d.bottomPattern.variable);
        td.bottomPattern.realizedVariable.addAll(d.bottomPattern.realizedVariable);
        td.bottomPattern.predicate.addAll(d.bottomPattern.predicate);
        td.bottomPattern.assignment.addAll(d.bottomPattern.assignment);
        td.bottomPattern.enforcementOperation.addAll(d.bottomPattern.enforcementOperation);
    }
}


post {
    "QVTuToQVTm Done!".println();
}



