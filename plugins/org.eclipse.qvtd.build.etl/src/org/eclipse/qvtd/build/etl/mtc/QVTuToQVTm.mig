/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "../helpers/QVTHelpers.eol";
import "../helpers/OclLibHelper.eol";

pre {
    var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
}

/****f* /org.eclipse.qvtd.build.etl/mtc/QVTuToQVTm
 * NAME
 *  QVTuToQVTm -- Flock migration script from QVTu to QVTm
 *
 * SEE ALSO
 *  /org.eclipse.qvtd.build.etl/mtc/QVTcToQVTu  
 ******
 */


// **** Flat mappings by removing nested mappings ****

/****d* QVTuToQVTm/delete/NestedMappings
 * CONTEXT
 *  Mapping
 * WHEN
 *  The mapping is nested
 * FUNCTION
 *  Delete all nested mappings, i.e., flatten the mappings
 ******
 */
delete Mapping
    when : original.context.isDefined()

/****d* QVTuToQVTm/delete/NestedMappingCoreDomains
 * CONTEXT
 *  CoreDomain
 * WHEN
 *  The CoreDomain's mapping is nested
 * FUNCTION
 *  Delete all CoreDomains in nested mappings.
 ******
 */
delete CoreDomain
    when : original.rule.context.isDefined()        // Nested

/****d* QVTuToQVTm/delete/NestedMappingCorePattern
 * CONTEXT
 *  CorePattern
 * WHEN
 *  The Pattern's area is a nested mapping or a domain in a nested mapping
 * FUNCTION
 *  Delete patterns in nested mappings regardles
 ******
 */
delete CorePattern
    when : original.area.isNested()

/****m* QVTuToQVTm/migrate/NestedMappingDomainCorePatternVariable
 * CONTEXT
 *  Variable
 * WHEN
 *  The variables's pattern belongs to a domain, the domain's mapping is nested
 *  the top mapping has a domain with the same TypeModel.
 * FUNCTION
 *  Move the variable to the domain in the top containment mapping with the same
 *  typed model. 
 ******
 */
migrate Variable
    when : original.oppositePattern().isDefined()
            and original.oppositePattern().area.isDefined()
            and original.oppositePattern().area.isNested()
    {
        var migArea;
        if (original.oppositePattern().area.isTypeOf(QVTu!Mapping)) {
            migArea = original.oppositePattern().area
                .closure(m | m.context)
                .selectOne(m | not m.context.isDefined()).equivalent(); 
        } else {
            migArea = original.oppositePattern().area.rule
                .closure(m | m.context)
                .selectOne(m | not m.context.isDefined()).domain
                .selectOne(d| d.typedModel == original.oppositePattern().area.typedModel).equivalent();
        }
        if (original.oppositePattern().isTypeOf(QVTu!GuardPattern)) {
            migArea.guardPattern.variable.add(migrated);
        } else {
            migArea.bottomPattern.variable.add(migrated);
        }
    }


/****d* QVTuToQVTm/migrate/NestedMappingCorePatternAssignments
 * CONTEXT
 *  Assignment
 * WHEN
 *  The assignment's bottom pattern is in a nested mapping
 * FUNCTION
 *  Move the assignment to the top containment mapping.
 ******
 */
migrate Assignment
    when : original.bottomPattern.area.isNested()
    {   
        var migArea;
        if (original.bottomPattern.area.isTypeOf(QVTu!Mapping)) {
            migArea = original.bottomPattern.area
                .closure(m | m.context)
                .selectOne(m | not m.context.isDefined()).equivalent(); 
        } else {
            migArea = original.bottomPattern.area.rule
                .closure(m | m.context)
                .selectOne(m | not m.context.isDefined()).domain
                .selectOne(d| d.typedModel == original.bottomPattern.area.typedModel).equivalent();
        }
        migrated.bottomPattern = migArea.bottomPattern;
    }

/****m* QVTuToQVTm/migrate/NestedMappingCorePatternPredicate
 * CONTEXT
 *  Predicate
 * WHEN
 *  The predicate's pattern is in a nested mapping
 * FUNCTION
 *  Move predicates in nested mappings to the top containment mapping
 ******
 */
migrate Predicate
    when : original.pattern.area.isNested()
    {
        var migArea;
        if (original.pattern.area.isTypeOf(QVTu!Mapping)) {
            migArea = original.pattern.area
                .closure(m | m.context)
                .selectOne(m | not m.context.isDefined()).equivalent(); 
        } else {
            migArea = original.pattern.area.rule
                .closure(m | m.context)
                .selectOne(m | not m.context.isDefined()).domain
                .selectOne(d| d.typedModel == original.pattern.area.typedModel).equivalent();
        }
        if (original.pattern.isTypeOf(QVTu!GuardPattern)) {
            migArea.guardPattern.variable.add(migrated);
        } else {
            migArea.bottomPattern.variable.add(migrated);
        }
    }
    
// **** Flat mappings by removing nested mappings ****


/****d* QVTuToQVTm/delete/RefinedMappings
 * CONTEXT
 *  mapping
 * WHEN
 *  The mapping refines other mapping(s)
 * FUNCTION
 *  Copy the refined mappings features to the refining mapping.
 ******
 */
migrate Mapping
    when : not original.refinement.isEmpty()
    {
    	//original.println("Refining ");
    	// Get the set of refined mappings
    	var refined = original.closure(m | m.refinement).asSet();//.println("refined ");
    	migrated.migrateFromMappings(refined);
    	// Promote local mappings from refined mappings
    	var refinedLocal = original.closure(m | m.refinement).asSet()
    			.closure(m | m.local).asSet();//.println("refinedLocal ");
    	migrated.migrateFromMappings(refinedLocal);
    }


operation QVTm!Mapping migrateFromMappings(mappings : Collection) {
	for (tm in QVTu!TypedModel.all().select(tm | tm.name.isDefined())) {
		//tm.println("tm ");
		var tmDomains = mappings.domain.flatten().select(d | d.typedModel == tm);
		//tmDomains.println();
		var migDomain = self.domain.selectOne(ed | ed.typedModel == tm.equivalent());
    	if (migDomain.isUndefined()) {
  		    //tm.println("Create ");
            migDomain = new QVTm!CoreDomain;
            migDomain.guardPattern = new QVTm!GuardPattern;
            migDomain.bottomPattern = new QVTm!BottomPattern;
            migDomain.isCheckable = tmDomains.exists(d | d.isCheckable);
            migDomain.isEnforceable = tmDomains.exists(d | d.isEnforceable);
            migDomain.typedModel = tm.equivalent();
            migDomain.name = tm.name;
            self.domain.add(migDomain);
    	}
    	migDomain.migrateFromAreas(tmDomains);
	}
	//"MappingPatterns ".println();
	self.migrateFromAreas(mappings);
}

	
operation QVTm!Area migrateFromAreas(areas : Collection) {
	self.guardPattern.addRefinedVariables(areas.guardPattern);
   	self.bottomPattern.addRefinedVariables(areas.bottomPattern);
    self.bottomPattern.addRefinedRealizedVariables(areas.bottomPattern);
    for (a in areas.bottomPattern.assignment.flatten()) {
		//a.toString().println();
		var aCopy = emfTool.getECoreUtil().copy(a);
		self.bottomPattern.assignment.add(aCopy);
		// Fix the var references
		aCopy.fixVarReferences();
	}
	for (p in areas.bottomPattern.predicate.flatten()) {
		//p.toString().println();
		var pCopy = emfTool.getECoreUtil().copy(p);
		self.bottomPattern.predicate.add(pCopy);
		// Fix the var references
		pCopy.fixVarReferences();
	}
	for (p in areas.guardPattern.predicate.flatten()) {
		//p.toString().println();
		var pCopy = emfTool.getECoreUtil().copy(p);
		self.guardPattern.predicate.add(pCopy);
		// Fix the var references
		pCopy.fixVarReferences();
	}

}

operation QVTm!Predicate fixVarReferences() {
    //self.toString().println("Fixing Assignment ");
    var refVars =  self.findReferencedVariables();
    //refVars.println("refVars ");
    // Find variables and fix references
    for (v in refVars) {
        //v.println("Fixing ");
        var searchPatterns = new Sequence();
        searchPatterns.add(self.pattern);
        if (self.pattern.area.isTypeOf(QVTm!CoreDomain)) {
        	if (self.pattern.isTypeOf(QVTm!BottomPattern)) {
        		// 1. GuardPattern of the Domain
	            searchPatterns.add(self.pattern.area.guardPattern);
	            // 2. BottomPattern of domains with depending typed models
	            searchPatterns.add(self.pattern.area.rule.domain
	            		.select(d | d.typedModel.dependsOn.includes(self.pattern.area.typedModel))
	            		.collect(d | d.bottomPattern).flatten());
        	}
		} else if (self.pattern.area.isTypeOf(QVTm!Mapping)) {
			if (self.pattern.isTypeOf(QVTm!BottomPattern)) {
				// 1. GuardPattern of the Mapping, and thus GuardPatterns of the domains
	            searchPatterns.add(self.pattern.area.guardPattern);
            }
            searchPatterns.addAll(self.pattern.area.domain.collect(d | d.guardPattern).flatten());
            // 2. BottomPatterns of the Mapping's domains
            searchPatterns.addAll(self.pattern.area.domain.collect(d | d.bottomPattern).flatten());
	        
		}
        // MiddleGuard Pattern depends on domain guard patterns
        //searchPatterns.println("searchPatterns ");
        var targetVar = v.findReferencesInPatterns(searchPatterns);
        //targetVar.println("targetVar ");
        if (targetVar == null) {
            if (self.pattern.area.isTypeOf(QVTm!Mapping)) {
                throw "Error! not able to find a local reference for variable " + v + " in predicate " + self.toString() + "in " + self.area;  
            } else if(self.pattern.area.isTypeOf(QVTm!CoreDomain)) {
                throw "Error! not able to find a local reference for variable " + v + " in predicate " + self.toString() + "in " + self.area;  
            }  
        }
        self.conditionExpression.fixVarReferences(targetVar);
    }
}

operation QVTm!Assignment fixVarReferences() {
    //self.toString().println("Fixing Assignment ");
    var refVars =  self.findReferencedVariables();
    //refVars.println("refVars ");
    // Find variables and fix references
    for (v in refVars) {
        //v.println("Fixing ");
        var searchPatterns = new Sequence();
        searchPatterns.add(self.bottomPattern);
        if (self.bottomPattern.area.isTypeOf(QVTm!CoreDomain)) {
            // 1. GuardPattern of the Domain
            searchPatterns.add(self.bottomPattern.area.guardPattern);
            // 2. BottomPattern of domains with depending typed models
            searchPatterns.add(self.bottomPattern.area.rule.domain
            		.select(d | d.typedModel.dependsOn.includes(self.bottomPattern.area.typedModel))
            		.collect(d | d.bottomPattern).flatten());
		} else if (self.bottomPattern.area.isTypeOf(QVTm!Mapping)) {
			// 1. GuardPattern of the Mapping, and thus GuardPatterns of the domains
            searchPatterns.add(self.bottomPattern.area.guardPattern);
            searchPatterns.addAll(self.bottomPattern.area.domain.collect(d | d.guardPattern).flatten());
            // 2. BottomPatterns of the Mapping's domains
            searchPatterns.addAll(self.bottomPattern.area.domain.collect(d | d.bottomPattern).flatten());
		}
        // MiddleGuard Pattern depends on domain guard patterns
        //searchPatterns.println("searchPatterns ");
        var targetVar = v.findReferencesInPatterns(searchPatterns);
        //targetVar.println("targetVar ");
        if (targetVar == null) {
            if (self.bottomPattern.area.isTypeOf(QVT!Mapping)) {
                throw "Error! not able to find a local reference for variable " + v + " in assignemnt " + self.toString() + "in BottomPattern of Mapping " + self.area;  
            } else if(self.bottomPattern.area.isTypeOf(QVT!CoreDomain)) {
                throw "Error! not able to find a local reference for variable " + v + " in assignment " + self.toString() + "in BottomPattern of Domain " + self.area;  
            }  
        }
        self.value.fixVarReferences(targetVar);
        if (self.isTypeOf(QVTm!PropertyAssignment)) {
            self.slotExpression.fixVarReferences(targetVar);
        } else if (self.isTypeOf(QVTm!VariableAssignment)) {
            if (self.targetVariable.name = targetVar.name) {
                self.targetVariable = targetVar;
            }
        }
    }
}


// FIXME we assume the refining mapping uses the least abstract type
operation QVTm!Pattern addRefinedVariables(sourcePatterns : Collection) {
	
	var varNames = sourcePatterns.variable.flatten().name.asSet();			// Unique variable names 
	var lowRankVars = varNames.collect(n | getLowestRankVariable(sourcePatterns.variable.flatten()	// For variables with same name, get the less abstract one
			.includingAll(self.variable).select(v | v.name == n)))
			.excludingAll(self.variable.select(v | v.name == varNames.first()));		// Only copy theones that don't esist already
	//lowRankVars.println("lr vars ");
	self.variable.addAll(emfTool.getECoreUtil().copyAll(lowRankVars));
}

// FIXME we assume the refining mapping uses the least abstract type
operation QVTm!BottomPattern addRefinedRealizedVariables(sourcePatterns : Collection ) {

	var varNames = sourcePatterns.realizedVariable.flatten().name.asSet();			// Unique variable names 
	//varNames.println("gp rvarNames ");
	var lowRankVars = varNames.collect(n | getLowestRankVariable(sourcePatterns.realizedVariable.flatten()	// For variables with same name, get the less abstract one
			.includingAll(self.realizedVariable).select(v | v.name == n)))
			.excludingAll(self.realizedVariable.select(v | v.name == varNames.first()));
	//lowRankVars.println("lr rvars ");
	self.realizedVariable.addAll(emfTool.getECoreUtil().copyAll(lowRankVars));
}

post {
    "QVTuToQVTm Done!".println();
}



