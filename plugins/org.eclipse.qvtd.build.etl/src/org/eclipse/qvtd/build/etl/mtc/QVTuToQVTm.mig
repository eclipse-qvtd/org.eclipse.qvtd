/*******************************************************************************
 * Copyright (c) 2013 The University of York, Willink Transformations and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "Helpers.eol";
import "OclLibHelper.eol";

pre {
    var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
}

@cascade       
delete Area
    when : original.isTypeOf(QVT!Mapping)
            and original.context.isDefined()
            and (original.context.local.select(m | m.domain.isEmpty()).size() > 1)
            and original.domain.isEmpty()

/*
@cascade       
delete CorePattern
    when : original.area.isTypeOf(QVT!Mapping)
            and original.area.context.isDefined()
            and (original.area.context.local.select(m | m.domain.isEmpty()).size() > 1)
            and original.area.domain.isEmpty()

@cascade      
delete Assignment
    when : original.bottomPattern.area.isTypeOf(QVT!Mapping)
            and original.bottomPattern.area.context.isDefined()
            and (original.bottomPattern.area.context.local.select(m | m.domain.isEmpty()).size() > 1)
            and original.bottomPattern.area.domain.isEmpty()

*/


// Merge domainless local mappigns
migrate Mapping
    when : not original.context.isDefined()
            and original.refinement.isEmpty()
            and (original.local.select(m | m.domain.isEmpty()).size() > 1) {
        
        //original.println("ContextMapping ");
        // Merge existing local mappings
        var olm = original.local.select(m | m.domain.isEmpty());
        var lm = new QVTm!Mapping;
        lm.guardPattern = new QVTm!GuardPattern;
        lm.bottomPattern = new QVTm!BottomPattern;
        lm.bottomPattern.assignment.addAll(emfTool.getECoreUtil().copyAll(olm.collect(l | l.bottomPattern).flatten().collect(gp | gp.assignment).flatten()));
        lm.bottomPattern.realizedVariable.addAll(emfTool.getECoreUtil().copyAll(olm.collect(l | l.bottomPattern).flatten().collect(gp | gp.realizedVariable).flatten()));
        migrated.local.add(lm);
        // Fix references
        migrated.guardPattern.fixPredicateVarReferences();
        migrated.bottomPattern.fixPredicateVarReferences();
        migrated.bottomPattern.fixOperationCallReferences();
        migrated.bottomPattern.fixAssignmentVarReferences();
        for (m in migrated.local) {
            m.guardPattern.fixPredicateVarReferences();
            m.bottomPattern.fixPredicateVarReferences();
            m.bottomPattern.fixOperationCallReferences();
            m.bottomPattern.fixAssignmentVarReferences();
        }
        
    }

            
// Refinned mappings
migrate Mapping
    when : original.refinement.size() > 0 {
        
        //original.println("RefinnedMapping ");
        // Merge domainless local mappings
        var olm = original.local.select(m | m.domain.isEmpty());
        if (olm.size() > 1) {
            var lm = new QVTm!Mapping;
            lm.guardPattern = new QVTm!GuardPattern;
            lm.bottomPattern = new QVTm!BottomPattern;
            lm.bottomPattern.assignment.addAll(emfTool.getECoreUtil().copyAll(olm.collect(l | l.bottomPattern).flatten().collect(gp | gp.assignment).flatten()));
	        lm.bottomPattern.realizedVariable.addAll(emfTool.getECoreUtil().copyAll(olm.collect(l | l.bottomPattern).flatten().collect(gp | gp.realizedVariable).flatten()));
	        migrated.local.add(lm);
        }
        
        for (refined in original.refinement) {
            //refined.println("refined ");
            // For each domain in the refined mapping, if it doesn't exist, copy it. If it does exist, merge it.
            // Domains added first so nested mappings can find them
            for (d in refined.collect(r | r.domain).flatten()) {
                if (not migrated.domain.exists(ed | ed.name == d.name)) {
                    //d.println("Copy ");
                    migrated.domain.add(emfTool.getECoreUtil().copy(d.equivalent()));
                } else {
                    //d.println("Merge ");
                    var local = migrated.domain.selectOne(ed | ed.name == d.name);
                    local.guardPattern.mergeGuardPatterns(d.equivalent().guardPattern);
                    local.bottomPattern.mergeBottomPatterns(d.equivalent().bottomPattern);
                }
            }
            // Merge middle patterns
            migrated.guardPattern.mergeGuardPatterns(refined.equivalent().guardPattern);
            migrated.bottomPattern.mergeBottomPatterns(refined.equivalent().bottomPattern);

            // Nested mappings with no domains. Since many mappings can refine the same mapping
            // get the equivalent and copy (create) them. If the migrated mapping already has a
            // nested mapping it has to be merged
            for (m in refined.collect(r | r.local.select(nm | nm.domain.isEmpty())).flatten()) {
                if (migrated.local.isEmpty()) {
                    migrated.local.add(emfTool.getECoreUtil().copy(m.equivalent()));
	            } else {
	                var local = migrated.local.selectOne(m | m.domain.isEmpty());
	                local.guardPattern.mergeGuardPatterns(m.equivalent().guardPattern);
	                local.bottomPattern.mergeBottomPatterns(m.equivalent().bottomPattern);
	            }
            }
        }
        
        // Fix references
        migrated.guardPattern.fixPredicateVarReferences();
        migrated.bottomPattern.fixPredicateVarReferences();
        migrated.bottomPattern.fixOperationCallReferences();
        migrated.bottomPattern.fixAssignmentVarReferences();
        for (d in migrated.domain) {
            d.guardPattern.fixPredicateVarReferences();
            d.bottomPattern.fixPredicateVarReferences();
            d.bottomPattern.fixOperationCallReferences();
            d.bottomPattern.fixAssignmentVarReferences();
        }
        for (m in migrated.local) {
            m.guardPattern.fixPredicateVarReferences();
            m.bottomPattern.fixPredicateVarReferences();
            m.bottomPattern.fixOperationCallReferences();
            m.bottomPattern.fixAssignmentVarReferences();
        }
        // Remove the refinements
        migrated.refinement = Set{};
    }

/**
 * Merge a GuardPattern with another one. This operation is to be used when
 * flattening a mapping to compose domains and nested mappings.
 */    
operation QVT!GuardPattern mergeGuardPatterns(merge : QVT!GuardPattern) {

    // Variables. Search for variables in the refined mapping. Copy all variables that have
    // different names as the local variables. If there is any with the same name, re-type it
    var localVarNames = self.variable.collect(v | v.name); 
    
    // TODO this should be an OCL constraint: if mapping refines, and there is
    // a variable with the same name, then its type should be the same or extend
    // it
    //var refinedPatterns = self.getRefinedPatterns(merge, "guard");
    //refinedPatterns.println("refined patterns ");
    //for (localVar in self.variable) {
    //    localVar.retypeVar(refinedPatterns);
    //}
    
    // Straight copy non-refined variables
    self.variable.addAll(emfTool.getECoreUtil().copyAll(merge.variable.select(v | not localVarNames.includes(v.name))));
    // Copy predicates
    self.predicate.addAll(emfTool.getECoreUtil().copyAll(merge.predicate));
}

/**
 * Merge a BottomPattern with another one. This operation is to be used when
 * flattening a mapping to compose domains and nested mappings.
 */    
operation QVT!BottomPattern mergeBottomPatterns(merge : QVT!BottomPattern) {

    // Variables. Search for variables in the refined mapping. Copy all variables that have
    // different names as the local variables. If there is any with the same name, re-type it
    var localVarNames = self.variable.collect(v | v.name);
        
    // Perhaps this shuold be done after all the refinements have been done
    //var refinedPatterns = self.getRefinedPatterns(merge, "bottom");
    //for (localVar in self.variable) {
    //    localVar.retypeVar(refinedPatterns);
    //}
    
    
    // Straight copy non-refined variables
    self.variable.addAll(emfTool.getECoreUtil().copyAll(merge.variable.select(v | not localVarNames.includes(v.name))));
    
    // The same for realized variables
    var localRealizedVarNames = self.realizedVariable.collect(v | v.name);
    
    //for (localVar in self.realizedVariable) {
    //    localVar.retypeRealizedVar(refinedPatterns);
    //}
    
    // Straight copy non-refined realized variables
    self.realizedVariable.addAll(emfTool.getECoreUtil().copyAll(merge.realizedVariable.select(v | not localRealizedVarNames.includes(v.name))));
    // Copy predicates
    self.predicate.addAll(emfTool.getECoreUtil().copyAll(merge.predicate));
    // Copy assignments
    self.assignment.addAll(emfTool.getECoreUtil().copyAll(merge.assignment));
    // Copy operations
    self.enforcementOperation.addAll(emfTool.getECoreUtil().copyAll(merge.enforcementOperation));
}

/**
 * Retruns a Collection of patterns related this pattern. The related patterns
 * are searched in the orginial pattern and its refinement's areas.
 */
@cached
operation QVT!CorePattern getRefinedPatterns(orig : QVT!CorePattern, pattern : String) : Collection {
    
    var refinedAreas;
    if (orig.area.isTypeOf(QVT!Mapping)) {
        refinedAreas = orig.area.refinement;
    } else if (orig.area.isTypeOf(QVT!CoreDomain)) {
        refinedAreas = orig.area.rule.refinement.collect(m | m.domain).flatten().select(d | d.typedModel == orig.area.typedModel);
    }
    if (pattern = "guard") {
        return refinedAreas.collect(r | r.guardPattern);
    } else if (pattern = "bottom") {
        return refinedAreas.collect(r | r.bottomPattern);
    }
}






