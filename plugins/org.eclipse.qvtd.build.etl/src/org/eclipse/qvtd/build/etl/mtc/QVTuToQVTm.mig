/*******************************************************************************
 * Copyright (c) 2013 The University of York, Willink Transformations and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "Helpers.eol";
import "OclLibHelper.eol";

pre {
    var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
}

// Refinned mappings
migrate Mapping
    when : original.refinement.size() > 0 {
        
        //original.println("Maping ");
        for (refined in original.refinement) {
            //refined.println("refined ");
            // For each domain in the refined mapping, if it doesn't exist, copy it. If it does exist, merge it.
            // Domains added first so nested mappings can find them
            for (d in refined.collect(r | r.domain).flatten()) {
                if (not migrated.domain.exists(ed | ed.name == d.name)) {
                    //d.println("Copy ");
                    migrated.domain.add(emfTool.getECoreUtil().copy(d.equivalent()));
                } else {
                    //d.println("Merge ");
                    var local = migrated.domain.selectOne(ed | ed.name == d.name);
                    local.guardPattern.mergeGuardPatterns(d.equivalent().guardPattern);
                    local.bottomPattern.mergeBottomPatterns(d.equivalent().bottomPattern);
                }
            }
            // Merge middle patterns
            migrated.guardPattern.mergeGuardPatterns(refined.equivalent().guardPattern);
            migrated.bottomPattern.mergeBottomPatterns(refined.equivalent().bottomPattern);

            // Nested mappings with no domains. Since many mappings can refine the same mapping
            // get the equivalent and copy (create) them. If the migrated mapping already has a nested mapping it has to be merged
            for (m in refined.collect(r | r.local.select(nm | nm.domain.isEmpty())).flatten()) {
                if (migrated.local.isEmpty()) {
                    migrated.local.add(emfTool.getECoreUtil().copy(m.equivalent()));
	            } else {
	                var local = migrated.local.selectOne(m | m.domain.isEmpty());
	                local.guardPattern.mergeGuardPatterns(m.equivalent().guardPattern);
	                local.bottomPattern.mergeBottomPatterns(m.equivalent().bottomPattern);
	            }
            }
            // TODO For nested mappings with domains Possibly a similar mapping with the same domains must be found
        }
        
        // Fix references
        migrated.guardPattern.fixPredicateVarReferences();
        migrated.bottomPattern.fixPredicateVarReferences();
        migrated.bottomPattern.fixOperationCallReferences();
        migrated.bottomPattern.fixAssignmentVarReferences();
        for (d in migrated.domain) {
            d.guardPattern.fixPredicateVarReferences();
            d.bottomPattern.fixPredicateVarReferences();
            d.bottomPattern.fixOperationCallReferences();
            d.bottomPattern.fixAssignmentVarReferences();
        }
        for (m in migrated.local) {
            m.guardPattern.fixPredicateVarReferences();
            m.bottomPattern.fixPredicateVarReferences();
            m.bottomPattern.fixOperationCallReferences();
            m.bottomPattern.fixAssignmentVarReferences();
        }
        // Remove the refinements
        migrated.refinement = Set{};
    }

/**
 * Merge a GuardPattern with another one. This operation is to be used when
 * flattening a mapping to compose domains and nested mappings.
 */    
operation QVT!GuardPattern mergeGuardPatterns(merge : QVT!GuardPattern) {

    // Variables. Search for variables in the refined mapping. Copy all variables that have
    // different names as the local variables. If there is any with the same name, re-type it
    var localVarNames = self.variable.collect(v | v.name); 
    
    // TODO this should be an OCL constraint: if mapping refines, and there is
    // a variable with the same name, then its type should be the same or extend
    // it
    //var refinedPatterns = self.getRefinedPatterns(merge, "guard");
    //refinedPatterns.println("refined patterns ");
    //for (localVar in self.variable) {
    //    localVar.retypeVar(refinedPatterns);
    //}
    
    // Straight copy non-refined variables
    self.variable.addAll(emfTool.getECoreUtil().copyAll(merge.variable.select(v | not localVarNames.includes(v.name))));
    // Copy predicates
    self.predicate.addAll(emfTool.getECoreUtil().copyAll(merge.predicate));
}

/**
 * Merge a BottomPattern with another one. This operation is to be used when
 * flattening a mapping to compose domains and nested mappings.
 */    
operation QVT!BottomPattern mergeBottomPatterns(merge : QVT!BottomPattern) {

    // Variables. Search for variables in the refined mapping. Copy all variables that have
    // different names as the local variables. If there is any with the same name, re-type it
    var localVarNames = self.variable.collect(v | v.name);
        
    // Perhaps this shuold be done after all the refinements have been done
    //var refinedPatterns = self.getRefinedPatterns(merge, "bottom");
    //for (localVar in self.variable) {
    //    localVar.retypeVar(refinedPatterns);
    //}
    
    
    // Straight copy non-refined variables
    self.variable.addAll(emfTool.getECoreUtil().copyAll(merge.variable.select(v | not localVarNames.includes(v.name))));
    
    // The same for realized variables
    var localRealizedVarNames = self.realizedVariable.collect(v | v.name);
    
    //for (localVar in self.realizedVariable) {
    //    localVar.retypeRealizedVar(refinedPatterns);
    //}
    
    // Straight copy non-refined realized variables
    self.realizedVariable.addAll(emfTool.getECoreUtil().copyAll(merge.realizedVariable.select(v | not localRealizedVarNames.includes(v.name))));
    // Copy predicates
    self.predicate.addAll(emfTool.getECoreUtil().copyAll(merge.predicate));
    // Copy assignments
    self.assignment.addAll(emfTool.getECoreUtil().copyAll(merge.assignment));
    // Copy operations
    self.enforcementOperation.addAll(emfTool.getECoreUtil().copyAll(merge.enforcementOperation));
}

/**
 * Retruns a Collection of patterns related this pattern. The related patterns
 * are searched in the orginial pattern and its refinement's areas.
 */
@cached
operation QVT!CorePattern getRefinedPatterns(orig : QVT!CorePattern, pattern : String) : Collection {
    
    var refinedAreas;
    if (orig.area.isTypeOf(QVT!Mapping)) {
        refinedAreas = orig.area.refinement;
    } else if (orig.area.isTypeOf(QVT!CoreDomain)) {
        refinedAreas = orig.area.rule.refinement.collect(m | m.domain).flatten().select(d | d.typedModel == orig.area.typedModel);
    }
    if (pattern = "guard") {
        return refinedAreas.collect(r | r.guardPattern);
    } else if (pattern = "bottom") {
        return refinedAreas.collect(r | r.bottomPattern);
    }
}

/**
 * Finds all variables referenced in a Preicate.
 */
@cached
operation QVT!Predicate findRreferencedVariables() : Collection {
    return self.conditionExpression.findRreferencedVariables();
}

/**
 * Finds all variables referenced in a Pattern by finding all references in
 * the pattern's predicates.
 */
@cached
operation QVT!GuardPattern findReferencesInPattern(variable : QVT!TypedElement) {
    
    return self.variable.selectOne(lv | lv.name == variable.name);
}

@cached
operation QVT!BottomPattern findReferencesInPattern(variable : QVT!TypedElement) {
    
    var name;
    if (variable.isTypeOf(QVT!CollectionItem)) {
        name = variable.item.asString();
    } else {
        name = variable.name;
    }
    return self.variable.includingAll(self.realizedVariable).selectOne(lv | lv.name == name);
}

/**
 * Finds all variables referenced in a set of Pattern by finding all references
 * each of the patterns.
 */
operation QVT!TypedElement findReferencesInPatterns(patterns : Sequence) {
    
    var targetVar = null;
    for (p in patterns) {
        targetVar = p.findReferencesInPattern(self);
        if (targetVar <> null) {
           return targetVar;
        }
    }
}

operation QVT!Area getContextMappingPatterns() : Sequence {

    var mapping;
    if (self.isTypeOf(QVTu!CoreDomain)) {
        mapping = self.rule;
    } else if (self.isTypeOf(QVTu!Mapping)) {
        mapping = self;
    }
    var searchPatterns = new Sequence;
    if (mapping.context.isDefined()) {
        searchPatterns.addAll(mapping.context.domain.collect(d | d.guardPattern).flatten());
        searchPatterns.addAll(mapping.context.domain.collect(d | d.bottomPattern).flatten());
        searchPatterns.add(mapping.context.guardPattern);
        searchPatterns.add(mapping.context.bottomPattern);
        searchPatterns.addAll(mapping.context.getContextMappingPatterns());
    }
    return searchPatterns;
}

operation QVT!GuardPattern fixPredicateVarReferences() {
    for (predicate in self.predicate) {
        //predicate.println("Predicate ");
        var refVars =  predicate.findRreferencedVariables();
        //refVars.println("refVars ");
        // Find variables and fix references
        for (v in refVars) {
            //v.println("Fixing ");
            var targetVar = v.findReferencesInPatterns(self.asSequence());
            if (targetVar == null) {
                var searchPatterns;
                if (self.area.isTypeOf(QVTu!CoreDomain)) {
                    // Domain guard patterns depend on guard patterns of domains with depending typed models
                    searchPatterns = self.area.rule.domain.select(d | d.typedModel.dependsOn.includes(self.area.typedModel)).collect(d | d.guardPattern).flatten();
                } else if (self.area.isTypeOf(QVTu!Mapping)) {
                    // 1. Mapping's domain guard patterns
                    searchPatterns = self.area.domain.collect(d | d.guardPattern).flatten();
                }
                targetVar = v.findReferencesInPatterns(searchPatterns);
                if (targetVar == null) {
                    // Search in the context
	                searchPatterns = self.area.getContextMappingPatterns();
	                targetVar = v.findReferencesInPatterns(searchPatterns);
                }
            }
            if (targetVar == null) {
                if (self.area.isTypeOf(QVTu!Mapping)) {
                    throw "Error! not able to find a local reference for variable " + v + " in predicate " + predicate + "in GuardPattern of Mapping " + self.area;  
                } else if(self.area.isTypeOf(QVTu!CoreDomain)) {
                    throw "Error! not able to find a local reference for variable " + v + " in predicate " + predicate + "in GuardPattern of Domain " + self.area;  
                }  
            }
            //targetVar.println("local ");
            predicate.conditionExpression.fixVarReferences(targetVar);
        }
    }
}


operation QVT!BottomPattern fixPredicateVarReferences() {
    
    for (predicate in self.predicate) {
        //predicate.println("Predicate ");
        var refVars =  predicate.findRreferencedVariables();
        //refVars.println("refVars ");
        // Find variables and fix references
        for (v in refVars) {
            //v.println("Fixing ");
            // MiddleGuard Pattern depends on domain guard patterns
            var targetVar = v.findReferencesInPatterns(self.asSequence());
            if (targetVar == null) {
                var searchPatterns;
                if (self.area.isTypeOf(QVTu!CoreDomain)) {
                    // 1. Guard Pattern of the Domain
                    searchPatterns = self.area.rule.domain.collect(d | d.guardPattern).flatten();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Bottom Pattern of domains with depending typed models
                    if (targetVar == null) {
                        searchPatterns = self.area.rule.domain.select(d | d.typedModel.dependsOn.includes(self.area.typedModel)).collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                    }
                    
                } else if (self.area.isTypeOf(QVTu!Mapping)) {
                    // 1. Guard Pattern of the Mapping
                    searchPatterns = self.area.guardPattern.asSet();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Mapping's domain bottom pattern
                    if (targetVar == null) {
                        searchPatterns = self.area.domain.collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                        if (targetVar == null) {
                            // 3. Mapping's domain guard patterns
                            searchPatterns = self.area.domain.collect(d | d.guardPattern).flatten();
                            targetVar = v.findReferencesInPatterns(searchPatterns); 
                        }
                    }
                }
                if (targetVar == null) {
	                // Search in the context
	                searchPatterns = self.area.getContextMappingPatterns();
	                targetVar = v.findReferencesInPatterns(searchPatterns);
	            }
            }
            if (targetVar == null) {
                if (self.area.isTypeOf(QVTu!Mapping)) {
                    throw "Error! not able to find a local reference for variable " + v + " in predicate " + predicate + "in BottomPattern of Mapping " + self.area;  
                } else if(self.area.isTypeOf(QVTu!CoreDomain)) {
                    throw "Error! not able to find a local reference for variable " + v + " in predicate " + predicate + "in BottomPattern of Domain " + self.area;  
                }  
            }
            //targetVar.println("local ");
            predicate.conditionExpression.fixVarReferences(targetVar);
        }
    }
}

@cached
operation QVT!Assignment findRreferencedVariables() : Set {
    
    var varRefs : Set();
    varRefs = self.value.findRreferencedVariables();
    if (self.isTypeOf(QVTu!PropertyAssignment)) {
        varRefs.addAll(self.slotExpression.findRreferencedVariables());
    } else if (self.isTypeOf(QVTu!VariableAssignment)) {
        varRefs.add(self.targetVariable);
    }
    return varRefs;
}

operation QVT!BottomPattern fixAssignmentVarReferences() {
    for (assignment in self.assignment) {
        //assignment.println("Assignment ");
        var refVars =  assignment.findRreferencedVariables();
        //refVars.println("refVars ");
        // Find variables and fix references
        for (v in refVars) {
            //v.println("Fixing ");
            // MiddleGuard Pattern depends on domain guard patterns
            var targetVar = v.findReferencesInPatterns(self.asSequence());
            if (targetVar == null) {
                var searchPatterns;
                if (self.area.isTypeOf(QVTu!CoreDomain)) {
                    // 1. Guard Pattern of the Domain
                    searchPatterns = self.area.rule.domain.collect(d | d.guardPattern).flatten();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Bottom Pattern of domains with depending typed models
                    if (targetVar == null) {
                        searchPatterns = self.area.rule.domain.select(d | d.typedModel.dependsOn.includes(self.area.typedModel)).collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                    }
                } else if (self.area.isTypeOf(QVTu!Mapping)) {
                    // 1. Guard Pattern of the Mapping
                    searchPatterns = self.area.guardPattern.asSequence();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Mapping's domain bottom pattern
                    if (targetVar == null) {
                        searchPatterns = self.area.domain.collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                        if (targetVar == null) {
                            // 3. Mapping's domain guard patterns
                            searchPatterns = self.area.domain.collect(d | d.guardPattern).flatten();
                            targetVar = v.findReferencesInPatterns(searchPatterns); 
                        }
                    }
                }
                if (targetVar == null) {
                    // Search in the context
                    searchPatterns = self.area.getContextMappingPatterns();
                    targetVar = v.findReferencesInPatterns(searchPatterns);
                }
            }
            if (targetVar == null) {
                if (self.area.isTypeOf(QVTu!Mapping)) {
                    throw "Error! not able to find a local reference for variable " + v + " in assignemnt " + assignment + "in BottomPattern of Mapping " + self.area;  
                } else if(self.area.isTypeOf(QVTu!CoreDomain)) {
                    throw "Error! not able to find a local reference for variable " + v + " in assignment " + assignment + "in BottomPattern of Domain " + self.area;  
                }  
            }
            assignment.value.fixVarReferences(targetVar);
		    if (assignment.isTypeOf(QVTu!PropertyAssignment)) {
                assignment.slotExpression.fixVarReferences(targetVar);
		    } else if (assignment.isTypeOf(QVTu!VariableAssignment)) {
		        if (assignment.targetVariable.name = targetVar.name) {
		            assignment.targetVariable = targetVar;
		        }
		    }
        }
    }
}

operation QVT!BottomPattern fixOperationCallReferences() {
    for (o in self.enforcementOperation) {
        //predicate.println("Predicate ");
        var refVars =  o.operationCallExp.findRreferencedVariables();
        //refVars.println("refVars ");
        // Find variables and fix references
        for (v in refVars) {
            //v.println("Fixing ");
            // MiddleGuard Pattern depends on domain guard patterns
            var targetVar = v.findReferencesInPatterns(self.asSequence());
            if (targetVar == null) {
                var searchPatterns;
                if (self.area.isTypeOf(QVTu!CoreDomain)) {
                    // 1. Guard Pattern of the Domain
                    searchPatterns = self.area.rule.domain.collect(d | d.guardPattern).flatten();
                    searchPatterns.println();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Bottom Pattern of domains with depending typed models
                    if (targetVar == null) {
                        searchPatterns = self.area.rule.domain.select(d | d.typedModel.dependsOn.includes(self.area.typedModel)).collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                    }
                } else if (self.area.isTypeOf(QVTu!Mapping)) {
                    // 1. Guard Pattern of the Mapping
                    searchPatterns = self.area.guardPattern.asSequence();
                    targetVar = v.findReferencesInPatterns(searchPatterns); 
                    // 2. Mapping's domain bottom pattern
                    if (targetVar == null) {
                        searchPatterns = self.area.domain.collect(d | d.bottomPattern).flatten();
                        targetVar = v.findReferencesInPatterns(searchPatterns); 
                        if (targetVar == null) {
                            // 3. Mapping's domain guard patterns
                            searchPatterns = self.area.domain.collect(d | d.guardPattern).flatten();
                            targetVar = v.findReferencesInPatterns(searchPatterns); 
                        }
                    }
                }
                if (targetVar == null) {
                    // Search in the context
                    searchPatterns = self.area.getContextMappingPatterns();
                    targetVar = v.findReferencesInPatterns(searchPatterns);
                }
            }
            if (targetVar == null) {
                if (self.area.isTypeOf(QVTu!Mapping)) {
                    throw "Error! not able to find a local reference for variable " + v + " in operation " + o + "in BottomPattern of Mapping " + self.area;  
                } else if(self.area.isTypeOf(QVTu!CoreDomain)) {
                    throw "Error! not able to find a local reference for variable " + v + " in operation " + o + "in BottomPattern of Domain " + self.area;  
                }  
            }
            o.operationCallExp.fixVarReferences(targetVar);
        }
    }
}

