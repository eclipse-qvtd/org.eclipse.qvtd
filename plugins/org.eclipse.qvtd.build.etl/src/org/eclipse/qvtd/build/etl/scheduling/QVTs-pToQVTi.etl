/*******************************************************************************
 * Copyright (c) 2014 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "../helpers/OclExpressionAnalysis.eol";
import "../helpers/QVTHelpers.eol";

pre {
    var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
}

//=============== QVTp to QVTi (just copy)  ===============

rule ImperativeModel
    transform mIn : QVTp!ImperativeModel
    to mOut : QVTi!ImperativeModel
    {
        
        mOut.externalURI = mIn.externalURI.replace(".qvtp.qvti", ".qvti");
        mOut.nestedPackage.addAll(mIn.nestedPackage.equivalent());
        // Copy the OCL types package
        mOut.nestedPackage.add(emfTool.getEcoreUtil().copy(mIn.nestedPackage.selectOne(p | p.isTypeOf(QVTp!Package))));
    }

@abstract
rule NamedElements
    transform eIn : QVTp!NamedElement
    to eOut : QVTi!NamedElement
    {
        eOut.name = eIn.name;
    }
    
rule Transformations
    transform tIn : QVTp!Transformation
    to tOut : QVTi!Transformation
    extends NamedElements
    {
        
        tOut.ownedTag = emfTool.getEcoreUtil().copyAll(tIn.ownedTag);
        tOut.modelParameter = emfTool.getEcoreUtil().copyAll(tIn.modelParameter);
        tOut.`rule`.addAll(tIn.`rule`.equivalent());
        tOut.`extends` ::= tIn.`extends`;
    }

@abstract
rule Rules
    transform rIn : QVTp!Rule
    to rOut : QVTi!Rule
    extends NamedElements
    {

        rOut.domain.addAll(rIn.domain.equivalent());
        rOut.overrides ::= rIn.overrides;
        rOut.transformation ::= rIn.transformation;
        rOut.overridden.addAll(rIn.overridden.equivalent());
    }

@abstract
rule Areas
    transform aIn : QVTp!Area
    to aOut : QVTi!Area
    {
    
        aOut.guardPattern ::= aIn.guardPattern;
        aOut.bottomPattern ::= aIn.bottomPattern;
    }

rule Mappings
    transform mIn : QVTp!Mapping
    to mOut : QVTi!Mapping
    extends Rules, Areas
    {
        
        var ma = QVTs!MappingAction.all().selectOne(ma | ma.mapping.name == mIn.name); 
        if (not ma.children.isEmpty()) {
            mIn.name.println("Children ");
            mOut.mappingStatement = new QVTi!MappingSequence;
            // Add loops of mapping calls accordingly... hard!
            if (ma.hasLoopVariable()) {
                mOut.mappingStatement.mappingStatements.addAll(ma.children.collect(ma | ma.distinctArguments).flatten().equivalent());
            } else {
                mOut.mappingStatement.mappingStatements.addAll(ma.children.equivalent());
            }
        }
    }

@abstract
rule Domains
    transform dIn : QVTp!Domain
    to dOut : QVTi!Domain
    {
        dOut.isCheckable = dIn.isCheckable;
        dOut.isEnforceable = dIn.isEnforceable;
        dOut.`rule` ::= dIn.`rule`;
        dOut.typedModel ::= dIn.typedModel; 
    } 

rule CodeDomains
    transform cdIn : QVTp!CoreDomain
    to cdOut : QVTp!CoreDomain
    extends Domains, Areas
    {
        
    }

@abstract        
rule Patterns
    transform pIn : QVTp!Pattern
    to pOut : QVTi!Pattern
    {
        pOut.predicate.addAll(pIn.predicate.equivalent());
        pOut.bindsTo.addAll(pIn.bindsTo.equivalent());
    }

@abstract
rule CorePatterns
    transform cpIn : QVTp!CorePattern
    to cpOut : QVTi!CorePattern
    extends Patterns
    {
    
        cpOut.variable.addAll(cpIn.variable.equivalent());
    }        
    
rule BottomPatterns
    transform bpIn : QVTp!BottomPattern
    to bpOut : QVTi!BottomPattern
    extends CorePatterns
    {
        bpOut.area ::= bpIn.area;
        bpOut.assignment.addAll(bpIn.assignment.equivalent());
        bpOut.enforcementOperation.addAll(bpIn.enforcementOperation.equivalent());
        bpOut.variable.addAll(bpIn.variable.equivalent());
        bpOut.realizedVariable.addAll(bpIn.realizedVariable.equivalent());
    }

rule GuardPatterns
    transform gpIn : QVTp!GuardPattern
    to gpOut : QVTi!GuardPattern
    extends CorePatterns
    {
        gpOut.area ::= gpIn.area;
    }

@abstract
rule Assignments
    transform aIn : QVTp!Assignment
    to aOut : QVTi!Assignemnt
    {
        aOut.bottomPattern ::= aIn.bottomPattern;
        aOut.isDefault = aIn.isDefault;
        aOut.value = emfTool.getEcoreUtil().copy(aIn.value);
        var vars;
        if (aIn.bottomPattern.area.isTypeOf(QVTi!CoreDomain)) {
            vars = aIn.bottomPattern.area.`rule`.getAllVariables().equivalent();
        } else {
            vars = aIn.bottomPattern.area.getAllVariables().equivalent();
        }
        for (vFix in vars) {
            aOut.value.fixVarReferences(vFix);
        }
    }

rule PropertyAssignments
    transform paIn : QVTp!PropertyAssignment
    to paOut : QVTi!PropertyAssignment
    extends Assignments
    {
        paOut.slotExpression = emfTool.getEcoreUtil().copy(paIn.slotExpression);
        paOut.targetProperty = paIn.targetProperty;
        var vars;
        if (paIn.bottomPattern.area.isTypeOf(QVTi!CoreDomain)) {
            vars = paIn.bottomPattern.area.`rule`.getAllVariables().equivalent();
        } else {
            vars = paIn.bottomPattern.area.getAllVariables().equivalent();
        }
        for (vFix in vars) {
            paOut.slotExpression.fixVarReferences(vFix);
        }
    }

rule VariableAssignments
    transform vaIn : QVTp!VariableAssignment
    to vaOut : QVTi!VariableAssignment
    extends Assignments
    {
        vaOut.targetVariable ::= vaIn.targetVariable;
    }
     
rule Variables
    transform vIn : QVTp!Variable
    to vOut : QVTi!Variable
    extends NamedElements
    {
        // Not a loop variable
        guard : not vIn.eContainer.isTypeOf(QVTp!IteratorExp)
        
        vOut.implicit = vIn.implicit;
        vOut.type = vIn.type;
    }
    
rule RealizedVariables
    transform vIn : QVTp!RealizedVariable
    to vOut : QVTi!RealizedVariable
    extends NamedElements
    {
        vOut.implicit = vIn.implicit;
        vOut.type = vIn.type;
    }

//=============== QVTs to QVTi (add mapping calls)  ===============

rule MappingActions
    transform ma : QVTs!MappingAction
    to mc : QVTi!MappingCall
    {
        guard : ma.parent.isDefined()
        
        mc.referredMapping = ma.mapping;
        mc.binding.addAll(ma.distinctArguments.collect(da | da.primaryArguments.includingAll(da.secondaryArguments)).equivalent().select(e | e.isTypeOf(QVTi!MappingCallBinding)));
    }

    
rule DistinctData
    transform dd : QVTs!DistinctData
    to loop : QVTi!MappingLoop
    {
        
        var it = new QVTi!Variable;
        it.name = dd.primaryArguments.first().variable.name;
        it.type = dd.primaryArguments.first().variable.type;
        loop.iterator.add(it);
        var exp = new QVTi!OperationCallExp;
        exp.referredOperation = getClassByName("OclElement").getOperationByName("allInstances");
        exp.source = new QVTi!TypeExp;
        exp.source.type = dd.primaryArguments.first().variable.type;
        loop.source = exp;
        // TODO what happens with multiple Distinct Datas?
        loop.body ::= dd.target;
        
    }
    

rule DataParameter
    transform dp : QVTs!DataParameter
    to cb : QVTi!MappingCallBinding
    {
        
        cb.boundVariable = dp.variable;
        cb.value = new QVTi!VariableExp;
        if (dp.primaryDistinctData.isDefined()) {
            cb.value.referredVariable = dp.primaryDistinctData.equivalent().iterator.first();
            cb.mappingCall ::= dp.primaryDistinctData.target;
        } else {
            cb.value.referredVariable = dp.secondaryDistinctData.equivalent().iterator.first();
            cb.mappingCall ::= dp.secondaryDistinctData.target;
        }
        
    }

operation QVTs!MappingAction hasLoopVariable() : Boolean {
    
    // This is the actual operation that finds the nesting
    return true;
}


post {
    "QVTp+s to QVTi Done".println();
}    