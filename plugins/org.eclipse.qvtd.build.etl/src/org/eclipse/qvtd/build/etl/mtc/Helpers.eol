@chached
operation isInputDomain(area : QVT!Area) : Boolean {
    return area.isTypeOf(QVT!CoreDomain) and
        config!Configuration.all.first().inputDirection.name == area.typedModel.name;
}

@chached
operation isMiddleDomain(area : QVT!Area) : Boolean {
    return area.isTypeOf(QVT!Mapping) and area.name.size() > 0;
}

@chached
operation isOutputDomain(area : QVT!Area) : Boolean {
    return area.isTypeOf(QVT!CoreDomain) and
        config!Configuration.all.first().outputDirection.collect(od | od.name).includes(area.typedModel.name);
}

operation isCheckMode() : Boolean {
    return config!Configuration.all.first().mode == config!Mode#checking;
}

operation isEnforceMode() : Boolean {
    return config!Configuration.all.first().mode == config!Mode#enforcement;
}

@cached
operation QVT!RealizedVariable oppositeBottomPattern() : QVT!BottomPattern  {
    return QVT!BottomPattern.all.selectOne(p |p.realizedVariable.includes(self)); }

@cached
operation QVT!Variable oppositePattern() : QVT!CorePattern  {
    
    if(self.isTypeOf(QVT!Variable)) {
        return QVT!CorePattern.all.selectOne(p |p.variable.includes(self));
    }
    if (self.isTypeOf(QVT!RealizedVariable)) {
        return self.oppositeBottomPattern();
    }     
}

// How to find the domain of an OCL expression? It depends on the expression.. but it can get nasty
@cached
operation QVT!OCLExpression getArea() : QVT!Area {
    //var area : QVT!Area;
    if (self.isTypeOf(QVT!VariableExp)) {
        // TODO Hack to deal with undefined variable types? Why is this happening
        if (self.referredVariable.type() == null) {
            return null;
        }
        return self.referredVariable.oppositePattern().area;
    } else if (self.isKindOf(QVT!CallExp)) {
        return self.source.getArea();
    } else if (self.isTypeOf(QVT!IfExp)) {
        return self.condition.getArea();
    } else if (self.isKindOf(QVT!LiteralExp)) {
        return null;
    } else {
        self.println();
        throw "Error! Add getArea for " + self.type();
    }
    return null;
}

operation QVT!OCLExpression findRreferencedVariables() : Set {
    var varRefs : Set();
    if (self.isTypeOf(QVT!VariableExp)) {
        varRefs.add(self.referredVariable);
    } else if (self.isTypeOf(QVT!OperationCallExp)) {
        varRefs.addAll(self.source.findRreferencedVariables());
        for (arg in self.argument) {
            varRefs.addAll(arg.findRreferencedVariables());
        }
    } else if (self.isTypeOf(QVT!PropertyCallExp)) {
        varRefs.addAll(self.source.findRreferencedVariables());
    } else if (self.isTypeOf(QVT!IfExp)) {
        varRefs.addAll(self.condition.findRreferencedVariables());
        varRefs.addAll(self.elseExpression.findRreferencedVariables());
        varRefs.addAll(self.thenExpression.findRreferencedVariables());
    } else if (self.isTypeOf(QVT!CollectionLiteralExp)){
        varRefs.addAll(self.part);
    } else if (self.isKindOf(QVT!LiteralExp)) {
      // Noting to add
    } else {
        self.println();
        throw "Error! Add findRreferencedVariables() for " + self.type();
    }
    return varRefs;
}

// TODO Ask what PropertyCallExp.qualifier is/works in QVT
operation QVT!OCLExpression fixVarReferences(v : QVT!Variable) {
    if (self.isTypeOf(QVT!VariableExp)) {
        if (self.referredVariable.name = v.name) {
            //v.println("Fixed a reference to v ");
            self.referredVariable = v;
        }
    } else if (self.isTypeOf(QVT!OperationCallExp)) {
        self.source.fixVarReferences(v);
        for (arg in self.argument) {
           arg.fixVarReferences(v);
        }
    } else if (self.isTypeOf(QVT!PropertyCallExp)) {
        self.source.fixVarReferences(v);
    } else if (self.isTypeOf(QVT!IfExp)) {
        self.condition.fixVarReferences(v);
        self.elseExpression.fixVarReferences(v);
        self.thenExpression.fixVarReferences(v);
    } else if (self.isTypeOf(QVT!CollectionLiteralExp)) {
        if (self.part.exists(p | p.name == v.name)) {
            self.part.remove(self.part.select(p | p.name == v.name));
            self.part.add(v);
        }
    } else if (self.isKindOf(QVT!LiteralExp)) {
      // Noting to fix
    } else {
        self.println();
        throw "Error! Add fixVarReference() for " + self.type();
    }
 }
 
/* Retype variables by searching variables with the same name in the
 * refined guard patterns.
 */  
operation QVT!Variable retypeVar(refinedGuardPatterns : Collection) {
    // Same names
    //self.println("Retype vars " + refinedGuardPatterns.type() );
    var refinedVars = refinedGuardPatterns.collect(
                p | p.variable
                ).flatten().select(
                    v | v.name == self.name
                    );
    if (refinedVars.size() > 0) {
        var lrv = x.getLowestRankVariable(refinedVars.including(self));
        self.type = lrv.type;
    }
}

/* Retype variables by searching variables with the same name in the
 * refined guard patterns.
 */  
operation QVT!Variable retypeRealizedVar(refinedBottomPatterns : Collection) {
    // Same names
    //self.println("Retype vars " + refinedGuardPatterns.type() );
    var refinedVars = refinedBottomPatterns.collect(
                p | p.realizedVariable
                ).flatten().select(
                    v | v.name == self.name
                    );
    if (refinedVars.size() > 0) {
        var lrv = x.getLowestRankVariable(refinedVars.including(self));
        self.type = lrv.type;
    }
}
 

operation getUnidirComment() : String {
    var comment : String;
    comment = "/* ";
    /* Enforce uml to rdbms */
    if (config!Configuration.all.first().mode == config!Mode#enforcement) {
        comment = comment + "Enforce ";
    } else {
        comment = comment + "Check ";
    }
    comment = comment + config!Configuration.all.first().inputDirection.name + " to ";
    comment = comment + config!Configuration.all.first().outputDirection.collect(d | d.name).concat(",") + " /*";
    comment.println();
    return comment; 
}

