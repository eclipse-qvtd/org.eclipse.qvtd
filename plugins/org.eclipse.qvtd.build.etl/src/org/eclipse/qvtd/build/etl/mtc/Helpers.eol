/*******************************************************************************
 * Copyright (c) 2013 The University of York, Willink Transformations and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/

/**
 * Returns true if the area is of type QVT!CoreDomain and it's TypedModel is the
 * input domain.
 * <p>
 * The operation is @chached to improve performance.
 * @param area the area to be tested
 */
@chached
operation isInputDomain(area : QVT!Area) : Boolean {
    return area.isTypeOf(QVT!CoreDomain) and
        config!Configuration.all.first().inputDirection.name == area.typedModel.name;
}

/**
 * Returns true if the area is of type QVT!Mapping.
 * <p>
 * The operation is @chached to improve performance.
 * @param area the area to be tested
 */
@chached
operation isMiddleDomain(area : QVT!Area) : Boolean {
    return area.isTypeOf(QVT!Mapping);
}

/**
 * Returns true if the area is of type QVT!CoreDomain and it's TypedModel is any
 * of the output domains.
 * <p>
 * The operation is @chached to improve performance.
 * @param area the area to be tested
 */
@chached
operation isOutputDomain(area : QVT!Area) : Boolean {
    return area.isTypeOf(QVT!CoreDomain) and
        config!Configuration.all.first().outputDirection.collect(od | od.name).includes(area.typedModel.name);
}

/**
 * Returns true if the transformation is invoked in check mode.
 */
operation isCheckMode() : Boolean {
    return config!Configuration.all.first().mode == config!Mode#checking;
}

/**
 * Returns true if the transformation is invoked in enforce mode.
 */
operation isEnforceMode() : Boolean {
    return config!Configuration.all.first().mode == config!Mode#enforcement;
}

/** 
 * Returns the tranformation of a mapping. Does a bottom up recursive search
 */
operation QVT!Mapping getTransforamtion() : QVT!Transformation {
    if (self.transformation.isDefined()) {
        return self.transformation;
    } else if (self.context.isDefined()) {
        return self.context.getTransforamtion();
    } else {
        self.err("Cotextless mapping ");
    }
}

/**
 * Returns the typed model of a tranformation that corresponds to the middle
 * model.
 */
operation QVT!Transformation getMiddleTypedModel() : QVT!TypedModel {

    return self.modelParameter.selectOne(tm | tm.name = config!Configuration.all.first().middle.name);
}

/**
 * Returns the pattern to which a variable belongs.
 * <p>
 * The operation is @chached to improve performance.
 */
@cached
operation QVT!Variable oppositePattern() : QVT!CorePattern  {
    
    if(self.isTypeOf(QVT!Variable)) {
        return QVT!CorePattern.all.selectOne(p |p.variable.includes(self));
    } else if (self.isTypeOf(QVT!RealizedVariable)) {
        return QVT!BottomPattern.all.selectOne(p |p.realizedVariable.includes(self));
    }
}

/**
 * Returns the area that defines the environment of an OCL expression. The results
 * depends on the type of the OCL expression. 
 * <p>
 * The operation is @chached to improve performance.
 */
@cached
operation QVT!OCLExpression getArea() : QVT!Area {
    if (self.isTypeOf(QVT!VariableExp)) {
        if (self.referredVariable.type() == null) {
            return null;
        }
        return self.referredVariable.oppositePattern().area;
    } else if (self.isKindOf(QVT!CallExp)) {
        return self.source.getArea();
    } else if (self.isTypeOf(QVT!IfExp)) {
        return self.condition.getArea();
    } else if (self.isKindOf(QVT!LiteralExp)) {
        return null;
    } else {
        self.println();
        throw "Error! Add getArea for " + self.type();
    }
    return null;
}

/**
 * Returns the set of variables used in the OCL expression. 
 */
operation QVT!OCLExpression findRreferencedVariables() : Set {
    return self.findRreferencedVariables(Set{});
}

/**
 * Returns the set of variables used in the OCL expression, ignoring the
 * variables in the ignore set. Usefull for analyzing IteratorExp
 */
operation QVT!OCLExpression findRreferencedVariables(ignore : Set) : Set {
    var varRefs : Set();
    if (self.isTypeOf(QVT!VariableExp)) {
        varRefs.add(self.referredVariable);
    } else if (self.isTypeOf(QVT!OperationCallExp)) {
        varRefs.addAll(self.source.findRreferencedVariables());
        for (arg in self.argument) {
            varRefs.addAll(arg.findRreferencedVariables());
        }
    } else if (self.isTypeOf(QVT!PropertyCallExp)) {
        varRefs.addAll(self.source.findRreferencedVariables());
    } else if (self.isTypeOf(QVT!IfExp)) {
        varRefs.addAll(self.condition.findRreferencedVariables());
        varRefs.addAll(self.elseExpression.findRreferencedVariables());
        varRefs.addAll(self.thenExpression.findRreferencedVariables());
    } else if (self.isTypeOf(QVT!CollectionLiteralExp)) {
        // TODO Check that it is a collection of variables. 
        // TODO what if it is a collection of collections or other OCL types?
        for (p in self.part) {
            if (p.isTypeOf(QVT!CollectionItem)) {
                varRefs.addAll(p.item.findRreferencedVariables());
            } else {
                self.println();
                throw "Error! Add findRreferencedVariables() for " + p.type() + " in collections";
            }
        }
    } else if (self.isKindOf(QVT!IteratorExp)) {
        // Ignore iterator variables
        varRefs.addAll(self.body.findRreferencedVariables(self.iterator));
        varRefs.addAll(self.source.findRreferencedVariables());
    } else if (self.isKindOf(QVT!LiteralExp)) {
      // Noting to add
    } else {
        self.println();
        throw "Error! Add findRreferencedVariables() for " + self.type();
    }
    return varRefs.excludingAll(ignore);
}

/**
 * Returns the set of variables used in the assignemnt 
 */
operation QVT!Assignment findRreferencedVariables() : Set {
    
    var varRefs : Set();
    varRefs = self.value.findRreferencedVariables();
    if (self.isTypeOf(QVT!PropertyAssignment)) {
        varRefs.addAll(self.slotExpression.findRreferencedVariables());
    } else if (self.isTypeOf(QVT!VariableAssignment)) {
        varRefs.add(self.targetVariable);
    }
    return varRefs;
}

/**
 * Fixes all references to a variable within the OCL expression. The v argument
 * is the variable for which the references must be fixed.
 * 
 * @param v the variable for which the references must be fixed.
 */
operation QVT!OCLExpression fixVarReferences(v : QVT!Variable) {
    if (self.isTypeOf(QVT!VariableExp)) {
        if (self.referredVariable.name = v.name) {
            self.referredVariable = v;
        }
    } else if (self.isTypeOf(QVT!OperationCallExp)) {
        self.source.fixVarReferences(v);
        for (arg in self.argument) {
           arg.fixVarReferences(v);
        }
    } else if (self.isTypeOf(QVT!PropertyCallExp)) {
        self.source.fixVarReferences(v);
    } else if (self.isTypeOf(QVT!IfExp)) {
        self.condition.fixVarReferences(v);
        self.elseExpression.fixVarReferences(v);
        self.thenExpression.fixVarReferences(v);
    } else if (self.isTypeOf(QVT!CollectionLiteralExp)) {
        if (self.part.exists(p | p.name == v.name)) {
            self.part.remove(self.part.select(p | p.name == v.name));
            self.part.add(v);
        }
    } else if (self.isKindOf(QVT!LiteralExp)) {
      // Noting to fix
    } else if (self.isKindOf(QVT!IteratorExp)) {
        self.body.fixVarReferences(v);
        self.source.fixVarReferences(v);
    } else {
        self.println();
        throw "Error! Add fixVarReference() for " + self.type();
    }
 }
 
/**
 * Retypes a variable to the less abstract type of all variables in the patterns
 * with the same name.
 *
 * @param patterns the patterns to look for variables with the same name 
 */  
operation QVT!Variable retypeVar(patterns : Collection) {
    var refinedVars = patterns.collect(
                p | p.variable
                ).flatten().select(
                    v | v.name == self.name
                    );
    if (refinedVars.size() > 0) {
        var x = new Native("org.eclipse.qvtd.build.etl.PivotUtil");
        var lrv = x.getLowestRankVariable(refinedVars.including(self));
        self.type = lrv.type;
    }
}

/**
 * Retypes a realized variable to the less abstract type of all variables in the
 * bottom patterns with the same name.
 *
 * @param patterns the patterns to look for variables with the same name 
 */  
operation QVT!Variable retypeRealizedVar(bottomPatterns : Collection) {
    var refinedVars = bottomPatterns.collect(
                p | p.realizedVariable
                ).flatten().select(
                    v | v.name == self.name
                    );
    if (refinedVars.size() > 0) {
        var x = new Native("org.eclipse.qvtd.build.etl.PivotUtil");
        var lrv = x.getLowestRankVariable(refinedVars.including(self));
        self.type = lrv.type;
    }
}
 
/**
 * Returns the comment added to state the direction in which the transformation
 * was invoked.
 *
 */  
operation getUnidirComment() : String {
    var comment : String = "/* ";
    if (config!Configuration.all.first().mode == config!Mode#enforcement) {
        comment = comment + "Enforce ";
    } else {
        comment = comment + "Check ";
    }
    comment = comment + config!Configuration.all.first().inputDirection.name + " to ";
    comment = comment + config!Configuration.all.first().outputDirection.collect(d | d.name).concat(",") + " */";
    return comment; 
}