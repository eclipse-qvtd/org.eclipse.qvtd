/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "../helpers/OclLibHelper.eol";

/****l* /org.eclipse.qvtd.build.etl/helpers/OCLExpressionAnalysis
 * NAME
 *  QVTiDependenceAnalysis -- Helper functions to analyze OCLExpressions in QVT
 * and understand the relations between variables used in them.
 */ 

/****o* OCLExpressionAnalysis/fixVarReferences
 * NAME
 *  fixVarReferences - Fixes all references to a variable within the OCL
 *  expression.
 * FUNCTION
 *  Matches all variables in the expression with the same name and type as the
 *  input variable and replaces them by references to it.
 * CONTEXT
 *  QVT!OCLExpression The expression for which the references are being fixed
 * PARAMETERS
 *  v The variable to fix
 */
operation QVT!OCLExpression fixVarReferences(v : QVT!Variable) {
    if (self.isTypeOf(QVT!VariableExp)) {
        if (self.referredVariable.name = v.name) {
            self.referredVariable = v;
        }
    } else if (self.isTypeOf(QVT!OperationCallExp)) {
        self.source.fixVarReferences(v);
        for (arg in self.argument) {
           arg.fixVarReferences(v);
        }
    } else if (self.isTypeOf(QVT!PropertyCallExp)) {
        self.source.fixVarReferences(v);
    } else if (self.isTypeOf(QVT!IfExp)) {
        self.condition.fixVarReferences(v);
        self.elseExpression.fixVarReferences(v);
        self.thenExpression.fixVarReferences(v);
    } else if (self.isTypeOf(QVT!CollectionLiteralExp)) {
        for (p in self.part) {
            if (p.isTypeOf(QVT!CollectionItem)) {
                p.item.fixVarReferences(v);
            } else if (p.isTypeOf(QVT!CollectionRange)) {
                p.first.fixVarReferences(v);
                p.last.fixVarReferences(v);
            } 
        } 
    } else if (self.isKindOf(QVT!LiteralExp)) {
      // Noting to fix
    } else if (self.isKindOf(QVT!IteratorExp)) {
        self.body.fixVarReferences(v);
        self.source.fixVarReferences(v);
    } else {
        self.println();
        throw "Error! Add fixVarReference() for " + self.type();
    }
 }

/****o* OCLExpressionAnalysis/findReferencedVariables
 * NAME
 *  findReferencedVariables - Returns the set of variables used in the OCL
 *  expression. 
 * CONTEXT
 *  QVT!OCLExpression The expression to analyze
 *  
 */
operation QVT!OCLExpression findReferencedVariables() : Set {
    return self.findReferencedVariables(Set{});
}

/****o* OCLExpressionAnalysis/findReferencedVariables
 * NAME
 *  findReferencedVariables - Returns the set of variables used in the OCL
 *  expression, ignoring the variables in the ignore set. Usefull for analyzing
 *  IteratorExp (ignore loop variables)
 * CONTEXT
 *  QVT!OCLExpression The expression to analyze
 * PARAMETERS
 *  ignore The set of variables to ignore in the analysis
 */
operation QVT!OCLExpression findReferencedVariables(ignore : Set) : Set {
    var varRefs : Set();
    if (self.isTypeOf(QVT!VariableExp)) {
        varRefs.add(self.referredVariable);
    } else if (self.isTypeOf(QVT!OperationCallExp)) {
        varRefs.addAll(self.source.findReferencedVariables());
        for (arg in self.argument) {
            varRefs.addAll(arg.findReferencedVariables());
        }
    } else if (self.isTypeOf(QVT!PropertyCallExp)) {
        varRefs.addAll(self.source.findReferencedVariables());
    } else if (self.isTypeOf(QVT!IfExp)) {
        varRefs.addAll(self.condition.findReferencedVariables());
        varRefs.addAll(self.elseExpression.findReferencedVariables());
        varRefs.addAll(self.thenExpression.findReferencedVariables());
    } else if (self.isTypeOf(QVT!CollectionLiteralExp)) {
        // TODO Check that it is a collection of variables. 
        // TODO what if it is a collection of collections or other OCL types?
        for (p in self.part) {
            if (p.isTypeOf(QVT!CollectionItem)) {
                varRefs.addAll(p.item.findReferencedVariables());
            } else if (p.isTypeOf(QVT!CollectionRange)) {
                varRefs.addAll(p.first);
                varRefs.addAll(p.last);
            } else {
                self.println();
                throw "Error! Add findReferencedVariables() for " + p.type() + " in collections";
            }
        }
    } else if (self.isKindOf(QVT!IteratorExp)) {
        // Ignore iterator variables
        varRefs.addAll(self.body.findReferencedVariables(self.iterator));
        varRefs.addAll(self.source.findReferencedVariables());
    } else if (self.isKindOf(QVT!LiteralExp)) {
      // Noting to add
    } else {
        self.println();
        throw "Error! Add findReferencedVariables() for " + self.type();
    }
    return varRefs.excludingAll(ignore);
}
 
 // Determine if the OCLExpression is of the form 
 // varA.attribute = varB
 //
operation QVT!OCLExpression isSimpleAttributeNavigation() : Boolean {
    // 1. The OCLExpression must be an operation call 
    if (self.isTypeOf(QVT!OperationCallExp)) {
        // 2. The Operation must be a OclAny "=", operation
        if (self.referredOperation == self.referredOperation.owningType.getOperationByName("=")) {
            // The arguments must be 1: VariableExp
            if ( (self.argument.size() == 1) and self.argument.first().isTypeOf(QVT!VariableExp)) {
                // The source must be a  PropertyCallExp
                if (self.source.isTypeOf(QVT!PropertyCallExp)) {
                    // the source's source must be a VariableExp
                    if (self.source.source.isTypeOf(QVT!VariableExp)) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
 }
 
// Only call if isSimpleAttributeNavigation returns true
// We are only interested in domains
operation QVT!OCLExpression isSingleDomained() : Boolean {
    return self.argument.first().referredVariable.oppositePattern().area.isTypeOf(QVT!CoreDomain)
        and self.argument.first().referredVariable.oppositePattern().area == self.source.source.referredVariable.oppositePattern().area;
}

// Only call if isSimpleAttributeNavigation returns true
// We are only interested in domains
operation QVT!PropertyAssignment isSingleDomained() : Boolean {
    return self.slotExpression.referredVariable.oppositePattern().area == self.value.referredVariable.oppositePattern().area;
}
 
 
// Only call if isSimpleAttributeNavigation returns true
// TODO If isSimpleAttributeNavigation is a requirement, the if statement should
// not exist!
operation QVT!OCLExpression getNavigatedProperty() : QVT!Property {
    if (self.source.isTypeOf(QVT!PropertyCallExp)) {
        return self.source.referredProperty;
    }
} 

// 
// Only call if isSimpleAttributeNavigation returns true
operation QVT!OCLExpression isArgumentVariable(v : QVT!Variable) : Boolean {
    if (self.argument.first().isTypeOf(QVT!VariableExp) and self.argument.first().referredVariable == v) {
        return true;
    }
    return false;
}  

operation QVT!OCLExpression isSourceVariable(v : QVT!Variable) : Boolean {
    if (self.source.source.isTypeOf(QVT!VariableExp) and self.source.source.referredVariable == v) {
        return true;
    }
    return false;
} 
 
operation OCLExpression containmentPredicate() : Boolean {

} 

// Only invoke if ocl expression is simple attribute navigation
operation QVT!OCLExpression getReferredProperty() : Any {
    
    return self.source.referredProperty;
 }