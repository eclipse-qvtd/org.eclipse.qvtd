/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "QVTHelpers.eol";

/**
 * Data Dependencies Helpers. A set of EOL helpers to perform mapping data
 * dependence analysis for a QVT transformation.
 *
 * @cond ddg  A data dependence graph
 * @cond QVT  A QVTx AST model
 * @cond config The QVT transformation configuration
 */
 
/**
 * Get the correspoiding graph node for the AST node. If a graph node for the
 * AST node does not exist, it creates a new one. If it exists, it returns
 * the previously created one. For porformance, the nodeMap attribute works
 * as a cache for previously created nodes.
 * 
 * @context ddg!Graph The graph in which the node should exist
 * @param astNode The QVT AST node for whihc the corresponding graph node is wanted
 * @param nodeMap The map to keep a cache of AST - Node relations
 * 
 */
operation ddg!Graph getNodeForQvtAstNode(astNode : QVT!NamedElement, nodeMap : Map) : ddg!Node {
    var n;
    if (nodeMap.containsKey(astNode)) {
        n = nodeMap.get(astNode);
    } else {
	    n = self.owningModel().createInstance("Node");
	    n.label = getNodeName(astNode);
	    n.qvtAstNode = astNode;
	    n.type = self.getNodeType(astNode);   
	    nodeMap.put(astNode, n);
	    self.element.add(n);
    }
    return n;
}

operation getNodeName(m : QVT!Mapping) : String {
    return m.name;
}

operation getNodeName(v : QVT!Variable) : String {
    return v.type.name;
}

operation ddg!Graph getNodeType(m : QVT!Mapping) : Any {
    //return ddg!NodeType#mapping;
    return self.owningModel().getEnumerationValue("NodeType", "mapping");
}

operation ddg!Graph getNodeType(v : QVT!Variable) : Any {

    if (v.oppositePattern().area.name == "middle") {
        return self.owningModel().getEnumerationValue("NodeType", "middle");//ddg!NodeType#middle;
    } else if(isInputDomain(v.oppositePattern().area)) {
        return self.owningModel().getEnumerationValue("NodeType", "input");//ddg!NodeType#input;
    } else if(isOutputDomain(v.oppositePattern().area)) {
        return self.owningModel().getEnumerationValue("NodeType", "output");//ddg!NodeType#output;      
    } 
}


operation ddg!Graph getNodeForTreeNode(treeNode : tree!Node, nodeMap : Map, nodeType) : ddg!Node {
    var n;
    if (nodeMap.containsKey(treeNode)) {
        n = nodeMap.get(treeNode);
    } else {
        n = self.owningModel().createInstance("Node");
        n.label = treeNode.EClassifierName;
        n.type = nodeType;   
        nodeMap.put(treeNode, n);
        self.element.add(n);
    }
    return n;
}

operation ddg!Graph getNodeCopy(ddNode : ddg!Node, mergeMap : Map) : ddg!Node {
    var n;
    if (mergeMap.containsKey(ddNode)) {
        n = mergeMap.get(ddNode);
    } else {
        n = self.owningModel().createInstance("Node");
        n.label = ddNode.label;
        n.qvtAstNode = ddNode.qvtAstNode;
        switch (ddNode.type) {
            case ddg!NodeType#mapping : n.type = ddg!NodeType#mapping;
            case ddg!NodeType#input : n.type = ddg!NodeType#input;
            case ddg!NodeType#middle : n.type = ddg!NodeType#middle;
            case ddg!NodeType#output : n.type = ddg!NodeType#output;      
        }
        mergeMap.put(ddNode, n);
        self.element.add(n);
    }
    return n;
}


/**
 * Analysis of variable relations. Creates an edge between variables if they
 * realted by either a containment relation or a trace relations. A Containment
 * relation exists if both variables' types are in the same metamodel and if 
 * the type of the context variable has a containment association of the type
 * of the loop variable. 
 * 
 *
 * @context QVT!Variable  The variable being analyzed
 * @param graph The graph to populate
 * @param varMap   The map of AST variables to nodes
 */
operation QVT!Variable variableRelations(graph : ddg!Graph, vars : Set, varMap : Map) {

    var vaNode = graph.getNodeForQvtAstNode(self, varMap);
    for (vB in vars) {
        //vB.println("vB ");
        var vbNode = graph.getNodeForQvtAstNode(vB, varMap);
        var refProp = self.hasRelation(vB);
        if(refProp <> null) {
           var e = graph.owningModel().createInstance("Edge");
           e.source = vaNode;
           e.target = vbNode;
           e.referredProperty = refProp;
           if (refProp.isContainer()) {
               switch (vbNode.type) {
	               case(graph.owningModel().getEnumerationValue("NodeType", "middle")) :
	                   e.type = graph.owningModel().getEnumerationValue("EdgeType", "middleCont");
	               case(graph.owningModel().getEnumerationValue("NodeType", "input")) :
	                   e.type = graph.owningModel().getEnumerationValue("EdgeType", "inputCont");
	               case(graph.owningModel().getEnumerationValue("NodeType", "output")) :
	                   e.type = graph.owningModel().getEnumerationValue("EdgeType", "outputCont");
	           }
           } else {
               e.type = graph.owningModel().getEnumerationValue("EdgeType", "relation");
           }
           graph.element.add(e);
        }
    }
}

/**
 * Import metamodel containment trees into data dependence graph. Copies all
 * the nodes in the metamodel containment tree into the data dependence graph.
 *
 * @context ddg!Graph   The graph to where the tree is imported
 * @param treeNodes A set of the tree nodes to be copied into the graph
 * @param treeType  The type of tree being imported: l=left,m=middle,r=right
 */
operation ddg!Graph importContainmentTree(treeNodes : Collection, treeType : String, mergeMap : Map) {
    var nodeType;
    var edgeType;
    switch (treeType) {
        case("l") :
            nodeType = self.owningModel().getEnumerationValue("NodeType", "input");
            edgeType = self.owningModel().getEnumerationValue("EdgeType", "inputCont");
            //nodeType = ddg!NodeType#input;
            //edgeType = ddg!EdgeType#inputCont;
        case("m") :
            nodeType = self.owningModel().getEnumerationValue("NodeType", "middle");
            edgeType = self.owningModel().getEnumerationValue("EdgeType", "middleCont");
            //nodeType = ddg!NodeType#middle;
            //edgeType = ddg!EdgeType#middleCont;
        case("r") :
            nodeType = self.owningModel().getEnumerationValue("NodeType", "output");
            edgeType = self.owningModel().getEnumerationValue("EdgeType", "outputCont");
            //nodeType = ddg!NodeType#output;
            //edgeType = ddg!EdgeType#outputCont;
    }
    for (tn in treeNodes.excluding(treeNodes.selectOne(n | n.parent.isEmpty()))) {
        var n = self.getNodeForTreeNode(tn, mergeMap, nodeType);
        for (c in tn.children) {
            var e = self.owningModel().createInstance("Edge");
            e.type = edgeType;
            e.source = n;
            e.target = self.getNodeForTreeNode(c, mergeMap, nodeType);
            self.element.add(e);
        }
    }  
}


/****o* org.eclipse.qvtd.build.etl/helpers/DataDependenceGraphHelpers/hasRelation
  *  NAME
  *    hasRelation -- Identify relations between variables
  *  SYNOPSIS
  *    relation =  var1.hasRelation(var2);
  *  FUNCTION
  *    Analysies the predicates and assignments of the mapping that contains the 
  *   variables and returns the type of relation found. 
  *  CONTEXT
  *     QVT!Variable   
  *  PARAMETERS
  *    varB - variable to analyze relations against
  *  RESULT
  *    Any  - The EReference that relates the variables, null if not existant 
  *  SEE ALSO
  *
  */
operation QVT!Variable hasRelation(varB : QVT!Variable) : Any {
    
    // Fin predicates that only refer the two variables
    for (p in self.oppositePattern().area.rule.guardPattern.predicate
            .includingAll(self.oppositePattern().area.rule.local.collect(l | l.guardPattern.predicate).flatten())
            .select(p | p.conditionExpression.isSimpleAttributeNavigation())) {
        if (p.conditionExpression.findRreferencedVariables()
                .forAll(v | v.type.name == self.type.name or v.type.name == varB.type.name)) {
            // Expression in the form varB.prop = self
            if (p.conditionExpression.isArgumentVariable(varB) and 
                            p.conditionExpression.isSourceVariable(self)) {
                return p.conditionExpression.getReferredProperty();

            }
        }                
    }
    // Find assignments that only refer the two vars
    for (a in self.oppositePattern().area.rule.bottomPattern.assignment.select(a | a.isSimpleAttributeNavigation())) {
        if (a.findRreferencedVariables()
                .forAll(v | v.type.name == self.type.name or v.type.name == varB.type.name)) {
            // Only analyse expression in the form varB.prop := self
            if (a.slotExpression.referredVariable == self and 
                a.value.referredVariable == varB) {
                return a.targetProperty;
            }
        }          
    }
    return null;
}

/****o* org.eclipse.qvtd.build.etl/helpers/DataDependenceGraphHelpers/dfsDerivedVariables
 * NAME
 *  dfsDerivedVariables - Do a dfs vor derived variables. 
 * SYNOPSIS
 *   
 * FUNCTION
 *  Traverses the outgoing edges which has a type different from
 *  ddg!EdgeType#primaryInput. There is no need to query opposite relations as
 *  the outgoing relations are the only valid ones. 
 * CONTEXT
 *  ddg!Node   
 * PARAMETERS
 *  
 * RESULT
 *  A set of all the derived variables 
 * SEE ALSO
 *
 */
@cached
operation ddg!Edge dfsDerivedVariables() : Set {
    self.target.println("DFS ");
    var derived = new Set;
    
    // Target's Outgoing
    self.target.outgoing.select(e | e.type <> ddg!EdgeType#primaryInput).println("Outgoing ");
    for (e in self.target.outgoing.select(e | e.type <> ddg!EdgeType#primaryInput)) {
        derived.addAll(e.dfsDerivedVariables());
        derived.add(e.target);
    }
    
    // Target's Incoming 
    self.target.incoming.excluding(self).println("Incoming ");
    for (e in self.target.incoming.excluding(self)) {
        // Is the relation navigable in the opposite direction?
        // If the relation is 1..1 and non-containment, it is navigable (regardles of opposite multiplicity)
        
        // If the realtion is 0..1, the opposite must be 1..1 to be navigable
        
        
        derived.addAll(e.dfsDerivedVariables());
        derived.add(e.target);
    }
    
    /*
    for (e in self.incoming.select(e | e.type <> ddg!EdgeType#primaryInput)) {
        e.referredProperty.hasNavigableOpposite().println(e + " ");
    }
    // Search outgoing relations
    for (n in self.outgoing.collect(e | e.target).flatten()
            .select(t | t.type <> ddg!NodeType#mapping)
            .select(t | not t.incoming.exists(e | e.source.type == ddg!NodeType#mapping))
            .excluding(self)) {
        n.println("assoc ");
        derived.addAll(n.dfsDerivedVariables());
        derived.add(n);
    }
    */
    return derived;
}
