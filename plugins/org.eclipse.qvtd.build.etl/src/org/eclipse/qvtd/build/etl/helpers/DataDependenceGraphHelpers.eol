/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
import "QVTHelpers.eol";

/**
 * Data Dependencies Helpers. A set of EOL helpers to perform mapping data
 * dependence analysis for a QVT transformation.
 *
 * @cond ddg  A data dependence graph
 * @cond QVT  A QVTx AST model
 * @cond config The QVT transformation configuration
 */
 
/**
 * Get the correspoiding graph node for the AST node. If a graph node for the
 * AST node does not exist, it creates a new one. If it exists, it returns
 * the previously created one. For porformance, the nodeMap attribute works
 * as a cache for previously created nodes.
 * 
 * @context ddg!Graph The graph in which the node should exist
 * @param astNode The QVT AST node for whihc the corresponding graph node is wanted
 * @param nodeMap The map to keep a cache of AST - Node relations
 * 
 */
operation ddg!Graph getNodeForQvtAstNode(astNode : QVT!NamedElement, nodeMap : Map) : ddg!Node {
    var n;
    if (nodeMap.containsKey(astNode)) {
        n = nodeMap.get(astNode);
    } else {
	    n = self.owningModel().createInstance("Node");
	    n.label = getNodeName(astNode);
	    n.qvtAstNode = astNode;
	    n.type = self.getNodeType(astNode);   
	    nodeMap.put(astNode, n);
	    self.element.add(n);
    }
    return n;
}

operation getNodeName(m : QVT!Mapping) : String {
    return m.name;
}

operation getNodeName(v : QVT!Variable) : String {
    return v.type.name;
}

operation ddg!Graph getNodeType(m : QVT!Mapping) : Any {
    //return ddg!NodeType#mapping;
    return self.owningModel().getEnumerationValue("NodeType", "mapping");
}

operation ddg!Graph getNodeType(v : QVT!Variable) : Any {

    if (v.oppositePattern().area.name == "middle") {
        return self.owningModel().getEnumerationValue("NodeType", "middle");//ddg!NodeType#middle;
    } else if(isInputDomain(v.oppositePattern().area)) {
        return self.owningModel().getEnumerationValue("NodeType", "input");//ddg!NodeType#input;
    } else if(isOutputDomain(v.oppositePattern().area)) {
        return self.owningModel().getEnumerationValue("NodeType", "output");//ddg!NodeType#output;      
    } 
}


// self contains vB
operation QVT!Variable hasContainmentRelation(varB : QVT!Variable) : Boolean {
    // Containment is in the same domain
    if (self.oppositePattern().area == varB.oppositePattern().area) {
        // Fin predicates that only refer the two variables
        for (p in self.oppositePattern().area.rule.guardPattern.predicate.select(p | p.conditionExpression.isSimpleAttributeNavigation())) {
            // Are both vars
            if (p.conditionExpression.findRreferencedVariables()
                    .forAll(v | v.type.name == self.type.name or v.type.name == varB.type.name)) {
                // Find if the navigated property is a containment opposite.
                var prop = p.conditionExpression.getNavigatedProperty();
                //p.conditionExpression.toString().println("Predicate ");
                //self.println("var A ");
                //varB.println("var B ");
                //p.conditionExpression.argument.referredVariable.name.println("argument.referredVariable ");
                //p.conditionExpression.source.source.referredVariable.name.println("source.source.referredVariable ");
                if (p.conditionExpression.isArgumentVariable(self) and 
                    p.conditionExpression.isSourceVariable(varB) and prop.opposite.isDefined() and prop.opposite.isComposite()) {
                    //p.conditionExpression.toString().println(self.name + " with " + varB.name + " in ");   
                    return true;
                }
            }                
        }
        // Find assignments that only refer the two vars
        var assignments;
        if (isOutputDomain(self.oppositePattern().area)) {
            assignments = self.oppositePattern().area.bottomPattern.assignment.select(a | a.isSimpleAttributeNavigation());
        } else {
            assignments = self.oppositePattern().area.rule.bottomPattern.assignment.select(a | a.isSimpleAttributeNavigation());
        }
        for (a in assignments) {
            // Are both vars
            if (a.findRreferencedVariables()
                    .forAll(v | v.type.name == self.type.name or v.type.name == varB.type.name)) {
                // Find if the navigated property is a containment opposite.
                var prop = a.targetProperty;
                //p.conditionExpression.toString().println("Predicate ");
                //self.println("var A ");
                //varB.println("var B ");
                //p.conditionExpression.argument.referredVariable.name.println("argument.referredVariable ");
                //p.conditionExpression.source.source.referredVariable.name.println("source.source.referredVariable ");
                if (a.slotExpression.referredVariable == varB and 
                    a.value.referredVariable == self and prop.opposite.isDefined() and prop.opposite.isComposite()) {
                    //a.toString().println(self.name + " with " + varB.name + " in ");   
                    return true;
                }
            }                
        }
    }
    return false;
}

// self has a reference to vB (non-containment, can be cross-domain)
operation QVT!Variable hasRelation(varB : QVT!Variable) : Boolean {
    // Fin predicates that only refer the two variables
    for (p in self.oppositePattern().area.rule.guardPattern.predicate.select(p | p.conditionExpression.isSimpleAttributeNavigation())) {
        // Are both vars
        if (p.conditionExpression.findRreferencedVariables()
                .forAll(v | v.type.name == self.type.name or v.type.name == varB.type.name)) {
            // Find if the navigated property is a containment opposite.
            //p.conditionExpression.toString().println("Predicate ");
            //self.println("var A ");
            //varB.println("var B ");
            //p.conditionExpression.argument.referredVariable.name.println("argument.referredVariable ");
            //p.conditionExpression.source.source.referredVariable.name.println("source.source.referredVariable ");
            var prop = p.conditionExpression.getNavigatedProperty();
            if (p.conditionExpression.isArgumentVariable(varB) and 
                p.conditionExpression.isSourceVariable(self) and not prop.isComposite()) {
                //p.conditionExpression.toString().println(self.name + " with " + varB.name + "in ");   
                return true;
            }
        }                
    }
    // Find assignments that only refer the two vars
    for (a in self.oppositePattern().area.rule.bottomPattern.assignment.select(a | a.isSimpleAttributeNavigation())) {
        // Are both vars
        if (a.findRreferencedVariables()
                .forAll(v | v.type.name == self.type.name or v.type.name == varB.type.name)) {
            // Find if the navigated property is a containment opposite.
            var prop = a.targetProperty;
            //a.toString().println("Assignment ");
            //self.println("var A ");
            //varB.println("var B ");
            //p.conditionExpression.argument.referredVariable.name.println("argument.referredVariable ");
            //p.conditionExpression.source.source.referredVariable.name.println("source.source.referredVariable ");
            if (a.slotExpression.referredVariable == self and 
                a.value.referredVariable == varB and not prop.isComposite()) {
                //a.toString().println(self.name + " with " + varB.name + " in ");   
                return true;
            }
        }                
    }
    return false;
}

operation ddg!Graph getNodeForTreeNode(treeNode : tree!Node, nodeMap : Map, nodeType) : ddg!Node {
    var n;
    if (nodeMap.containsKey(treeNode)) {
        n = nodeMap.get(treeNode);
    } else {
        n = self.owningModel().createInstance("Node");
        n.label = treeNode.EClassifierName;
        n.type = nodeType;   
        nodeMap.put(treeNode, n);
        self.element.add(n);
    }
    return n;
}

operation ddg!Graph getNodeCopy(ddNode : ddg!Node, mergeMap : Map) : ddg!Node {
    var n;
    if (mergeMap.containsKey(ddNode)) {
        n = mergeMap.get(ddNode);
    } else {
        n = self.owningModel().createInstance("Node");
        n.label = ddNode.label;
        n.qvtAstNode = ddNode.qvtAstNode;
        switch (ddNode.type) {
            case ddg!NodeType#mapping : n.type = ddg!NodeType#mapping;
            case ddg!NodeType#input : n.type = ddg!NodeType#input;
            case ddg!NodeType#middle : n.type = ddg!NodeType#middle;
            case ddg!NodeType#output : n.type = ddg!NodeType#output;      
        }
        mergeMap.put(ddNode, n);
        self.element.add(n);
    }
    return n;
}


/**
 * Analysis of variable relations. Creates an edge between variables if they
 * realted by either a containment relation or a trace relations. A Containment
 * relation exists if both variables' types are in the same metamodel and if 
 * the type of the context variable has a containment association of the type
 * of the loop variable. 
 * 
 *
 * @context QVT!Variable  The variable being analyzed
 * @param graph The graph to populate
 * @param varMap   The map of AST variables to nodes
 */
operation QVT!Variable variableRelations(graph : ddg!Graph, vars : Set, varMap : Map) {

    var vaNode = graph.getNodeForQvtAstNode(self, varMap);
    for (vB in vars) {
        //vB.println("vB ");
        var vbNode = graph.getNodeForQvtAstNode(vB, varMap);
        if (self.hasContainmentRelation(vB)) {
            var ce = graph.owningModel().createInstance("Edge");
            ce.source = vaNode;
            ce.target = vbNode;
            switch (vbNode.type) {
                case(graph.owningModel().getEnumerationValue("NodeType", "middle")) :
                    ce.type = graph.owningModel().getEnumerationValue("EdgeType", "middleCont");
                case(graph.owningModel().getEnumerationValue("NodeType", "input")) :
                    ce.type = graph.owningModel().getEnumerationValue("EdgeType", "inputCont");
                case(graph.owningModel().getEnumerationValue("NodeType", "output")) :
                    ce.type = graph.owningModel().getEnumerationValue("EdgeType", "outputCont");
            }
            graph.element.add(ce);
        } else if (self.hasRelation(vB)) {
            var re = graph.owningModel().createInstance("Edge");
            re.source = vaNode;
            re.target = vbNode;
            re.type = graph.owningModel().getEnumerationValue("EdgeType", "relation");
            //re.type = ddg!EdgeType#relation;
            graph.element.add(re);
        }
    }
}

/**
 * Import metamodel containment trees into data dependence graph. Copies all
 * the nodes in the metamodel containment tree into the data dependence graph.
 *
 * @context ddg!Graph   The graph to where the tree is imported
 * @param treeNodes A set of the tree nodes to be copied into the graph
 * @param treeType  The type of tree being imported: l=left,m=middle,r=right
 */
operation ddg!Graph importContainmentTree(treeNodes : Collection, treeType : String, mergeMap : Map) {
    var nodeType;
    var edgeType;
    switch (treeType) {
        case("l") :
            nodeType = self.owningModel().getEnumerationValue("NodeType", "input");
            edgeType = self.owningModel().getEnumerationValue("EdgeType", "inputCont");
            //nodeType = ddg!NodeType#input;
            //edgeType = ddg!EdgeType#inputCont;
        case("m") :
            nodeType = self.owningModel().getEnumerationValue("NodeType", "middle");
            edgeType = self.owningModel().getEnumerationValue("EdgeType", "middleCont");
            //nodeType = ddg!NodeType#middle;
            //edgeType = ddg!EdgeType#middleCont;
        case("r") :
            nodeType = self.owningModel().getEnumerationValue("NodeType", "output");
            edgeType = self.owningModel().getEnumerationValue("EdgeType", "outputCont");
            //nodeType = ddg!NodeType#output;
            //edgeType = ddg!EdgeType#outputCont;
    }
    for (tn in treeNodes.excluding(treeNodes.selectOne(n | n.parent.isEmpty()))) {
        var n = self.getNodeForTreeNode(tn, mergeMap, nodeType);
        for (c in tn.children) {
            var e = self.owningModel().createInstance("Edge");
            e.type = edgeType;
            e.source = n;
            e.target = self.getNodeForTreeNode(c, mergeMap, nodeType);
            self.element.add(e);
        }
    }  
}
