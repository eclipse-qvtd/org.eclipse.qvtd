pre {
  "QVTc to QVTu".println();
  // The user must define a direction and a mode
  var inputDomain : new String = "upperGraph";
  //var outputDomain : new String = "rdbms";
  var isUpdate = new Boolean = false;
  var isCreate = new Boolean = true;
  
  if (isUpdate == isCreate) {
    // ERROR
  }
}

rule CoreModels 
    transform cm : QVTc!CoreModel
    to um : QVTu!CoreModel {
    
        um.name = cm.name;
        um.nestedPackage ::= cm.nestedPackage;
    }

rule Transformation
    transform ct : QVTc!Transformation
    to ut : QVTu!Transformation {
        
        ut.name = ct.name;
        ut.`extends` ::= ct.`extends`;
        ut.modelParameter ::= ct.modelParameter;
        ut.`rule` ::= ct.`rule`; 
    }
    
rule TypedModel
    transform ctp : QVTc!TypedModel    
    to utp : QVTu!TypedModel {
    
        utp.name = ctp.name;
        utp.dependsOn ::= ctp.dependsOn;
        utp.usedPackage =  ctp.usedPackage;
    }

rule Mapping
    transform cm : QVTc!Mapping
    to um : QVTu!Mapping {
    	
    	um.name = cm.name;
        um.overrides ::= cm.overrides;
        um.domain ::= cm.domain;    
        um.local ::= cm.local;
    }


rule InputDomain 
    transform cd : QVTc!CoreDomain
    to ud : QVTu!CoreDomain {
    
	    guard : cd.name == inputDomain
	    
	    ud.isCheckable = false;
	    ud.isEnforceable = false;
	    ud.name = cd.name;
	    ud.typedModel ::= cd.TypedModel;
	    ud.guardPattern ::= ud.guardPattern;
	    ud.bottomPattern ::= cd.bottomPattern;
    }
    
rule OutputDomain 
    transform cd : QVTc!CoreDomain
    to ud : QVTu!CoreDomain {
    
        guard : cd.name <> inputDomain
        
	    // If the write mode is create, remove all check keywords from output domains. If the write mode is update, keep them
	    if (isCreate) {
	        ud.isCheckable = false;
	    } else {
	        // Is update?
	        ud.isCheckable = cd.isCheckable;
	    }
	    ud.isEnforceable = cd.isEnforceable;
	    ud.name = cd.name;
        ud.typedModel ::= cd.TypedModel;
        ud.guardPattern ::= ud.guardPattern;
	    ud.bottomPattern ::= cd.bottomPattern;
    }

rule GuardPattern
	transform cgp : QVTc!GuardPattern
	to ugp : QVTu!GuardPattern {
		
		ugp.variable ::= cgp.variable;
		ugp.predicate ::= cgp.predicate;
	}

rule BottomPattern 
	transform cbp : QVTc!BottomPattern
	to ubp : QVTu!BottomPattern {
		
		ubp.variable ::= cbp.variable;
		ubp.assignment ::= cbp.assignment;
		ubp.enforcementOperation ::= cbp.enforcementOperation;
		ubp.realizedVariable ::= cbp.realizedVariable;
		ubp.predicate ::= cbp.predicate;
	}

rule Variable
	transform cv : QVTc!Variable
	to uv : QVTu!Variable {
	
		uv.name = cv.name;
		uv.implicit = cv.implicit;
		//uv.type = cv.type;		
	}


/* Remove all realize keywords from variables that are contained in mappings
 * that reference the input domain */
rule InputRealizedVariable
	transform crv : QVTc!RealizedVariable
	to urv : QVTu!RealizedVariable {
		
		// Input domain, realized variables dont have an opposite...
		// so hard to get the pattern and then the domain...
		//guard crv.
		
		
	}

rule Type
	transform ct : QVTc!Type
	to ut : QVTu!Type {
	
		ut.name = ct.name;
		ut.superClass ::= ct.superClass; // Possible loop?
		ut.instanceClassName = ct.instanceClassName;
		// Do we need to transform the package?
		// ut.package = ct.package;
	}

 
	