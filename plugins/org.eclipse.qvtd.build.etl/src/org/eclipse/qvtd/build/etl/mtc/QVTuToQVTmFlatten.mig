import "Helpers.eol";
import "OclLibHelper.eol";

pre {
    var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
    var x = new Native("org.eclipse.qvtd.build.etl.PivotUtil");
}

// Refinned mappings
migrate Mapping
    when : original.refinement.size() > 0 {
        
        original.println("Mapping ");
        for (refined in original.refinement) {
            // Nested mappings with no domains. Since many mappings can refine the same mapping
            // get the equivalent and copy (create) them
            migrated.local.addAll(emfTool.getECoreUtil().copyAll(refined.collect(r | r.local.select(nm | nm.domain.size() == 0)).flatten().equivalent()));
            // Add a copy (create) domains that don't need to be merged (i.e. with different typeModels than the refining mapping)
            migrated.domain.addAll(emfTool.getECoreUtil().copyAll(refined.collect(r | r.domain).flatten().select(d | original.domain.collect(d2 | d2.name).flatten().excludes(d.name)).equivalent()));
        }
        // Remove the refinements
        migrated.refinement = Set{};
    }

@cached
operation QVT!CorePattern getRefinedPatterns(orig : QVT!CorePattern, pattern : String) : Collection {
    var refinedAreas;
    if (orig.area.isTypeOf(QVT!Mapping)) {
        refinedAreas = orig.area.refinement;
    } else if (orig.area.isTypeOf(QVT!CoreDomain)) {
        refinedAreas = orig.area.rule.refinement.collect(m | m.domain).flatten().select(d | d.typedModel == orig.area.typedModel);
    }
    if (pattern = "guard") {
        return refinedAreas.collect(r | r.guardPattern);
    } else if (pattern = "bottom") {
        return refinedAreas.collect(r | r.bottomPattern);
    }
}

@cached
operation QVT!Predicate findRreferencedVariables() : Collection {
    return self.conditionExpression.findRreferencedVariables();
}

@cached
operation QVT!Variable findPatternReferences(pattern : QVT!CorePattern) {
    if (pattern.isTypeOf(QVT!GuardPattern)) {
        return pattern.variable.selectOne(lv | lv.name == self.name);
    } else if (pattern.isTypeOf(QVT!BottomPattern)) {
        return pattern.variable.includingAll(pattern.realizedVariable).selectOne(lv | lv.name == self.name);
    }
}


operation QVT!CorePattern fixPredicateVarReferences() {
    for (predicate in self.predicate) {
        //predicate.println("Predicate ");
        var refVars =  predicate.findRreferencedVariables();
        //refVars.println("refVars ");
        // Find variables and fix references
        for (v in refVars) {
            //v.println("Fixing ");
            // MiddleGuard Pattern depends on domain guard patterns
            var targetVar = v.findPatternReferences(self);
            if (targetVar == null) {
	            var searchPatterns;
	            if (self.area.isTypeOf(QVTu!CoreDomain)) {
	                // If guard pattern -> guard patterns of domains with depending typed models 
	                if (self.isTypeOf(QVTu!GuardPattern)) {
	                    searchPatterns = self.area.rule.domain.select(d | d.typedModel.dependsOn.includes(self.area.typedModel)).collect(d | d.guardPattern).flatten();
	                    for (p in searchPatterns) {
	                        targetVar = v.findPatternReferences(p);
	                        if (targetVar <> null) {
	                           break;
	                        }
	                    }
	                } else if (self.isTypeOf(QVTu!BottomPattern)) {
	                    // 1. Guard Pattern of the Domain
	                    searchPatterns = self.area.rule.domain.collect(d | d.guardPattern).flatten();
                        for (p in searchPatterns) {
                            targetVar = v.findPatternReferences(p);
                            if (targetVar <> null) {
                               break;
                            }
                        }
                        // 2. Bottom Pattern of domains with depending typed models
                        if (targetVar == null) {
                            searchPatterns = self.area.rule.domain.select(d | d.typedModel.dependsOn.includes(self.area.typedModel)).collect(d | d.bottomPattern).flatten();
	                        for (p in searchPatterns) {
	                            targetVar = v.findPatternReferences(p);
	                            if (targetVar <> null) {
	                               break;
	                            }
	                        }
                        }
	                }
	            } else if (self.area.isTypeOf(QVTu!Mapping)) {
	                if (self.isTypeOf(QVTu!GuardPattern)) {
                        // 1. Mapping's domain guard patterns
                        searchPatterns = self.area.domain.collect(d | d.guardPattern).flatten();
                        for (p in searchPatterns) {
                            targetVar = v.findPatternReferences(p);
                            if (targetVar <> null) {
                               break;
                            }
                        }
                    } else if (self.isTypeOf(QVTu!BottomPattern)) {
                        // 1. Guard Pattern of the Mapping
                        searchPatterns = self.area.guardPattern;
                        for (p in searchPatterns) {
                            targetVar = v.findPatternReferences(p);
                            if (targetVar <> null) {
                               break;
                            }
                        }
                        // 2. Mapping's domain bottom pattern
                        // TODO this should me somehow recursive or something
                        if (targetVar == null) {
                            searchPatterns = self.area.domain.collect(d | d.bottomPattern).flatten();
                            for (p in searchPatterns) {
                                targetVar = v.findPatternReferences(p);
                                if (targetVar <> null) {
                                   break;
                                }
                            }
                            if (targetVar == null) {
                                // 3. Mapping's domain guard patterns
                                searchPatterns = self.area.domain.collect(d | d.guardPattern).flatten();
		                        for (p in searchPatterns) {
		                            targetVar = v.findPatternReferences(p);
		                            if (targetVar <> null) {
		                               break;
		                            }
		                        }
                            }
                        }
                    }       
	            }
	        }
	        if (targetVar == null) {
                if (self.area.isTypeOf(QVTu!Mapping)) {
                    throw "Error! not able to find a local reference for variable " + v + " in predicate " + predicate + "in GuardPattern of Mapping " + self.area;  
                } else if(self.area.isTypeOf(QVTu!CoreDomain)) {
                    throw "Error! not able to find a local reference for var " + v + " in predicate " + predicate + "in GuardPattern of Domain " + self.area;  
                }  
            }
            //targetVar.println("local ");
            predicate.conditionExpression.fixVarReferences(targetVar);
        }
    }
}

operation QVT!GuardPattern getDependingPatterns(mapping : QVT!Mapping) : Collection {
    return mapping.domain.collect(d | d.guardPattern).flatten();
}

operation QVT!GuardPattern getDependingPatterns(domain : QVT!CoreDomain) : Collection  {
    // Domains depend in other domains when one of the two associated model types is declared to depend on the other associated model type
    if (domain.typedModel.dependsOn.size() > 0) {
        return domain.rule.domain.select(d | domain.typedModel.dependsOn.exists(d)).collect(d | d.guardPattern).flatten();
    } else {
        return new Set();
    }
}

operation QVT!BottomPattern getDependingPatterns(domain : QVT!CoreDomain) : Collection  {
    // Domains depend in other domains when one of the two associated model types is declared to depend on the other associated model type
    if (domain.typedModel.dependsOn.size() > 0) {
        return domain.rule.domain.select(d | domain.typedModel.dependsOn.exists(d)).collect(d | d.bottomPattern).flatten();
    } else {
        return new Set();
    }
}

migrate GuardPattern
    when {
	         if (original.area.isTypeOf(QVTu!CoreDomain)) {
	            return original.area.rule.refinement.size() > 0; 
	         } else if (original.area.isTypeOf(QVTu!Mapping)) {
	            return original.area.refinement.size() > 0;
	         } 
	     } {
        "GuardPattern ".println(original.area + " ");
        // Variables. Search for variables in the refined mapping. Copy all variables that have
        // different names as the local variables. If there is any with the same name, re-type it
        var localVarNames = migrated.variable.collect(v | v.name); 
        var refinedPatterns = migrated.getRefinedPatterns(original, "guard");
        for (localVar in migrated.variable) {
            localVar.retypeVar(refinedPatterns);
        }
        // Straight copy non-refined variables
        migrated.variable.addAll(emfTool.getECoreUtil().copyAll(refinedPatterns.collect(p | p.variable).flatten().select(v | not localVarNames.includes(v.name)).equivalent()));
        // Copy predicates
        migrated.predicate.addAll(emfTool.getECoreUtil().copyAll(refinedPatterns.collect(p | p.predicate).flatten().equivalent()));
        // Find all variable references.
        migrated.fixPredicateVarReferences();
   }
    

migrate BottomPattern
    when {
            if (original.area.isTypeOf(QVTu!CoreDomain)) {
               return original.area.rule.refinement.size() > 0; 
            } else if (original.area.isTypeOf(QVTu!Mapping)) {
               return original.area.refinement.size() > 0;
            } 
         } {
         
        "BottomPattern ".println(original.area + " ");
        // Variables. Search for variables in the refined mapping. Copy all variables that have
        // different names as the local variables. If there is any with the same name, re-type it
        var localVarNames = migrated.variable.collect(v | v.name);    
        var refinedPatterns = migrated.getRefinedPatterns(original, "bottom");
        for (localVar in migrated.variable) {
            localVar.retypeVar(refinedPatterns);
        }
        // Straight copy non-refined variables
        migrated.variable.addAll(emfTool.getECoreUtil().copyAll(refinedPatterns.collect(p | p.variable).flatten().select(v | not localVarNames.includes(v.name)).equivalent()));
        // The same for realized variables
        var localRealizedVarNames = migrated.realizedVariable.collect(v | v.name);
        for (localVar in migrated.realizedVariable) {
            localVar.retypeRealizedVar(refinedPatterns);
        }
        // Straight copy non-refined realized variables
        migrated.realizedVariable.addAll(emfTool.getECoreUtil().copyAll(refinedPatterns.collect(p | p.realizedVariable).flatten().select(v | not localRealizedVarNames.includes(v.name)).equivalent()));
        
        
        // Copy predicates
        migrated.predicate.addAll(emfTool.getECoreUtil().copyAll(refinedPatterns.collect(p | p.predicate).flatten().equivalent()));
        
        // Copy assignments
        migrated.assignment.addAll(emfTool.getECoreUtil().copyAll(refinedPatterns.collect(p | p.assignment).flatten().equivalent()));
        
        // Copy operations
        migrated.enforcementOperation.addAll(emfTool.getECoreUtil().copyAll(refinedPatterns.collect(p | p.enforcementOperation).flatten().equivalent()));
        
        // Find all variable references.
        migrated.fixPredicateVarReferences();
        
        
        // Fix variable references in assignments
        //migrated.assignment.addAll(bps.collect(bp | bp.assignment).flatten());
        
        // Fix references in operations?
        
}
