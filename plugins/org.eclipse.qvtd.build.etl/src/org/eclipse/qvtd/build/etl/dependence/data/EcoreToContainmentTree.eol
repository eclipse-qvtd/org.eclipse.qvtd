/*******************************************************************************
 * Copyright (c) 2013 The University of York, Willink Transformations and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/

/**
 * We are only interested in containemnet relations, so we only need to search
 * EPackages and EClasses, all other nodes in the root can be safely ignored. 
 * Note: Ed Merks suggests there should only be one EPackage per metamodel, but
 * since this is not a requirement, we need to be safe
 */

var visited : Map;

for (p in mm!EPackage.all().first()) {
    p.iterativeDFS();
}
"Done".println();

/* ===========================================================================*/

// Iterative Depth First Search of containment relations
// Serch till no more elements are visited during three increments
operation mm!EPackage iterativeDFS() {

	var iterate = true;
	var change = false;
	var maxDepth : Integer;
	var noChangeCount : Integer = 0;
	
	var parentNode = new tree!Node;
    //parentNode.data = self;
    parentNode.type = self.name;
	maxDepth = 1;
    
    while (iterate) {
        //maxDepth.println("IterativeDFS ");
        change = false;
        for (c in self.eClassifiers.select(c | c.isKindOf(mm!EClassifier))) {
            change = c.dfs(1, maxDepth, parentNode) or change;
        }
        if (not change) {
	       noChangeCount = noChangeCount + 1;
	       if (noChangeCount > 3) {
	           iterate = false;
	       }
	    }
	    maxDepth = maxDepth + 1;
	    if(maxDepth > 10) {
	       iterate = false; // Safe ending
	    }
	       
    }
}

// Returns true if added
operation mm!EClassifier dfs(depth, maxDepth, parentNode) : Boolean {
    
    
    var change = false;
    //"Max depth reached, do nothing".println(tabs);
    if (depth <= maxDepth) {
        // If self is abstract, consider all subclasses at same depth (flattening)
	    if (self.isTypeOf(mm!EClass) and self.abstract) {
	        //"Abstract, do inheritance".println(tabs);
	        for (sc in mm!EClass.all().select(c | c.eSuperTypes.includes(self))) {
	            sc.dfs(depth, maxDepth, parentNode);
	        }
	    } else {
	        // Add Node or get node
	        var n;
	        if (visited.containsKey(self)) {
	            n = visited.get(self);
	        } else { 
	            n = new tree!Node;
	            //n.data = self;
	            //n.data.println();
	            n.type = self.name;
	            visited.put(self, n);
	        }
	        if (depth == maxDepth) {
	            n.parent = parentNode;
	            change = true;
	        }
	        if (self.isTypeOf(mm!EClass)) {
	           // Navigate Containment
	            for (sf in self.eStructuralFeatures.select(sf : mm!EReference | sf.containment)) {
	                change = sf.eReferenceType.dfs(depth+1, maxDepth, n) or change;
	            }
	        }
	    }
    }
    return change;
}
