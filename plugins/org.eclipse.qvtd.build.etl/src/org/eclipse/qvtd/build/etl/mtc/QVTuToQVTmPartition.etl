import "Helpers.eol";
import "OclLibHelper.eol";

pre {
    var EmfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
}

rule CoreModel
    transform mIn:QVTmF!CoreModel
    to mOut:QVTmP!CoreModel {
        mOut.name = mIn.name;
        mOut.nestedPackage ::= mIn.nestedPackage;
    }

rule Transformation
    transform tIn:QVTmF!Transformation
    to tOut:QVTmP!Transformation {
        
        tOut.name = tIn.name;
        tOut.`rule` ::= tIn.`rule`;
        tOut.modelParameter ::= tIn.modelParameter;
    }

rule TypedModels
    transform itm:QVTmF!TypedModel
    to otm:QVTmF!TypedModel {
        
        otm.name = itm.name;
        otm.usedPackage = itm.usedPackage.clone();
        otm.dependsOn ::= itm.dependsOn;
    }

    
rule PartitionLM
    transform mapping:QVTmF!Mapping
    to mappingLM:QVTmP!Mapping, mappingMR:QVTmP!Mapping {
        
        // Only top mappings (named)
        guard : mapping.name <> null
        
        mapping.println();
        
        /* Create LM mapping */
        mappingLM.name = mapping.name + "_LM";
        
        // Copy Input Domains
        for (d:QVT!Area in mapping.domain) {
            if (isInputDomain(d)) {
                mappingLM.domain.add(d.equivalent());
            }
        }
        // MappingPatterns
        mappingLM.guardPattern = mapping.guardPattern.equivalents().first();
        mappingLM.bottomPattern = mapping.bottomPattern.equivalents().first();
        
        // Assignemnt variable resolution
        for (a in mappingLM.bottomPattern.assignment) {
            a.resolveVariables();
        }
        
        // No nested mappings are copied, only the nested mapping's bottom pattern predicates
        // that refer to input domain variables (moved to the bottom pattern)
        for (nm in mapping.local) {
            for (bp in nm.bottomPattern) {
                if (bp.assignment.size() > 0) {
                    for (a in bp.offendingAssignments(false)) {
	                    var ac = EmfTool.getECoreUtil().copy(a);
                        mappingLM.bottomPattern.assignment.add(ac);
	                }
	            }
            }
        }
        
        
        /* Create MR mapping */
        mappingMR.name = mapping.name + "_MR";
        // DomainPatterns
        mappingMR.guardPattern = mapping.guardPattern.equivalents().last();
        mappingMR.bottomPattern = mapping.bottomPattern.equivalents().last();
        
        // Copy Output Domains
        for (d:QVT!Area in mapping.domain) {
            if (isOutputDomain(d)) {
                mappingMR.domain.add(d.equivalent());
            }
        }
        // Mested mappings are copied eliminating the nested mapping's bottom pattern predicates
        // that refer to input domain variables
        for (nm in mapping.local) {
            var nmc = EmfTool.getECoreUtil().copy(nm);
            mappingMR.local.add(nmc);
        }
        for (nm in mappingMR.local) {                      
            for (bp in nm.bottomPattern) {
                if (bp.assignment.size() > 0) {
                    bp.assignment.removeAll(bp.offendingAssignments(false));
                }
            }
        }
    }

rule Domains
    transform id : QVTmF!CoreDomain
    to od : QVTmP!CoreDomain {
         
         od.name = id.name;
         od.isCheckable = id.isCheckable;
         od.isEnforceable = od.isEnforceable;
         od.typedModel ::= id.typedModel;
         od.guardPattern ::= id.guardPattern;
         od.bottomPattern ::= id.bottomPattern;
    }

@lazy
rule GuardPatterns
    transform gp : QVTmF!GuardPattern
    to lmgp : QVTmP!GuardPattern, mrgp : QVTmP!GuardPattern {
        
        // .predicate *
        if (gp.predicate.size() > 0) {
            // LM: Remove predicates and assignments that reference variables in the output domain
            for (p in gp.predicate.excludingAll(gp.offendingPredicates(true))) {
                lmgp.predicate.add(p.equivalent());
            }
            // MR: Remove predicates and assignments that reference variables in the input domain
            for (p in gp.predicate.excludingAll(gp.offendingPredicates(false))) {
                mrgp.predicate.add(p.equivalent());
            }
        }
        
        // .variable *
        lmgp.variable = gp.variable.clone();
        mrgp.variable = gp.variable.clone();
        
        //.bindsTo *
        lmgp.bindsTo = gp.bindsTo.clone();
        mrgp.bindsTo = gp.bindsTo.clone();
        
        //.ownedComment *
        lmgp.ownedComment = gp.ownedComment.clone();
        mrgp.ownedComment = gp.ownedComment.clone();
        
    }

@lazy
rule BottomPatterns
    transform bp : QVTmF!BottomPattern
    to lmbp : QVTmP!BottomPattern, mrbp : QVTmP!BottomPattern {
    
    //.bindsTo *
    lmbp.bindsTo = bp.bindsTo.clone();
    mrbp.bindsTo = bp.bindsTo.clone();
    
    //.ownedComment *
    lmbp.ownedComment = bp.ownedComment.clone();
    mrbp.ownedComment = bp.ownedComment.clone();
    
    // .variable * might have to 'transform' them so the OCL expressions are correctly updated....
    // or find a way to replace all the OCL references...
    lmbp.variable = bp.variable.clone();
    mrbp.variable = bp.variable.clone();
    
    //.realizedVariable
    lmbp.realizedVariable = bp.realizedVariable.clone();
    mrbp.variable.addAll(bp.realizedVariable.equivalent());
    
    // Remove predicates and assignments that reference variables in the other domain
    // .predicate *
    if (bp.predicate.size() > 0) {
        // LM: Remove predicates and assignments that reference variables in the output domain
        for (p in bp.predicate.excludingAll(bp.offendingPredicates(true))) {
            lmbp.predicate.add(p.equivalent());
        }
        // MR: Remove predicates and assignments that reference variables in the input domain
        for (p in bp.predicate.excludingAll(bp.offendingPredicates(false))) {
            mrbp.predicate.add(p.equivalent());
        }
    }
    
    // .assignemnt
    if (bp.assignment.size() > 0) {
        // LM: Remove assignments and assignments that reference variables in the output domain
        for (a in bp.assignment.excludingAll(bp.offendingAssignments(true))) {
            lmbp.assignment.add(a.equivalent());
        }
        // MR: Remove assignments and assignments that reference variables in the input domain
        for (a in bp.assignment.excludingAll(bp.offendingAssignments(false))) {
            mrbp.assignment.add(a.equivalent());
        }
        
    }

}


@lazy
rule Predicates
    transform fp : QVTmF!Predicate
    to pp : QVTmP!Predicate {
        
        pp.conditionExpression = EmfTool.getECoreUtil().copy(fp.conditionExpression);
    }
    
@lazy
rule VariableAssignments
    transform fa : QVTmF!VariableAssignment
    to pa : QVTmP!VariableAssignment {
        
        pa.isDefault = fa.isDefault;
        pa.value = EmfTool.getECoreUtil().copy(fa.value);
        pa.targetVariable = EmfTool.getECoreUtil().copy(fa.targetVariable);
    }    

@lazy
rule PropertyAssignments
    transform fa : QVTmF!PropertyAssignment
    to pa : QVTmP!PropertyAssignment {
        
        pa.isDefault = fa.isDefault;
        pa.targetProperty = EmfTool.getECoreUtil().copy(fa.targetProperty);
        pa.slotExpression = EmfTool.getECoreUtil().copy(fa.slotExpression);
        pa.value = EmfTool.getECoreUtil().copy(fa.value);
    }  

/* Fix variable references in property assignments */
operation QVTmP!PropertyAssignment resolveVariables() {
    
    
    // Refered Variables in the slot expression and value most be resolved so they are
    // correctly resolved. We can limit lookup to the expression's context
    // Domain bottom patterns context includes guard pattern
    // Middle bottom patterns context includes domain bottom and guard pattern.
    // In the reduced context a name search is suficient (does the EMF copy leave a trace?)
    /* 
    if (self.slotExpression.isTypeOf(QVT!VariableExp)) {
        var rv = self.slotExpression.referredVariable;
        self.slotExpression.println("Slot expression ")
        rv.println();
        self.bottomPattern.variable.includingAll(self.bottomPattern.realizedVariable).println();
        var newVar = self.bottomPattern.variable.includingAll(self.bottomPattern.realizedVariable).select(v | v.name = rv.name).first();
        if (newVar == null) {
            rv.errln("No new variable found for: ");
        } else {
            self.slotExpression.referredVariable = newVar;
        }
        
    } else {
        self.slotExpression.type().errln("No implementation for finding target vars for this type: ");
    }
    */
    self.value.println("Value ");
    if (self.value.isTypeOf(QVT!VariableExp)) {
        var rv = self.value.referredVariable;
        var newVar = self.bottomPattern.variable.selectOne(v | v.name = rv.name);
        newVar.println("newVar ");
        if (newVar == null) {
            newVar = self.bottomPattern.realizedVariable.selectOne(v | v.name = rv.name);
            newVar.println("newVar ");
            if (newVar == null) {
	            newVar = self.bottomPattern.area.guardPattern.variable.selectOne(v | v.name = rv.name);
	            newVar.println("newVar ");
	            // Search in the domains
	            self.bottomPattern.area.isTypeOf(QVT!Mapping).println();
	            self.bottomPattern.area.println();
	            if (newVar == null and self.bottomPattern.area.isTypeOf(QVT!Mapping)) {
                    self.bottomPattern.area.domain.println();
	                for (d in self.bottomPattern.area.domain) {
	                    newVar = d.bottomPattern.variable.selectOne(v | v.name = rv.name);
	                    newVar.println("newVar ");
	                    if (newVar == null) {
	                        newVar = self.bottomPattern.realizedVariable.selectOne(v | v.name = rv.name);
	                        newVar.println("newVar ");
	                        if (newVar == null) {
	                          d.guardPattern.variable.println("Domain guard pat vars ");  
	                          newVar = d.guardPattern.variable.selectOne(v | v.name = rv.name);
	                          newVar.println("newVar ");
	                          if (newVar <> null) {
	                              break;
	                          }
	                        }
	                    } else {
	                      break;
	                    }
	                }
	            }
	        }
        }
        newVar.println();
        if (newVar == null) {
            rv.errln("No new variable found for: ");
        } else {
            self.value.referredVariable = newVar;
        }
        
    } else {
        self.value.type().errln("No implementation for finding target vars for this type: ");
    }
        
    
}


// In the MR transform realize variables to variables in the Middle Patterns
@lazy
rule MiddleRealizedvariables
    transform rv : QVTmF!RealizedVariable
    to v : QVTmP!Variable {
            
        v.implicit = rv.implicit;
        v.initExpression = rv.initExpression;
        v.isRequired = rv.isRequired;
        v.name = name;
        v.type = rv.type;
    }    

/*  Returns a set of predicates that don't match the specified (output) domain.
    params:
    output : Boolean    Indicates whether the output (true) or input (false)
                        domain is matched.    
*/  
operation QVT!CorePattern offendingPredicates(output : Boolean) :  Set {
    
    var offending : Set;
    for(p in self.predicate) {
        // The output domain vars may be either in the argument or in the source
        if (p.conditionExpression.source.isDefined()) {
            if (output) {
	            if (isOutputDomain(p.conditionExpression.source.getArea())) {
	                offending.add(p);
	                break;
	            }
            } else {
                if (isInputDomain(p.conditionExpression.source.getArea())) {
                    offending.add(p);
                    break;
                }
            }
        }
        if (p.conditionExpression.argument.isDefined()) {
            for (a in p.conditionExpression.argument) {
                if (output) {
	                if (isOutputDomain(a.getArea())) {
	                    offending.add(p);
	                    break;
	                }
	            } else {
	                if (isInputDomain(a.getArea())) {
                        offending.add(p);
                        break;
                    }
	            }
            }
        }
    }
    return offending;
}    

/*  Returns a set of assignments that don't match the specified domain.
    params:
    output : Boolean    Indicates whether the output (true) or input (false)
                        domain is matched.    
*/ 
operation QVT!BottomPattern offendingAssignments(output : Boolean) :  Set {
    var offending : Set;
    for (a in self.assignment) {
        if (a.isTypeOf(QVT!PropertyAssignment)) {
            if (output) {
	            if (isOutputDomain(a.value.getArea()) or isOutputDomain(a.slotExpression.getArea())) {
	                offending.add(a);
	                break;
	            }
	        } else {
	            if (isInputDomain(a.value.getArea()) or isInputDomain(a.slotExpression.getArea())) {
	                offending.add(a);
	                break;
	            }
	        }    
        } else if (a.isTypeOf(QVT!VariableAssignment)) {
	            if (output) {
	                if (isOutputDomain(a.targetVariable.oppositePattern().area) or isOutputDomain(a.value.getArea())) {
	                    offending.add(a);
	                    break;
	                }
	            } else {
	                if (isInputDomain(a.targetVariable.oppositePattern().area) or isInputDomain(a.value.getArea())) {
	                    offending.add(a);
	                    break;
	                }
	            }
	        }    
        }
    return offending;
}
 