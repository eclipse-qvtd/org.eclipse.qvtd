import "Helpers.eol";
import "OclLibHelper.eol";

pre {
    var EmfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
}

rule CoreModel
    transform mIn:QVTmF!CoreModel
    to mOut:QVTmP!CoreModel {
        mOut.name = mIn.name;
        mOut.nestedPackage ::= mIn.nestedPackage;
    }

rule Transformation
    transform tIn:QVTmF!Transformation
    to tOut:QVTmP!Transformation {
        
        tOut.`rule` ::= tIn.`rule`;
        for (mp in tIn.modelParameter) {
            var mpc = EmfTool.getECoreUtil().copy(mp);
            //QVTmP.resource.contents.add(mpc);
            tOut.modelParameter.add(mpc);
        }
    }
    
rule PartitionLM
    transform mapping:QVTmF!Mapping
    to mappingLM:QVTmP!Mapping, mappingMR:QVTmP!Mapping {
        
        // Only top mappings (named)
        guard : mapping.name <> null
        
        mapping.println();
        
        /* Create LM mapping */
        mappingLM.name = mapping.name + "_LM";
        
        // Copy DomainPatterns
        //mappingLM.guardPattern = EmfTool.getECoreUtil().copy(mapping.guardPattern);
        mappingLM.guardPattern = mapping.guardPattern.equivalents().first();
        
        //mappingLM.bottomPattern = EmfTool.getECoreUtil().copy(mapping.bottomPattern);
        mappingLM.bottomPattern = mapping.bottomPattern.equivalents().first();
        
        // Remove predicates and assignments that reference variables in the output domain
        /* 
        for (gp in mappingLM.guardPattern) {
            if (gp.predicate.size() > 0) {
	            gp.predicate.removeAll(gp.offendingPredicates(true));
	        }
        }
        for (bp in mappingLM.bottomPattern) {
            if (bp.predicate.size() > 0) {
                bp.predicate.removeAll(bp.offendingPredicates(true));
            }
            if (bp.assignment.size() > 0) {
                bp.assignment.removeAll(bp.offendingAssignments(true));
            }
        }
        */
        // Copy Input Domains
        for (d:QVT!Area in mapping.domain) {
            if (isInputDomain(d)) {
                var dc = EmfTool.getECoreUtil().copy(d);
                mappingLM.domain.add(dc);
            }
        }
        // No nested mappings are copied, only the nested mapping's bottom pattern predicates
        // that refer to input domain variables (moved to the bottom pattern)
        for (nm in mapping.local) {
            for (bp in nm.bottomPattern) {
                if (bp.assignment.size() > 0) {
                    for (a in bp.offendingAssignments(false)) {
	                    var ac = EmfTool.getECoreUtil().copy(a);
                        mappingLM.bottomPattern.assignment.add(ac);
	                }
	            }
            }
        }
        
        
        /* Create MR mapping */
        mappingMR.name = mapping.name + "_MR";
        // Copy DomainPatterns
        //mappingMR.guardPattern = EmfTool.getECoreUtil().copy(mapping.guardPattern);
        mappingMR.guardPattern = mapping.guardPattern.equivalents().last();
        mappingMR.bottomPattern = mapping.bottomPattern.equivalents().last();
        
        // mappingMR.bottomPattern = EmfTool.getECoreUtil().copy(mapping.bottomPattern);
        // Remove predicates and assignments that reference variables in the output domain
        /* 
        for (gp in mappingMR.guardPattern) {
            if (gp.predicate.size() > 0) {
                gp.predicate.removeAll(gp.offendingPredicates(false));
            }
            
        }
        for (bp in mappingLM.bottomPattern) {
            if (bp.predicate.size() > 0) {
                bp.predicate.removeAll(bp.offendingPredicates(false));
            }
            if (bp.assignment.size() > 0) {
                bp.assignment.removeAll(bp.offendingAssignments(false));
            }
        }
        */
        // Copy Output Domains
        for (d:QVT!Area in mapping.domain) {
            if (isOutputDomain(d)) {
                var dc = EmfTool.getECoreUtil().copy(d);
                mappingMR.domain.add(dc);
            }
        }
        // Mested mappings are copied eliminating the nested mapping's bottom pattern predicates
        // that refer to input domain variables
        for (nm in mapping.local) {
            var nmc = EmfTool.getECoreUtil().copy(nm);
            mappingMR.local.add(nmc);
        }
        for (nm in mappingMR.local) {                      
            for (bp in nm.bottomPattern) {
                if (bp.assignment.size() > 0) {
                    bp.assignment.removeAll(bp.offendingAssignments(false));
                }
            }
        }
    }

@lazy
rule GuardPatterns
    transform gp : QVTmF!GuardPattern
    to lmgp : QVTmP!GuardPattern, mrgp : QVTmP!GuardPattern {
        
        // .predicate *
        if (gp.predicate.size() > 0) {
            // LM: Remove predicates and assignments that reference variables in the output domain
            for (p in gp.predicate.excluding(gp.offendingPredicates(true))) {
                lmgp.predicate.add(p.equivalent());
            }
            // MR: Remove predicates and assignments that reference variables in the input domain
            for (p in gp.predicate.excluding(gp.offendingPredicates(false))) {
                mrgp.predicate.add(p.equivalent());
            }
        }
        
        // .variable *
        lmgp.variable = gp.variable.clone();
        mrgp.variable = gp.variable.clone();
        
        //.bindsTo *
        lmgp.bindsTo = gp.bindsTo.clone();
        mrgp.bindsTo = gp.bindsTo.clone();
        
        //.ownedComment *
        lmgp.ownedComment = gp.ownedComment.clone();
        mrgp.ownedComment = gp.ownedComment.clone();
        
    }

@lazy
rule BottomPatterns
    transform bp : QVTmF!BottomPattern
    to lmbp : QVTmP!BottomPattern, mrbp : QVTmP!BottomPattern {
    
    // .predicate *
    if (bp.predicate.size() > 0) {
        // LM: Remove predicates and assignments that reference variables in the output domain
        for (p in bp.predicate.excluding(bp.offendingPredicates(true))) {
            lmbp.predicate.add(p.equivalent());
        }
        // MR: Remove predicates and assignments that reference variables in the input domain
        for (p in bp.predicate.excluding(bp.offendingPredicates(false))) {
            mrbp.predicate.add(p.equivalent());
        }
    }
    
    //.assignemnt
    if (bp.assignment.size() > 0) {
        for (a in bp.assignment.excluding(bp.offendingAssignments(true))) {
            lmbp.assignment.add(a.equivalent());
        }
        for (a in bp.assignment.excluding(bp.offendingAssignments(false))) {
            mrbp.assignment.add(a.equivalent());
        }
    }
    
    // .variable *
    lmbp.variable = bp.variable.clone();
    mrbp.variable = bp.variable.clone();
    
    //.bindsTo *
    lmbp.bindsTo = bp.bindsTo.clone();
    mrbp.bindsTo = bp.bindsTo.clone();
    
    //.ownedComment *
    lmbp.ownedComment = bp.ownedComment.clone();
    mrbp.ownedComment = bp.ownedComment.clone();
    
    //.realizedVariable
    lmbp.realizedVariable = bp.realizedVariable.clone();
    mrbp.variable.addAll(bp.realizedVariable.equivalent());
}


@lazy
rule Predicates
    transform fp : QVTmF!Predicate
    to pp : QVTmP!Predicate {
        
        pp.conditionExpression = EmfTool.getECoreUtil().copy(fp.conditionExpression);
    }
    
@lazy
rule VariableAssignments
    transform fa : QVTmF!VariableAssignment
    to pa : QVTmP!VariableAssignment {
        
        pa.isDefault = fa.isDefault;
        pa.value = EmfTool.getECoreUtil().copy(fa.value);
        pa.targetVariable = EmfTool.getECoreUtil().copy(fa.targetVariable);
    }    

@lazy
rule PropertyAssignments
    transform fa : QVTmF!PropertyAssignment
    to pa : QVTmP!PropertyAssignment {
        
        pa.isDefault = fa.isDefault;
        pa.value = EmfTool.getECoreUtil().copy(fa.value);
        pa.targetProperty = EmfTool.getECoreUtil().copy(fa.targetProperty);
        pa.slotExpression = EmfTool.getECoreUtil().copy(fa.slotExpression);
    }  

// In the MR transform realize variables to variables in the Middle Patterns
@lazy
rule MiddleRealizedvariables
    transform rv : QVTmF!RealizedVariable
    to v : QVTmP!Variable {
            
        v.implicit = rv.implicit;
        v.initExpression = rv.initExpression;
        v.isRequired = rv.isRequired;
        v.name = name;
        v.type = rv.type;
    }    

/*  Returns a set of predicates that don't match the specified (output) domain.
    params:
    output : Boolean    Indicates whether the output (true) or input (false)
                        domain is matched.    
*/  
operation QVT!CorePattern offendingPredicates(output : Boolean) :  Set {
    
    var offending : Set;
    for(p in self.predicate) {
        // The output domain vars may be either in the argument or in the source
        if (p.conditionExpression.source.isDefined()) {
            if (output) {
	            if (isOutputDomain(p.conditionExpression.source.getArea())) {
	                offending.add(p);
	                break;
	            }
            } else {
                if (isInputDomain(p.conditionExpression.source.getArea())) {
                    offending.add(p);
                    break;
                }
            }
        }
        if (p.conditionExpression.argument.isDefined()) {
            for (a in p.conditionExpression.argument) {
                if (output) {
	                if (isOutputDomain(a.getArea())) {
	                    offending.add(p);
	                    break;
	                }
	            } else {
	                if (isInputDomain(a.getArea())) {
                        offending.add(p);
                        break;
                    }
	            }
            }
        }
    }
    return offending;
}    

/*  Returns a set of assignments that don't match the specified (output) domain.
    params:
    output : Boolean    Indicates whether the output (true) or input (false)
                        domain is matched.    
*/ 
operation QVT!BottomPattern offendingAssignments(output : Boolean) :  Set {
    var offending : Set;
    for (a in self.assignment) {
        if (a.isTypeOf(QVT!PropertyAssignment)) {
            if (output) {
	            if (isOutputDomain(a.value.getArea()) or isOutputDomain(a.slotExpression.getArea())) {
	                offending.add(a);
	                break;
	            }
	        } else {
	            if (isInputDomain(a.value.getArea()) or isInputDomain(a.slotExpression.getArea())) {
	                offending.add(a);
	                break;
	            }
	        }    
        } else if (a.isTypeOf(QVT!VariableAssignment)) {
	            if (output) {
	                if (isOutputDomain(a.targetVariable.oppositePattern().area) or isOutputDomain(a.value.getArea())) {
	                    offending.add(a);
	                    break;
	                }
	            } else {
	                if (isInputDomain(a.targetVariable.oppositePattern().area) or isInputDomain(a.value.getArea())) {
	                    offending.add(a);
	                    break;
	                }
	            }
	        }    
        }
    return offending;
}
 