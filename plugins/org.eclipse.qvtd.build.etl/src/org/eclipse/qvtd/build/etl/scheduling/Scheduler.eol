/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
 
 /****l* /org.eclipse.qvtd.build.etl.scheduling/Scheduler
 * NAME
 *  Scheduler -- Invoke the data dependency analysis and map ordering functions
 *  and add the mapping calls to the QVTi AST model.
 *
 * MODELS
 *  Required models to run the script:
 *      - NAME      ALIASES METAMODEL               ROL SOD
 *      - qvti      QVT     QVTCore                  X   -        The QVTi (partitioned) AST
 *      - rTree     tree    ECoreContainmentTree     X   -        The right metamodel containment tree
 *      - qvts              QVTScheduling            -   X        The scheduling model
 * SEE ALSO
 *
 ******
 */
import "../helpers/QVTHelpers.eol";
import "MapOrdering.eol";

var s = new QVTs!Schedule;
s.createDependencyRelations(QVTi!Transformation.all().first().rule);
// Ordering
s.findMapOrdering();

// Different Scheduleing Policies
//QVTi!Transformation.all.first().simpleSchedule(s);
QVTi!Transformation.all.first().simpleNestedSchedule(s);

"Done".println();

/****o* Scheduler/simpleSchedule
 * NAME
 *  simpleSchedule - Creates a simple (naive) schedule, solely based on the map
 *  ordering.
 * FUNCTION
 *  Defines a simple schedule based on the mapping ordering by calling all the
 *  mappings sequentially.  
 *
 * CONTEXT
 *  QVTs!Schedule  The Schdule
 * ANNOTATIONS
 *  cached
 * PARAMETERS
 * 	rules 	The transformation for which the schedule is being craeted (QVTi!Rule)
 *  SEE ALSO
 */
operation QVTi!Transformation simpleSchedule(schedule : QVTs!Schedule) {
	
	var baseMapping = self.createBaseMapping();
	for (ma in schedule.actions.sortBy(a | a.count)) {
		var mc = new QVTi!MappingCall;
		mc.referredMapping = ma.mapping;
		mc.context = baseMapping;
	}
	
}

/****o* Scheduler/simpleNestedSchedule
 * NAME
 *  simpleNestedSchedule - Creates a simple (naive) schedule, solely based on the 
 *  map ordering and simple nesting based on Type availability
 * FUNCTION
 *  Defines a nested simple schedule based on the mapping ordering and by nesting
 *  mappings under mappings that provide the most variable/types in order to
 *  reduce the global searches. Placement should be as low down as possible, i.e.
 *  prefer the more inmediate predecesor, but above any unused iteration
 *  variables. 
 *
 *  Mappings with multiple input variables of the same type 
 *
 * CONTEXT
 *  QVTs!Schedule  The Schdule
 * ANNOTATIONS
 *  cached
 * PARAMETERS
 * 	rules 	The transformation for which the schedule is being craeted (QVTi!Rule)
 *  SEE ALSO
 */
operation QVTi!Transformation simpleNestedSchedule(schedule : QVTs!Schedule) {
	
	schedule.simpleNest();
	var baseMapping = self.createBaseMapping();
	for (ma in schedule.actions.sortBy(aa | aa.count)) {
        var mc = new QVTi!MappingCall;
        mc.referredMapping = ma.mapping;
	    if (ma.parent.isDefined()) {
            mc.context = ma.parent.mapping;
        } else {
            mc.context = baseMapping;
        }
	}
	// Make sure order dependencies are preserved
	QVTi.setCachingEnabled(false);
    self.forceOrder();
    QVTi.setCachingEnabled(true);
}

/****o* Scheduler/simpleNest
 * NAME
 *  simpleNest - Define the mapping action nesting.
 * FUNCTION
 *  Places a mapping action by searching up the the mapping dependencies to
 *  locate the mapping for which the context variables result in the maximum
 *  reuse of work already done. This is, the context that offers the biggest
 *  number of already assigned variables.
 * CONTEXT
 *  QVTs!Schedule   The schedule
 */
operation QVTs!Schedule simpleNest() {
    for (ma in self.actions.sortBy(a | a.count)) {
        //ma.mapping.name.println("ma ");
        var qin = ma.mapping.getInputVariables();
        // If the mapping has two variables of the same type, try to nest, else put in the root
        if (ma.mapping.getInputVariables().collect(v | v.type).size() == ma.mapping.getInputVariables().collect(v | v.type).asSet().size()) {
            // Visit the predecesor mappings in "clossest" order, i.e. higher to lower index
            for (pma in ma.getPredecessors().sortBy(aa | aa.count).invert()) {
                //pma.mapping.println("    pma: ");
                var nav = pma.getAvailableVariables();
                if (nav.collect(v | v.type).includesAll(qin.collect(v | v.type))) {
                    ma.parent = pma;
                    break;              // As low as possible
                } else {
                    var matched = qin.select(v | nav.collect(v | v.type).includes(v.type));
                    var missing = qin.select(v | not nav.collect(v | v.type).includes(v.type));
                    // We are missing some types, can we derive them?
                    derivedMissing(matched, missing);
                    if (missing.isEmpty()) {
                        ma.parent = pma;
                        break;              // As low as possible
                    } else {
                        // One of the still missing variables can be used as a loop variable
                        var loopV = null;
                        for (m in missing) {
                            for (mv in matched) {
                                var relations = m.hasRelation(mv); 
                                if (not relations.isEmpty()
                                        and relations.first().opposite.isDefined()
                                        and relations.first().opposite.isComposite) {
                                    loopV = m;
                                    break;
                                }
                            }
                            if (loopV <> null) {
                                break;  
                            }
                        }
                        if (loopV <> null) {
                            missing.remove(loopV);
                            matched.add(loopV);
                            // Try to derive more variables from the loop
                            // We are missing some types, can we derive them?
                            derivedMissing(matched, missing);
                            
                            // Once we have a loop varaible, we dont need a perfect
                            // match, the mising varaibles would just have to be
                            // global searched. Another option is to look
                            // for another nesting position. However, since
                            // we are matching against the whole predecesor
                            // available variables, there is no way we can 
                            // find better matches higher in the tree.
                            ma.parent = pma;
                            break;              // As low as possible
                        }
                    }
                }
            }
        }
    }
}

/****o* Scheduler/derivedMissing
 * NAME
 *  derivedMissing - Test if any missing variables can be derived from the matched
 *   and if so, remove them from missing and add them to matched.  
 * FUNCTION
 *  
 * CONTEXT
 *  QVTs!MappingAction  The MappingAction
 */
operation derivedMissing(matched : Sequence, missing : Sequence) {
   // missing.collect(v | v.name).println("        missing ");
    for (m in missing.clone()) {
        if (m.canBeDerived(matched)) {
            //m.name.println("        derived ");
            missing.remove(m);
            matched.add(m);
        }
    }
}

/****o* Scheduler/canBeDerived
 * NAME
 *  canBeDerived - Test if the variable can be derived from one in the sequence
 * FUNCTION
 *  Returns true if there is a relation of the form m.att = variable, where m
 *  is a member of the input sequence, or if the relation is of the form
 *  variable.att = m, and the att has an opposite and the opposite is not a
 *  composition relations (composition relations are used for loop variables)  
 * CONTEXT
 *  QVTs!Variable  The variable
 * PARAMETERS
 *  matched     A sequence of variables to test derivation
 * RETURNS
 *  true        If the variable can be derived.
 */
operation QVTi!Variable canBeDerived(matched : Sequence) : Boolean {
    for (mv in matched) {
        if (not mv.hasRelation(self).isEmpty()) {
            // Relations of the form matched.att = self
            return true;
        } else {
            // Relations of the form self.att = matched can be used for derivation
            // iif the relation has an opposite, and the opposite not composite
            var relations = self.hasRelation(mv); 
            if (not relations.isEmpty()
                    and relations.first().opposite.isDefined()
                    and not relations.first().opposite.isComposite) {
                return true;
            }
        }
    }
    return false;
}

/****o* Scheduler/forceOrder
 * NAME
 *  forceOrder - Reorder the mapping calls so dependencies are met.
 * FUNCTION
 *  Uses a sort algorithm to determine the correct order of mapping calls
 *  based on data dependencies. 
 * CONTEXT
 *  QVTs!Transformation  The transformation
 */
operation QVTs!Transformation forceOrder() {
    
    for (m in self.rule) {
        m.name.println("m ");
        var sorted = sortByDependency(m.mappingCall.asSequence());
        m.mappingCall.clear();
        m.mappingCall.addAll(sorted);
    }
}

/****o* Scheduler/sortByDependency
 * NAME
 *  sortByDependency - Sort a collection of mapping calls based on data
 *  dependencies.
 * FUNCTION
 *  Sorting is done using a quick sort algorithm.
 * PARAMETERS
 *  calls  The collection of mapping Calls to be sorted
 */
operation sortByDependency(calls : Collection) : Sequence {
    //calls.collect(mc | mc.referredMapping.name).println("calls ");
    var size = calls.size();
    var sorted : Sequence;
    if(size > 1) {
        var ind : Integer = size/2;     
        var L : Sequence;
        var R : Sequence;
        var pivot = calls.at(ind);
        //pivot.referredMapping.name.println("Pivot ");
        for (i in Sequence{0..size-1}) {
            if (i <> ind) {
                //pivot.referredMapping.name.println("                    " + calls.at(i).referredMapping.name + " hasLowerOrder? ");
                if (calls.at(i).hasLowerOrder(pivot)) {
                    L.add(calls.at(i));
                } else {
                    R.add(calls.at(i));
                }
            }
        }
        //L.collect(mc | mc.referredMapping.name).println("L ");
        var sortedL = sortByDependency(L.clone());
        //R.collect(mc | mc.referredMapping.name).println("R ");
        var sortedR = sortByDependency(R.clone());
        sorted.addAll(sortedL.including(pivot).includingAll(sortedR));
        //sorted.collect(mc | mc.referredMapping.name).println("sorted ");
        return sorted;
    } else {
        return calls;
    }    
}

/****o* Scheduler/hasLowerOrder
 * NAME
 *  hasLowerOrder - Indicates whether this MappingCall has a lower order than
 *  some other MappingCall.
 * FUNCTION
 *  This MappingCall has a lower order if:
 *      * This MappingCall's referredMapping is a direct predecesor of the other referredMapping
 *      * This MappingCall's referredMapping is a direct predecesor of any of the other referredMapping's nested calls  
 * PARAMETERS
 *  mc  The reference mappingCall with which to compare.
 * RETURNS
 *  true    If this MappingCall has a lower order, i.e. must be called first.
 */
operation QVTi!MappingCall hasLowerOrder(other : QVTi!MappingCall) : Boolean {
    
    var selfMa = QVTs!MappingAction.all().selectOne(ma | ma.mapping == self.referredMapping);
    var otherMa = QVTs!MappingAction.all().selectOne(ma | ma.mapping == other.referredMapping);
    if (otherMa.getPredecessors().includes(selfMa)) {
        return true;
    } else {
        var selfNestedLower : Boolean = false;      // This mapping action has a nested mapping that should be invoked before
        var otherNestedLower : Boolean = false;     // The other mapping action has a nested mapping that should be invoked before
        if (not self.referredMapping.mappingCall.isEmpty()) {
            selfNestedLower = self.referredMapping.mappingCall.exists(nmc | nmc.hasLowerOrder(other));
        }
        if (not other.referredMapping.mappingCall.isEmpty()) {
            otherNestedLower = other.referredMapping.mappingCall.exists(nmc | self.hasLowerOrder(nmc));
        }
        return selfNestedLower or otherNestedLower;
    }
    return false;
}


operation QVTi!Transformation createBaseMapping() : QVTi!Mapping {
    
    var baseMapping = new QVTi!Mapping;
    baseMapping.name = "__root__";
    baseMapping.transformation = self;
    baseMapping.guardPattern = new QVTi!GuardPattern;
    baseMapping.bottomPattern = new QVTi!BottomPattern;
    return baseMapping;
    
}

/****o* Scheduler/getAvailableVariables
 * NAME
 *  getAvailableVariables - Navigates through the MappingAction hierarchy
 *  to get the available variables to it.
 * FUNCTION
 *  The context of a MppingAction is the context of its caller. Thus, this 
 *  operation recursively navigates through the calling contexts (i.e. parents)
 *  and returns the union of available variables in all the calling contexts.
 *  The available variables of a mapping are its input and output variables
 *  with the variables available from its context.  
 *  Don't cache the results as parents change dynamically.
 * CONTEXT
 *  QVTs!MappingAction  The MappingAction
 */
operation QVTs!MappingAction getAvailableVariables() : Sequence {
    
    var result = self.mapping.getInputVariables().includingAll(self.mapping.getOutputVariables());
    if (self.parent.isDefined()) {
        result.addAll(self.parent.getAvailableVariables());
    }
    return result;
}

/****o* Scheduler/createDependencyRelations
 * NAME
 *  createDependencyRelations - Creates the datums and actions to model the 
 *  dependency relations of the given transformation rules.
 * FUNCTION
 *  The datums and actions represent the data dependency relations between
 *  mappings and data types. By accepting a set of rules as a parameter,
 *  the scheduling algorithm can pre-filter the rules on which the analysis
 *  is performed. 
 *
 * CONTEXT
 *  QVTs!Schedule  The Schdule
 * ANNOTATIONS
 *  cached
 * PARAMETERS
 * 	rules 	The transformation for which the schedule is being craeted (QVTi!Rule)
 *  SEE ALSO
 */
operation QVTs!Schedule createDependencyRelations(rules : Collection) {
	for (r in rules) {
		//r.println("r ");
	    var action = new QVTs!MappingAction;
	    action.schedule = self;
	    action.mapping = r;
	    var resultDatums = r.getOutputVariables().collect(v | v.getClassDatum());
	    self.datums.addAll(resultDatums);
	    action.results.addAll(resultDatums);
	   
		// Create distinc data sets for input variables
	    for (vA in r.getInputVariables()) {
	    	//vA.name.println("  va ");
	    	var dd = new QVTs!DistinctData;
	    	var argDatum = vA.getClassDatum();
	    	self.datums.add(argDatum);
	    	dd.primaryArguments.add(argDatum);
	    	for (dv in vA.derivedVariables(r.getInputVariables().excluding(vA))) {
	        	//dv.println("    derived ");
	        	argDatum = dv.getClassDatum();
	        	dd.secondaryArguments.add(argDatum);
	        	self.datums.add(argDatum);
	        }
	        dd.target = action;
	    }
	    // Create result PropertyDatums for PrimitiveData types assigned to properties
	    resultDatums = r.getPrimitiveDataTypeAssignemnts().collect(a | a.getPropertyDatum());
	    self.datums.addAll(resultDatums);
	    action.results.addAll(resultDatums);
	}
	// Find uses of the PropertyDatum to create the arguments
	for (d in self.datums.select(dt : QVTs!PropertyDatum | true)) {
		for (r in QVTi!Transformation.all().first().rule) {
		    for (p in r.getAllPredicates().select(p |
	    	        p.conditionExpression.isSimpleAttributeNavigation()
	    		    and (p.conditionExpression.source.source.type == d.type
	    		         or d.type.superClass.includes(p.conditionExpression.source.source.type))
	    		    and p.conditionExpression.source.referredProperty == d.property)) {
	    		var dd = new QVTs!DistinctData;
	            dd.primaryArguments.add(d);
	            QVTs!MappingAction.all().selectOne(m | m.mapping == r).distinctArguments.add(dd);
	        }
	    }
    }
}

/****o* Scheduler/getClassDatums
 * NAME
 *  getClassDatums - Returns the ClassDatum for the type of the variable
 *
 * CONTEXT
 *  QVTi!Variable  The variable
 * ANNOTATIONS
 *  cached
 * RETURNS
 *  QVTs!AbstractDatum	The ClassDatum for the variable's type
 *  SEE ALSO
 */
@cached 
operation QVTi!Variable getClassDatum() : QVTs!AbstractDatum {
	//var typeDatum = self.type.getClassDatum();
	//typeDatum.super.addAll(self.type.getSuperClass().collect(t | t.getClassDatum()));
	//return typeDatum.super.asSequence().including(typeDatum);
	return self.type.getClassDatum();
}

/****o* Scheduler/getPropertyDatum
 * NAME
 *  getPropertyDatum - Returns the PropertyDatum for an assignment.
 *  The PropertyDatum points to the type of the variable in the slot expression
 *  and the property to the targetProperty
 *
 * CONTEXT
 *  QVTi!Assignment  The assignment
 * ANNOTATIONS
 *  
 * RETURNS
 *  Sequence	The ClassDatum for the variable type and its superTypes
 *  SEE ALSO
 */
operation QVTi!Assignment getPropertyDatum() : QVTs!PropertyDatum {
	
	var d = new QVTs!PropertyDatum;
	d.type = self.slotExpression.referredVariable.type;
	d.property = self.targetProperty;
	return d;
}

/****o* Scheduler/getClassDatum
 * NAME
 *  getClassDatum - Returns the ClassDatum for a given type
 *
 * CONTEXT
 *  QVTi!Type  The type
 * ANNOTATIONS
 *  cached
 * RETURNS
 *  QVTs!ClassDatum The class datum
 *  SEE ALSO
 */
@cached
operation QVTi!Type getClassDatum() : QVTs!AbstractDatum {
	//self.name.println("getClassDatum ");
	if (QVTs!ClassDatum.all().exists(d | d.type == self)) {
		"Exists".println();
        return QVTs!ClassDatum.all().selectOne(d | d.type == self);
    } else {
    	var d = new QVTs!ClassDatum;
        d.type = self;
        d.super.addAll(self.superClass.collect(t | t.getClassDatum()).flatten());
        return d;
    }
}

/****o* Scheduler/derivedVariables
 * NAME
 *  derivedVariables - Analysis of variable relations to find derivable ones
 * FUNCTION
 *  Returns a list of variables that can be derived from the context variable. 
 *  The function performs a full depth search looking for variables that can be
 *  derived from the derived ones too.
 *
 * CONTEXT
 *  QVT!Variable  The variable being analyzed
 * PARAMETERS
 *  vars The variables to look for relations
 * RESULT
 *  A 
 * SEE ALSO
 *
 */
operation QVTi!Variable derivedVariables(vars : Sequence) : Set {

	var derived : Set;
    for (vB in vars) {
        if (not self.hasRelation(vB).isEmpty()) {
            //vB.name.println(self.name + "    has relation to ");
        	derived.add(vB);
	        derived.addAll(vB.derivedVariables(vars.excluding(vB)));
        }
    }
    return derived;
} 
