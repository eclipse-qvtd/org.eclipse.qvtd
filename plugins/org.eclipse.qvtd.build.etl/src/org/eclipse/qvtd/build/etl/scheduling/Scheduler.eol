/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Horacio Hoyos - initial implementation
 ******************************************************************************/
 
 /****l* /org.eclipse.qvtd.build.etl/dependence/scheduling/Scheduler
 * NAME
 *  Scheduler -- Invoke the data dependency analysis and map ordering functions
 *  and add the mapping calls to the QVTi AST model.
 *
 * MODELS
 *  Required models to run the script:
 *      - NAME      ALIASES METAMODEL               ROL SOD
 *      - qvti      QVT     QVTCore                  X   -        The QVTi (partitioned) AST
 *      - rTree     tree    ECoreContainmentTree     X   -        The right metamodel containment tree
 *      - qvts              QVTScheduling            -   X        The scheduling model
 * SEE ALSO
 *
 ******
 */
import "../helpers/OCLExpressionAnalysis.eol";
import "MapOrdering.eol";

var inputVarMap : Map;  // (mapping, Set{variable})
var outputVarMap : Map; // (mapping, Set{realizedVariable})
var dataTypeAssignments : Map;    // (mapping, Sequence{Type, Attribute})
var nodeMap : Map;      // (mapping, graph!Node)
var dataNodeMap : Map;      // (??, graph!Node)

//  
var s = new qvts!Schedule;

for (r in qvti!Transformation.all().first().rule) {
	//r.println("r ");
    var action = new qvts!MappingAction;
    action.schedule = s;
    action.mapping = r;
    var results = r.getOutputVariables().collect(v | v.getArgument());
    //results.collect(cd | cd.type.name).println("results: ");
    s.abstractDepedencies.addAll(results.collect(a | a.classDependency));
    action.results.addAll(results);
    action.dataHooks.addAll(results.collect(a | a.classDependency));
   
	// Create distinc data sets for input variables
	var arguments = r.getInputVariables().collect(v | v.getArgument());
	//arguments.collect(cd | cd.type.name).println("arguments: ");
	s.abstractDepedencies.addAll(arguments.collect(a | a.classDependency));
    action.arguments.addAll(arguments);
    action.dataDependencies.addAll(arguments.collect(a | a.classDependency));
    
    arguments.collect(a | a.createSecondaryArgumentRelations());
        
    // Create result PropertyDatums for PrimitiveData types assigned to properties
    results = r.getPrimitiveDataTypeAssignemnts().collect(a | a.getPropertyDatum());
    s.abstractDepedencies.addAll(results);
    action.dataHooks.addAll(results);
}

// All ClassDependency subtypes are also dataDependencies for the Action. 
for (ma in s.abstractActions) {
	ma.dataDependencies.addAll(s.abstractDepedencies.select(ad | ma.dataDependencies.exists(dd | ad.super.includes(dd))));
}


// Find uses of the PropertyDatum to create the arguments
for (d in s.abstractDepedencies.select(dt : qvts!PropertyDependency | true)) {
	//d.property.println("d ");
	for (aa in s.abstractActions) {
		//r.name.println("rule: ");
	    if (aa.mapping.getAllPredicates().exists(p |
    	        p.conditionExpression.isSimpleAttributeNavigation()
    		    and (p.conditionExpression.source.source.type == d.type
    		         or d.type.superClass.includes(p.conditionExpression.source.source.type))
    		    and p.conditionExpression.source.referredProperty == d.property)) {
    		aa.dataDependencies.add(d);
        }
    }
}

// Ordering
s.defineMapOrdering();


// Nesting and bindings
// 1. Create the base mapping
var root = new qvti!Mapping;
root.name = "__root__";
root.guardPattern = new qvti!GuardPattern;
root.bottomPattern = new qvti!BottomPattern;
var nested : Boolean;

for (mq in s.abstractActions.sortBy(ma | ma.index)) {
    nested = false;
    
    // If the mapping has two variables of the same type, we don't know how to nested yet, nested at the root
    // and all bindings must be global searches?
    //mq.arguments.println();
    if (mq.dataDependencies.forAll(dd | mq.arguments.one(a | a.classDependency == dd))) {
    	var qin = mq.dataDependencies;
    	mq.mapping.name.println("mq ");
    	qin.collect(da | da.type.name).println("qin ");        
    	for (mn in s.abstractActions.select(ma | ma.index < mq.index).sortBy(ma | ma.index).invert) {
	        mn.mapping.name.println("    mn ");
	        var nav = mn.getAvailableDepedencies();
	        nav.collect(da | da.type.name).println("        nav: ");
	        nav.collect(da | da.type).includesAll(qin.collect(da | da.type)).println("        ");
	        if (nav.includesAll(qin)) {
	            // If for each ClassDatum there is only 1 input variable of the same type
	            // it is a perfect match, look no further
	            mq.parent = mn;
		        nested = true;
		        break;
	            // TODO Fix the correct binding later
				// Create the bindings?
		        // mq.createBindings(qin, mn, nav);
				//
	        } else {
	            var missing = qin.excludingAll(nav);
	            var matched = qin.excludingAll(missing);
	            matched.collect(da | da.type.name).println("            matched: ");
	            missing.collect(da | da.type.name).println("            missing: ");
	            // Can some missing be derived from the matched?
	            var matchedArgs = mq.arguments.select(a | matched.includes(a.classDependency));
	            var missingArgs = mq.arguments.select(a | missing.includes(a.classDependency));
	            var derived = missingArgs.select(ma | matchedArgs.secondaryArgumentRelations.flatten().exists(sa | sa.argument == ma));
				
				matchedArgs.collect(da | da.variable.name).println("            matchedArgs: ");
	            missingArgs.collect(da | da.variable.name).println("            missingArgs: ");
	            derived.collect(da | da.variable.name).println("            dervArgs: ");
	            
	            
	            missingArgs.removeAll(derived);
	            missingArgs.collect(da | da.variable.name).println("            missingArgs2: ");
	            // Can the missing be derived from the matched as a loop?
	            var loop = matchedArgs.select(ta | missingArgs.secondaryArgumentRelations.flatten().exists(sa | sa.argument == ta));
	            loop.collect(da | da.variable.name).println("            loop: ");
	            
	            
	            
	           
	            if (missingArgs.isEmpty()) {
	                mq.parent = mn;
	                nested = true;	// Don't break casue we might find a match higher and we preffer those.'
	            }
	        }
	    }	
    }
    
    /*         
    for (mn in s.actions.select(ma | ma.index < mq.index).sortBy(ma | ma.index).invert) {
        mn.println("    mn ");
        var nav = mn.getAvailableDatums();
        nav.collect(da | da.type.name).println("        nav: ");
        nav.includesAll(qin).println("        ");
        if (nav.includesAll(qin)) {
            // If for each ClassDatum there is only 1 input variable of the same type
            // it is a perfect match, look no further
            mq.parent = mn;
	        nested = true;
            // TODO Fix the correct binding later
			// Create the bindings?
	        // mq.createBindings(qin, mn, nav);
			//
        } else {
            var matched = nav.select(cd | qin.includes(cd));
            matched.collect(da | da.type.name).println("            matched: ");
            var missing = qin.excludingAll(nav);
            missing.collect(da | da.type.name).println("            missing: ");
            // Can some missing be derived from the matched?
            for (mcs in missing.clone()) {
                for (match in matched) {
	                var primaryMatch = mq.distinctArguments
	                    .select(da | da.primaryArgument.exists(pa | pa.type == match.type)
	                              or match.super.exists(sd | da.primaryArgument.exists(pa | pa.type == sd.type)));
	                    
	                var primary = primaryMatch.selectOne(da | da.secondaryArgument.exists(sa | sa.type = mcs.type));
	                // Find a predicate that relates the two types.
	                if (primary.isDefined()) {
	                    var p = mq.mapping.getAllPredicates()
	                        .selectOne(p | p.conditionExpression.isSimpleAttributeNavigation()
	                                   and p.conditionExpression.source.source.type = primary.type
	                                   and p.conditionExpression.argument.first().type = mcs.type);
	                    if (p.isDefined()) {
	                        // mq.createBindings(qin, mn, nav);
	                        primary.type.name.println(mcs.type.name + " derived from ");
		                    var mb = new qvts!MappingBinding;
		                    mb.mappingAction = mq;
		                    var bindingEx = new qvti!VariableExp;
		                    bindingEx.referredVariable = p.conditionExpression.source.source.referredVariable;
		                    mb.bindingExp = bindingEx;
		                    mb.boundVariable = p.conditionExpression.argument.first();
		                    missing.remove(mcs);
	                    }
	                }  
	            }
            }
            // Find if a missing variable can be used as a loop
            for (mcs in missing) {
                for (match in matched) {
                    var primaryMatch = mq.distinctArguments
                        .select(da | da.primaryArgument.exists(pa | pa.type == mcs.type)
                                  or mcs.super.exists(sd | da.primaryArgument.exists(pa | pa.type == sd.type)));
                        
                    var primary = primaryMatch.selectOne(da | da.secondaryArgument.exists(sa | sa.type = match.type));
                    // Find a predicate that relates the two types.
                    if (primary.isDefined()) {
                        var p = mq.mapping.getAllPredicates()
                            .selectOne(p | p.conditionExpression.isSimpleAttributeNavigation()
                                       and p.conditionExpression.source.source.type == mcs.type
                                       and primary.secondaryArgument.collect(sa | sa.type).includes(p.conditionExpression.argument.first().type));
                        
                        if (p.isDefined()) {   
                            if (p.conditionExpression.source.referredProperty.opposite.isDefined()
                                    and p.conditionExpression.source.referredProperty.opposite.isComposite) {
	                            // mq.createBindings(qin, mn, nav);
	                            
								//primary.secondaryArgument.selectOne(sa | sa.type == match.type).type.name.println(mcs.type.name + " derived from ");
	                            //var mb = new qvts!MappingBinding;
	                            //mb.mappingAction = mq;
	                            //var bindingEx = new qvti!PropertyCallExp;
	                            //bindingEx.referredProperty = p.conditionExpression.source.referredProperty.opposite;
	                            //var sourceEx = new qvti!VariableExp;
	                            //sourceEx.referredVariable = p.conditionExpression.argument.first().referredVariable;
	                            //bindingEx.source = sourceEx;
	                            //mb.bindingExp = bindingEx;
	                            //mb.boundVariable = p.conditionExpression.source.source.referredVariable;
	                            
								//missing.remove(mcs);
								
                                nested = true;
                            }
                        }    
                    }
                }
            }
            if (nested) {
                mq.parent = mn;
                break;
            }
        }
    }
    if (not nested) {
        // Nest in the root mapping
    }
    */
}


"Done".println();

// Create the bindings. 
// 


/****o* getArgument() 
 * NAME
 *  getClassDatums - Returns the ClassDatum(s) for the type of the variable.
 *
 * FUNCTION
 *  This functions returns the Argument that corresponds to the variable. 
 *  If the variable's type is does not has a ClassDatum, it is created.
 * CONTEXT
 *  qvti!Variable  The variable
 * ANNOTATIONS
 *  cached
 * RETURNS
 *  qvts!Argument	The Argument for the variable
 *  SEE ALSO
 */
operation qvti!RealizedVariable getArgument() : qvts!Parameter {
	
	var d = new qvts!OutputParameter;
    d.classDependency = self.type.getClassDependency();
    d.classDependency.domain = self.oppositePattern().area;
	d.variable = self;
	return d;
}

operation qvti!Variable getArgument() : qvts!Parameter {
	
	var d = new qvts!InputParameter;
    d.classDependency = self.type.getClassDependency();
    d.classDependency.domain = self.oppositePattern().area;
	d.variable = self;
	return d;
}

// KLUDGE If the implementation language change, the cache annotation must
// be changed by a code addtion that caches 
@cached 
operation qvti!Type getClassDependency() : qvts!ClassDependency {
	
	var d = new qvts!ClassDependency;
    d.type = self;
    d.super.addAll(self.getSuperClass().collect(sc | sc.getClassDependency()));
	return d;
}


/****o* getPropertyDatum
 * NAME
 *  getPropertyDatum - Returns the PropertyDatum for an assignment.
 *  The PropertyDatum points to the type of the variable in the slot expression
 *  and the property to the targetProperty
 *
 * CONTEXT
 *  qvti!Assignment  The assignment
 * ANNOTATIONS
 *  
 * RETURNS
 *  Sequence	The ClassDatum for the variable type and its superTypes
 *  SEE ALSO
 */
operation qvti!Assignment getPropertyDatum() : qvts!PropertyDependency {
	
	var d = new qvts!PropertyDependency;
	d.type = self.slotExpression.referredVariable.type;
	d.property = self.targetProperty;
	return d;
}

/****o* derivedVariables
 * NAME
 *  derivedVariables - Analysis of variable relations to find derivable ones
 * FUNCTION
 *  Returns a list of variables that can be derived from the context variable. 
 *  The function performs a full depth search looking for variables that can be
 *  derived from the derived ones too.
 *
 * CONTEXT
 *  QVT!Variable  The variable being analyzed
 * PARAMETERS
 *  vars The variables to look for relations
 * RESULT
 *  A 
 * SEE ALSO
 *
 */
operation qvti!Variable derivedVariables(vars : Sequence) : Set {

	var derived : Set;
    for (vB in vars) {
        //vB.name.println("    vB ");
        if (not self.hasRelation(vB).isEmpty()) {
        	derived.add(vB);
	        derived.addAll(vB.derivedVariables(vars.excluding(vB)));
        }
    }
    return derived;
} 

/****o* hasRelation
  *  NAME
  *    hasRelation -- Identify relations between variables
  *  SYNOPSIS
  *    relation =  var1.hasRelation(var2);
  *  FUNCTION
  *    Analysies the predicates the mapping that contains the 
  *   variables and returns the type of relation found. 
  *  CONTEXT
  *     QVT!Variable   
  *  PARAMETERS
  *    variable : QVT!Variable - variable to analyze relations against
  *  RESULT
  *    Any  - The EReference that relates the variables, null if not existant
  *   TODO
  *   It may be usefull to divide this into hasPredicateRelation and hasAssignmentRelation
  *   so we have more controll over what relations we are looking for.
  *  SEE ALSO
  *
  */
operation qvti!Variable getRelation(variable : QVT!Variable) : Set {
    
    // Fin predicates and assignemnts that only refer the two variables and
    // return the properties that relate them
    return self.oppositePattern().area.rule.guardPattern.predicate
    	.select(p | p.conditionExpression.isSimpleAttributeNavigation()
    		    and p.conditionExpression.isArgumentVariable(variable)
    		    and p.conditionExpression.isSourceVariable(self));
        /* .collect(p | p.conditionExpression.getReferredProperty())
    	.includingAll(
    		self.oppositePattern().area.rule.bottomPattern.assignment
    		.select(a | a.isSimpleAttributeNavigation()
    			and a.slotExpression.referredVariable == self
    			and a.value.referredVariable == variable)
    		//.collect(a | a.targetProperty())
    	);*/
}


operation qvti!Variable hasRelation(variable : QVT!RealizedVariable) : Bag {
    
    return self.oppositePattern().area.rule.bottomPattern.assignment
    		.select(a | a.isSimpleAttributeNavigation()
    			and a.slotExpression.referredVariable == self
    			and a.value.referredVariable == variable);
}



operation qvts!InputParameter createSecondaryArgumentRelations() {
	
	for (pa in self.target.arguments) {
        //v.name.println("    v ");
        for (p in self.variable.getRelation(pa.variable)) {
        	var sar = new qvts!SecondaryArgumentRelation;
	        sar.relation = p.conditionExpression;
	        sar.argument = pa;
	        self.secondaryArgumentRelations.add(sar);
        }
    }
}

operation qvts!MappingAction getAvailableDepedencies() : OrderedSet {
	
	var results = self.dataDependencies.includingAll(self.dataHooks);
	if (self.parent.isDefined()) {
		results.addAll(self.parent.getAvailableDepedencies());
	} 
	return results;
}


operation qvts!Schedule defineMapOrdering() {

    var visited : Set;
    var mapLinear : Map;
    
    var queue : Sequence;
    // Do a Depth first search of the containment tree of the output model
    queue.addAll(rTree!Node.all().select(n | n.parent.isEmpty()));
    while (not queue.isEmpty()) {
        var n = queue.first();
        queue.remove(n);
        //n.println("n ");
        //  Find all the mappings that have an output node if this type
        for (ma in self.abstractActions.select(a : qvts!MappingAction | a.dataHooks.exists(dh | dh.type.name = n.EClassName))) {
            // Find the predecesors and linearize
            ma.getMappingOrderIndex(visited);
        }
        queue.addAll(n.children);
    }
    // Order any mappings not found in the predecessor search.
    // TODO This will put all mappigns in the bottom of the list, check if this is the correct approach
    for (ma in qvts!MappingAction.all.select(m | m.index == 0)) {
    	ma.getMappingOrderIndex(visited);
    }
    "Ordering".println();
    for (ma in self.abstractActions.select(a : qvts!MappingAction | true).sortBy(ma | ma.index)) {
        ma.mapping.name.println(ma.index + ":");
    }
    " ".println();
    " ".println();

}

operation qvts!MappingAction getMappingOrderIndex(visited) {
    
    visited.add(self);
    var index : Integer;
    // Find all the mappings that are predecesor to this one
    var pre = self.getPredecesorMappings();
    while (pre.size() > 0) {
        var pma = pre.first();
        if (not visited.includes(pma)) {        
            //"Recursive ".println();
            pma.getMappingOrderIndex(visited);
            //"Back".println();
        }    
        pre.remove(pma);
    }
    if (self.index == 0) {
        index = qvts!MappingAction.all().sortBy(ma | ma.index).last().index + 1;
        self.index = index;
    }
}

/****o* getPredecesorMappings
 *  NAME
 *    getPredecesorMappings -- get the list of predecesor mappings
 *  FUNCTION
 *  Predecessors of a MappingAction are all origins of its dataDependencies.
 *  CONTEXT
 *     qvts!MappingAction The maping action to query (mapping B) 
 *  RESULT
 *    Sequence  - The list of predecessor MappingActions
 *  SEE ALSO
 *
 */
operation qvts!MappingAction getPredecesorMappings() : Sequence {
	
	return self.dataDependencies.origins.flatten();
}


operation createBindings(qin, mn, nav) {

            if (qin.forAll(cd | mq.mapping.getInputVariables().one(v | v.type == cd.type))) {
                mq.parent = mn;
	            nested = true;
	            
	            for (cd in qin) {
	               var mb = new qvts!MappingBinding;
	               mb.mappingAction = mq;
	               var binding = new qvti!VariableExp;
	               var candidates = mn.mapping.getInputVariables().includingAll(mn.mapping.getOutputVariables())
	                                   .select(v | v.type == cd.type);
	               if (not candidates.isEmpty()) {
	                   binding.referredVariable = candidates.first();
	               } else {
	                   // TODO Tell my parent to pass me a variable
	               }
	               mb.bindingExp = binding;
	               mb.boundVariable = mq.mapping.getInputVariables().selectOne(v | v.type == cd.type);
	               // TODO how to select and then discard when we have multiple CalssDatums
	               // with the same type?
	            }
	            break;
            }
}
