// Input Domain
migrate CoreDomain
    when : isInputDomain(original) {
	    
	    migrated.isCheckable = false;
	    migrated.isEnforceable = false;
	    // We need to know the bottom pattern of all RealizedVariables in 
	    // the input domain
	    for (rv in original.bottomPattern.realizedVariable) {
	       rv.~bottomPattern = original.bottomPattern;
	    }
    }

// Core Domain
migrate CoreDomain
    when : not isInputDomain(original) {
	    
	    // TODO this should be global vars somehow
	    var isCreate = new Boolean;
	    isCreate = true;
	    
	    if (isCreate) {
	        migrated.isCheckable = false;
	    }
    }

// Make sure variables and predicates are contained in the pattern    
migrate BottomPattern 
    when : isInputDomain(original.area) {
    migrated.variable = original.realizedVariable.equivalent();
    for (a in  original.assignment) {
        migrated.predicate.add(a.equivalent());
    }
}
    
retype RealizedVariable to Variable
    when : isInputDomain(original.oppositeBottomPattern().area)
   
retype PropertyAssignment to Predicate
    when : isInputDomain(original.bottomPattern.area)

migrate PropertyAssignment
    when : isInputDomain(original.bottomPattern.area) {
    
        var exp = new QVTc!OperationCallExp;
        // It's an '=' operation 
        exp.referredOperation = new QVTc!Operation;
        exp.referredOperation.name = "=";
        // The source is a PropertyCallExp
        exp.source = new QVTc!PropertyCallExp;
        // The property is the targetProperty
        exp.source.referredProperty = original.targetProperty.equivalent();
        // The source of the PropertyCallExp is the slotExpression
        exp.source.source = original.slotExpression.equivalent();
        // The argument is the value
        var args : Set;
        args.add(original.value.equivalent());
        exp.argument = args;
        migrated.conditionExpression = exp;    
    }

delete PropertyAssignment
    when {
    
        original.slotExpression.~cascadeDelete = true;
        original.targetProperty.~cascadeDelete = true;
        original.value.~cascadeDelete = true;
        return not isInputDomain(original.bottomPattern.area)
        and (original.slotExpression.isTypeOf(QVTc!VariableExp)
            and original.slotExpression.referredVariable.oppositePattern().area.isTypeOf(QVTc!Mapping))
        and not original.value.isTypeOf(QVTc!VariableExp);
    }

//delete OCLExpression when : original.~cascadeDelete

//delete Property when : original.~cascadeDelete

@chached
operation isInputDomain(area : QVTc!Area) : Boolean {
    return config!Configuration.all.first().inputDirection.name == area.name;
}

@cached
operation QVTc!RealizedVariable oppositeBottomPattern() : QVTc!BottomPattern  {
    return QVTc!BottomPattern.all.selectOne(p |p.realizedVariable.includes(self)); }

@cached
operation QVTc!Variable oppositePattern() : QVTc!CorePattern  {
    
    if(self.isTypeOf(QVTc!Variable)) {
        return QVTc!CorePattern.all.selectOne(p |p.variable.includes(self));
    }
    if (self.isTypeOf(QVTc!RealizedVariable)) {
        return self.oppositeBottomPattern();
    }     
}






