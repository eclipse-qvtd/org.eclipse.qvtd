/*******************************************************************************
 * Copyright (c) 2013 The University of York and Willink Transformations.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Horacio Hoyos - initial API and implementation
 ******************************************************************************/
import "../helpers/QVTHelpers.eol";
import "../helpers/OclLibHelper.eol";

/****m* /org.eclipse.qvtd.build.etl/mtc/QVTcToQVTu
 * NAME
 *  QVTcToQVTu -- Flock migration script from QVTc to QVTu
 *
 * SEE ALSO
 *    
 ******
 */
 
/****d* /org.eclipse.qvtd.build.etl/mtc/QVTcToQVTu/PropertyAssignment
 * CONTEXT
 *  PropertyAssignment -- Flock migration script from QVTc to QVTu
 *
 * SEE ALSO
 *    
 ******
 */
// TODO Check that if the slot expression area is Null, the test is correct
// Output domain to middle assignments are removed, iif the value expression
// is not a variable
// TODO Do we also have to migrate VariableAssignments?!?!?!
@cascade
delete PropertyAssignment
    when : original.value.getArea().isOutputDomain()
        and not original.value.isTypeOf(QVTc!VariableExp)
        and original.slotExpression.getArea().isMiddleDomain()

// Middle domian to input assigments are removed
@cascade
delete PropertyAssignment
    when : original.slotExpression.getArea().isInputDomain()
        and original.value.getArea().isMiddleDomain()

// Output domain predicates of realized variables
@cascade
delete Predicate
    when : original.pattern.isTypeOf(QVTc!BottomPattern) and original.conditionExpression.findReferencedVariables().forAll(v | v.oppositePattern().area.isOutputDomain())


// Realized variables in the input domain are retyped into variables
retype RealizedVariable to Variable
    when {
        if (original.oppositePattern().area.isInputDomain()) {
            return true;
        } else {
            if (isMiddleDomain(original.oppositePattern().area)) {
                return original.oppositePattern().area.domain.size() > 0 and
                       original.oppositePattern().area.domain.forAll(d | d.isOutputDomain());
            } else {
                return false;
            }
        }
    }  

// Property assignments in the input domain are retyped to predicates   
retype PropertyAssignment to Predicate
    when {
        if (original.bottomPattern.area.isInputDomain()) {
            return true;
        } else {
            if (original.bottomPattern.area.isMiddleDomain()) {
                return original.bottomPattern.area.domain.size() > 0 and
                       original.bottomPattern.area.domain.forAll(d | d.isOutputDomain()) and 
                       original.findReferencedVariables().forAll(v | v.oppositePattern().area.isMiddleDomain());
            } else {
                return false;
            }
        }
    }  

migrate Transformation {
    var comment : QVTc!Comment = new QVTc!Comment;
    comment.body = getUnidirComment();
    migrated.ownedComment.add(comment);
}

// Input Domain
migrate CoreDomain
    when : original.isInputDomain() {
	    
	    migrated.isCheckable = false;
	    migrated.isEnforceable = false;
    }

// Output Domain(s)
// THIS SHOULD BE HANDELED BY THE ENGINE!!??
migrate CoreDomain
    when : original.isOutputDomain() {
        if (isCheckMode()) {
            migrated.isEnforceable = false;
        }
	    if (isEnforceMode()) {
	        migrated.isCheckable = false;
	    }
    }

// Make sure variables and predicates are contained in the pattern    
migrate BottomPattern 
    when {
        if (original.area.isInputDomain()) {
            return true;
        } else {
            if (original.area.isMiddleDomain()) {
                return original.area.domain.size() > 0 and
                       original.area.domain.forAll(d | d.isOutputDomain());
            } else {
                return false;
            }
        }
    } {
	    migrated.variable.addAll(original.realizedVariable.equivalent());
	    for (a in original.assignment) {
	        if (original.area.isInputDomain() or 
	            a.findReferencedVariables().forAll(v | v.oppositePattern().area.isMiddleDomain())) {
	               migrated.predicate.add(a.equivalent());
	            }
	    }
}

migrate PropertyAssignment
    when {
        if (original.bottomPattern.area.isInputDomain()) {
            return true;
        } else {
            if (original.bottomPattern.area.isMiddleDomain()) {
                return original.bottomPattern.area.domain.size() > 0 and
                       original.bottomPattern.area.domain.forAll(d | d.isOutputDomain()) and 
                       original.findReferencedVariables().forAll(v | v.oppositePattern().area.isMiddleDomain());
            } else {
                return false;
            }
        } }{
    
        var exp = new QVTc!OperationCallExp;
        // It's an '=' operation. TODO, how to get the correct type?
        exp.referredOperation = getOperationByName("=", oclStdLib!AnyType.all().selectOne(t | t.name == "OclAny"));
        exp.name = "=";
        // The type is boolean
        exp.type = exp.referredOperation.type;
        // The source is a PropertyCallExp
        exp.source = new QVTc!PropertyCallExp;
        // The property is the targetProperty
        exp.source.referredProperty = original.targetProperty.equivalent();
        // The source of the PropertyCallExp is the slotExpression
        exp.source.source = original.slotExpression.equivalent();
        exp.source.type = original.targetProperty.equivalent().type;
        // The argument is the value
        var args : Set;
        args.add(original.value.equivalent());
        exp.argument = args;
        migrated.conditionExpression = exp;    
    }


    
migrate PropertyAssignment
    when : original.bottomPattern.area.isOutputDomain() 
        and isCheckMode()
        and original.isDefault {
    
    migrated.isDefault = false;
}

