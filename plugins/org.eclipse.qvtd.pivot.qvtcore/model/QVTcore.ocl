import 'QVTcore.ecore'

package qvtcore

context BottomPattern
inv VariablesAreBottomVariables:
	variable->forAll(oclIsKindOf(BottomVariable))

context GuardPattern
inv VariablesAreGuardVariables:
	variable->forAll(oclIsKindOf(GuardVariable))

context Mapping
inv DomainsAreCoreDomains:
	domain->forAll(oclIsKindOf(CoreDomain))

inv NestedNameIsNull:
	_context <> null implies name = null

inv RootNameIsNotNull:
	transformation <> null implies name <> null

--context NavigationAssignment
--def: getReferredTargetProperty() : pivot::Property[1] = invalid
--inv TargetPropetyIsSlotProperty: slotExpression.type.conformsTo(getReferredTargetProperty().owningClass)

context OppositePropertyAssignment
def: getReferredTargetProperty() : pivot::Property[1] = targetProperty.opposite

inv CompatibleTypeForPartialValue:
	isPartial implies
		let propertyType = getReferredTargetProperty().type.oclAsType(ocl::CollectionType).elementType in
		let valueType = value.type in
		Tuple{
			status : Boolean = valueType.conformsTo(propertyType) or propertyType.conformsTo(valueType),
			message : String = 'OppositePropertyAssignment::CompatibleTypeForPartialValue: ' + valueType?.name + ' must conform to ' + propertyType.name + ' or vice-versa'
		}.status

inv CompatibleTypeForTotalValue:
	not isPartial implies
		let propertyType = getReferredTargetProperty().type in
		let valueType = value.type in
		Tuple{
			status : Boolean = valueType.conformsTo(propertyType) or propertyType.conformsTo(valueType),
			message : String = 'OppositePropertyAssignment::CompatibleTypeForTotalValue: ' + valueType?.name + ' must conform to ' + propertyType?.name + ' or vice-versa'
		}.status

inv OppositePropertyIsImplicit:
	getReferredTargetProperty().isImplicit
	
inv TargetPropetyIsSlotProperty:
	slotExpression.type.conformsTo(getReferredTargetProperty().owningClass)

context PropertyAssignment
def: getReferredTargetProperty() : pivot::Property[1] = targetProperty

inv CompatibleTypeForPartialValue:
	isPartial implies
		let propertyType = getReferredTargetProperty().type.oclAsType(ocl::CollectionType).elementType in
		let valueType = value.type in
		Tuple{
			status : Boolean = valueType.conformsTo(propertyType) or propertyType.conformsTo(valueType),
			message : String = 'PropertyAssignment::CompatibleTypeForPartialValue: ' + valueType?.name + ' must conform to ' + propertyType.name + ' or vice-versa'
		}.status

inv CompatibleTypeForTotalValue:
	not isPartial implies
		let propertyType = getReferredTargetProperty().type in
		let valueType = value.type in
		Tuple{
			status : Boolean = valueType.conformsTo(propertyType) or propertyType.conformsTo(valueType),
			message : String = 'PropertyAssignment::CompatibleTypeForTotalValue: ' + valueType?.name + ' must conform to ' + propertyType?.name + ' or vice-versa'
		}.status

inv PropertyIsNotImplicit:
	not targetProperty.isImplicit

inv TargetPropetyIsSlotProperty:
	slotExpression.type.conformsTo(getReferredTargetProperty().owningClass)

context RealizedVariable
inv NonDataTypeForType: not type.oclIsKindOf(ocl::DataType)

context VariableAssignment
inv CompatibleTypeForValue('VariableAssignment::CompatibleTypeForValue: ' + value.type?.name + ' must conform to ' + targetVariable.type?.name + ' or vice-versa'):
	targetVariable.type.conformsTo(value.type)
	or value.type.conformsTo(targetVariable.type)

endpackage
