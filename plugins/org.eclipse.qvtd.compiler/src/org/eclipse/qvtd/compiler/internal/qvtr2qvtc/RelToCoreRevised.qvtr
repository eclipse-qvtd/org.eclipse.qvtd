--------------------------------------------------------------------------------
-- Copyright (c) 2008 Tata Consultancy Services and others.
-- All rights reserved. This program and the accompanying materials
-- are made available under the terms of the Eclipse Public License v1.0
-- which accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
--
-- Contributors:
--     S.Reddy - Section 10.3 of the OMG MOF-QVT 1.0 specification
--     E.D.Willink - contributions to drafts of the above
--     E.D.Willink - adaptation to comply with QVT specification
--     H. Hoyos - adaptation to comply with QVT 1.2 and bug fixes
--------------------------------------------------------------------------------
import pivotocl     :   'platform:/resource/org.eclipse.ocl.pivot/model/Pivot.ecore'::pivot;
import qvtbase      :   'platform:/resource/org.eclipse.qvtd.pivot.qvtbase/model/QVTbase.ecore'::qvtbase;
import qvttemplate  :   'platform:/resource/org.eclipse.qvtd.pivot.qvttemplate/model/QVTtemplate.ecore'::qvttemplate;
import qvtrelation  :   'platform:/resource/org.eclipse.qvtd.pivot.qvtrelation/model/QVTrelation.ecore'::qvtrelation;
import qvtcorebase  :   'platform:/resource/org.eclipse.qvtd.pivot.qvtcorebase/model/QVTcoreBase.ecore'::qvtcorebase;
import qvtcore      :   'platform:/resource/org.eclipse.qvtd.pivot.qvtcore/model/QVTcore.ecore'::qvtcore;



transformation relToCore(relations:{qvtrelation,qvttemplate,qvtbase,pivotocl}, core:{qvtcore,qvtcorebase,qvtbase,pivotocl})
{

key pivotocl::Type{name};
key pivotocl::Class{name};
key pivotocl::Property{name, owningClass};
key pivotocl::Package{name};
key pivotocl::Operation{name};
key pivotocl::Variable{name, type};
key qvtbase::TypedModel{name, usedPackage, transformation};
key qvtbase::Transformation{name};
key qvtbase::Predicate{pattern, conditionExpression};
key qvtcorebase::GuardPattern{area};
key qvtcorebase::BottomPattern{area};
key qvtcorebase::CoreDomain{name, rule};
key qvtcore::Mapping{name, transformation};

query getSharedDomainVars(r:qvtrelation::Relation):Set(pivotocl::Variable)
{
    r.domain->iterate(d; vars: Set(pivotocl::Variable) = Set{} |
        if (vars->isEmpty())
        then
            vars->union(d.oclAsType(qvtrelation::RelationDomain).pattern.bindsTo)
        else
            vars->intersection(d.oclAsType(qvtrelation::RelationDomain).pattern.bindsTo)
        endif
    )
}

query getWhenVars(r:qvtrelation::Relation):Set(pivotocl::Variable)
{
    let
        vs:Set(pivotocl::Variable) = Set{}
    in
    r.domain->iterate(d; vars: Set(pivotocl::Variable) = Set{} |
        if (vars->isEmpty())
        then
            vars->union(d.oclAsType(qvtrelation::RelationDomain).pattern.bindsTo)
        else
            vars->intersection(d.oclAsType(qvtrelation::RelationDomain).pattern.bindsTo)
        endif
    )
}

-- Get variables occuring in an ocl expression
-- Note: this function is not complete! It needs to be completed for other expressions
query getVarsOfExp(e:pivotocl::OCLExpression):Set(pivotocl::Variable)
{
    -- Walk the expr tree of the pivotocl::OCLExpression and
    -- collect the variables used in those expressions
    let
        vs:Set(pivotocl::Variable) = Set{}
    in
    if (e.oclIsTypeOf(pivotocl::VariableExp))
    then
        vs->including(e.oclAsType(pivotocl::VariableExp).referredVariable.oclAsType(pivotocl::Variable))
    else
        if (e.oclIsTypeOf(pivotocl::OperationCallExp))
        then
            let
                oc:pivotocl::OperationCallExp = e.oclAsType(pivotocl::OperationCallExp)
            in
            vs->union(getVarsOfExp(oc.ownedSource))->union(
                oc.ownedArguments->iterate(a; avs:Set(pivotocl::Variable)=Set{} | avs->union(getVarsOfExp(a)))
            )
        else
            if (e.oclIsTypeOf(pivotocl::PropertyCallExp))
            then
                vs->union(getVarsOfExp(e.oclAsType(pivotocl::PropertyCallExp).ownedSource))
            else
                if (e.oclIsTypeOf(qvtrelation::RelationCallExp))
                then
                    let
                        rc:qvtrelation::RelationCallExp = e.oclAsType(qvtrelation::RelationCallExp)
                    in
                    vs->union(rc.argument->iterate(a; avs:Set(pivotocl::Variable)=Set{} |
                        avs->union(getVarsOfExp(a)))
                    )
                else
                    vs
                endif
            endif
        endif
    endif
}

query filterOutPredicatesThatReferToVars(rpSet:Set(qvtbase::Predicate),
    ownrdVars:Set(pivotocl::Variable)) :Set(qvtbase::Predicate)
{
    rpSet->iterate(p:qvtbase::Predicate; fpSet:Set(qvtbase::Predicate) = Set{}|
        if (getVarsOfExp(p.conditionExpression)->intersection(ownrdVars)->isEmpty())
        then
            fpSet->including(p)
        else
            fpSet
        endif
    )
}

--Check if the given variable is bound to any template other than the one to be skipped
query isVarBoundToSomeOtherTemplate(rootTe:qvttemplate::ObjectTemplateExp,
    skipTe:qvttemplate::ObjectTemplateExp, v:pivotocl::Variable):Boolean
{
    if (rootTe = skipTe)
    then
        false
    else
        if (rootTe.bindsTo = v)
        then
            true
        else
            rootTe.part.value->select(pe | pe.oclIsKindOf(qvttemplate::ObjectTemplateExp))->exists(pet |
                isVarBoundToSomeOtherTemplate(pet.oclAsType(qvttemplate::ObjectTemplateExp), skipTe, v))
        endif
    endif
}

top relation RelationalTransformationToMappingTransformation
{
    rtn, tmn:String;

    domain relations rt:RelationalTransformation {
        name = rtn,
        modelParameter = rtm:TypedModel {
            name = tmn,
            usedPackage = up:pivotocl::Package{}
        }   
    };

    enforce domain core mt:Transformation {
        name = rtn,
        modelParameter = mtm:TypedModel {
            name = tmn,
            usedPackage = up
        }
    };
}

top relation RelationalTransformationToPackage
{
    rtn, rn :String;

    domain relations rt:RelationalTransformation {
        name = rtn,
        rule = r:Relation {}
    };

    enforce domain core p:pivotocl::Package {
        name = rtn,
        URI = rtn,
        ownedClasses = rc:Class {}
    };
    where {
    RelationToTraceClass(r, rc);
    }
}

-- Rule 1: Corresponding to each relation there exists a trace class in core.
-- The trace class contains a property corresponding to each object node in the
-- pattern of each domain of the relation, and a property for each shared domain
-- variable
--
relation RelationToTraceClass
{
    rn:String;
    sharedDomainVars: Set(pivotocl::Variable);

    domain relations r:Relation {
        name = rn,
        domain = rd:RelationDomain {
            pattern = rdp:DomainPattern {
                templateExpression = t:TemplateExp {}
            }
        }
    };
    enforce domain core rc:Class {
        name = 'T'+rn
    };
    where {
    	sharedDomainVars = getSharedDomainVars(r);
    	
    	RVarSetToTraceClassProps(sharedDomainVars->asSequence(), rc);
        SubObjectTemplateToTraceClassProps(t, rc);
        SubCollectionTemplateToTraceClassProps(t, rc);
    }
}

relation RVarSetToTraceClassProps
{
	rvRest: Sequence(pivotocl::Variable);

    domain relations rvSeq:Sequence(pivotocl::Variable) {
        rv:pivotocl::Variable {}
        ++ rvRest};
    enforce domain core rc:Class {};
    where {
        
        RVarToTraceClassProp(rv, rc);
        RVarSetToTraceClassProps(rvRest, rc);
    }
}

relation RVarToTraceClassProp
{
	vn: String;
    
    domain relations rv:pivotocl::Variable {
            name = vn,
            type = c:Class {}
    };
    enforce domain core rc:Class {
        ownedProperties = a:pivotocl::Property {
            name=vn,
            type=c
        }
    };
}

relation SubObjectTemplateToTraceClassProps
{
    domain relations t:TemplateExp { }
    {
        t.oclIsTypeOf(qvttemplate::ObjectTemplateExp)
    };
    enforce domain core rc:Class {};
    where {
        ObjectTemplateToTraceClassProps(t, rc);
    }
}

relation ObjectTemplateToTraceClassProps
{
    vn: String;
    
    domain relations t:ObjectTemplateExp {
        bindsTo = tv:pivotocl::Variable {
            name = vn,
            type = c:Class {}
        },
        part = pt:PropertyTemplateItem {
            value = tp:TemplateExp { }
        }
    };
    enforce domain core rc:Class {
        ownedProperties = a:pivotocl::Property {
            name=vn,
            type=c
        }
    };
    where {
        SubObjectTemplateToTraceClassProps(tp, rc);
        SubCollectionTemplateToTraceClassProps(tp, rc);
    }
}

relation SubCollectionTemplateToTraceClassProps
{

    domain relations t:TemplateExp {
    }
    {
        t.oclIsTypeOf(qvttemplate::CollectionTemplateExp)
    };
    enforce domain core rc:Class { };
    where {
        CollectionTemplateToTraceClassProps(t, rc);
    }
}

relation CollectionTemplateToTraceClassProps
{
    
    domain relations t:CollectionTemplateExp {
        member = tp:TemplateExp {}
    };
    enforce domain core rc:Class {};
    where {
        SubObjectTemplateToTraceClassProps(tp, rc);
        SubCollectionTemplateToTraceClassProps(tp, rc);
    }
}

-- For mapping to core we distinguish between two kinds of relations of a transformation:
--   - top-level relations and invoked relations.
-- Top-level relations are not invoked by any other relation in the transformation.
-- There exists a single mapping (with perhaps contained mappings) for a top-level relation,
-- whereas for an invoked relation there exists a separate mapping for each invoker-invoked
-- combination.

-- For mapping to core we also distinguish between check-only relations and enforceable
-- relations. A check-only relation maps to a single core mapping, whereas an enforceable
-- relation typically maps to a composite hierarchy of mappings in core.
--

-- Rule 2:
-- The following are the common translation rules between
-- a relation and a core mapping.
-- 2.1: Variables of a RelationDomain that occur in the when clause become
-- PatternVarables of the core domain guard.
-- 2.2: All other Variables of a relationDomain become PatternVars
-- of the core domain bottom pattern.
-- 2.3: An instance variable corresponding to the trace class of the relation becomes part of
-- the core mapping bottom pattern with its properties set(assigned or equated) to the
-- corresponding core domain pattern variables.
-- 2.4: A property template item in the relation domain pattern becomes an
-- assignment (or equation in the case of check-only domains) in the core domain bottom pattern.
-- 2.5: Predicates of the when clause become predicates of the core mapping guard.
-- 2.6: Non relation invocation predicates of the where clause become predicates of the core
--   mapping bottom.
-- 2.6.1: relation invocation predicates of the where clause are ignored in this mapping, but
-- are reflected in the mapping corresponding to the invoked relation.
--

-- All Object template expressions (at the top level of the DomainPattern)
-- become assignments in the core domain bottom. Nested
-- ObjectTemplateExpressions become assignments in composed mappings.
--

-- Rule 3 (extends Rule 2):
-- 3.1: A relation is 'check-only' if it does not have any enforceable domains.
-- 3.2: Only the trace class variable in the mapping bottom is 'realized'; there are no
-- other 'realized' variables in any of the mapping areas.
-- 3.3: A property template item in a relation domain becomes an equation in the core domain
-- bottom.
-- 3.4: A property template item in a relation domain that refers to a shared variable
-- becomes an equation in the mapping bottom.
-- 3.5: Shared variables referenced in property template items of relation domains become
-- variables of the mapping bottom.
--
top relation TopLevelRelationToMappingForChecking
{
    allDomainVars: Set(pivotocl::Variable);
    sharedDomainVars: Set(pivotocl::Variable);
    unsharedWhereVars: Set(pivotocl::Variable);
    whenVars: Set(pivotocl::Variable);
    whereVars: Set(pivotocl::Variable);
    rn: String;
    rt: qvtrelation::RelationalTransformation;
    mt: qvtbase::Transformation;

    domain relations r:Relation {
        transformation = rt,
        isTopLevel = true,
        name = rn
    }
    {
        not r.domain->exists(d| d.isEnforceable = true)
    };
    enforce domain core m:Mapping {
        transformation = mt,
        name = rn,
        guardPattern = mg:GuardPattern {
            area = m
        },
        bottomPattern = mb:BottomPattern {
            variable = mbVars:Set(pivotocl::Variable) { },
            realizedVariable = tcv:RealizedVariable { }
        }
    };
    when {
        RelationalTransformationToMappingTransformation(rt, mt);
    }
    where {
        allDomainVars = r.domain->iterate(md; acc:Set(qvtrelation::RelationDomain)=Set{} |
        acc->including(md.oclAsType(qvtrelation::RelationDomain))).pattern.bindsTo->asSet();
        whenVars = r.when.bindsTo;
        whereVars = r.where.bindsTo;
        sharedDomainVars = getSharedDomainVars(r);
        unsharedWhereVars = (whereVars - whenVars - allDomainVars)->union(sharedDomainVars);

        RelationToTraceClassVar(r, tcv);
        RWhenPatternToMGuardPattern(r, mg);
        if (unsharedWhereVars->isEmpty())
        then
            mbVars = Set{}
        else
            RVarSetToMVarSet(unsharedWhereVars->asSequence(), mbVars)
        endif;
        -- Only non relation invocation predicates are copied from where clause to mapping
        -- bottom.
        RWherePatternToMPattern(r, mb);
        RDomainToMDomainForChecking(r, m);
    }
}

relation RWherePatternToMPattern
{
    domain relations r:Relation{
        where = wherep:Pattern { }
    };
    enforce domain core mp:Pattern {};
    where {
        RSimplePatternToMPattern(wherep, mp);
    }
}

relation UnsharedWhenVarsToMgVars
{
    domain relations unsharedWhenVars:Set(pivotocl::Variable) {_++_};
    enforce domain core mg:GuardPattern {
        variable = mgVars:Set(pivotocl::Variable) {}
    };
    where {
        RVarSetToMVarSet(unsharedWhenVars->asSequence(), mgVars);
    }
}

relation DomainVarsSharedWithWhenToDgVars
{
    domain relations domainVarsSharedWithWhen:Set(pivotocl::Variable) {_++_};
    enforce domain core dg:GuardPattern {
        variable = dgVars:Set(pivotocl::Variable) {}
    };
    where {
        RVarSetToMVarSet(domainVarsSharedWithWhen->asSequence(), dgVars);
    }
}

relation DomainBottomUnSharedVarsToDbVars
{
    domain relations domainBottomUnSharedVars:Set(pivotocl::Variable) {_++_};
    enforce domain core db:BottomPattern {
        variable = dbVars:Set(pivotocl::Variable) {}
    };
    where {
        RVarSetToMVarSet(domainBottomUnSharedVars->asSequence(), dbVars);
    }
}

-- Rule 4 (extends Rule 2):
-- 4.1: A separate mapping is generated for each enforced domain of the relation.
-- 4.2: In this mapping only the enforced domain in question is marked as enforced in core;
-- all its opposite domains are marked in core as checked at most (i.e. either left as
-- they are or downgraded to checked if marked as enforced).
-- 4.3: The enforced domain's pattern gets decomposed into nested mappings as follows:
--         - root pattern object variable becomes a realized variable in the domain bottom
--         pattern of the current mapping.
--         - all identifying property template items become assignments in the domain bottom
--         pattern of the current mapping.
--         - all non identifying property template items of primitive type become assignments
--         in the bottom pattern of a nested mapping.
--         - each non identifying property template item of object type results in a nested
--         mapping which will have:
--            - a realized variable in the domain bottom, corresponding to the variable of the
--            property value object.
--            - a property assignment from parent object variable to this variable in the
--            domain bottom.
--            - and its own nested mappings as above recursively.
-- 4.4: Predicates of the where clause that refer to variables of the enforced domain get
-- distributed down to the nested mappings as variable bindings accumulate in the nested
-- mappings.
-- 4.5: all other opposite domains are mapped to their respective core domain parts as
-- described in Rule 3, i.e. their patterns are not decomposed down into nested mappings.
-- 4.6: A black-box operational implementation, if any, that the relation has for the
-- enforced domain becomes a pair of enforcement operations (one for creation and one for
-- deletion) in the domain-bottom pattern, both pointing to the same operation call
-- expression that takes its arguments from the variables corresponding to the root objects
-- of the domains of the relation.
--
top relation TopLevelRelationToMappingForEnforcement
{
    allDomainVars: Set(pivotocl::Variable);
    oppositeDomainVars: Set(pivotocl::Variable);
    sharedDomainVars: Set(pivotocl::Variable);
    predicatesWithVarBindings: Set(qvtbase::Predicate);
    predicatesWithoutVarBindings: Set(qvtbase::Predicate);
    unsharedWhenVars: Set(pivotocl::Variable);
    unsharedWhereVars: Set(pivotocl::Variable);
    domainVarsSharedWithWhen: Set(pivotocl::Variable);
    domainBottomUnSharedVars: Set(pivotocl::Variable);
    rdSeq, rdtSeq, relImplSeq: Sequence(pivotocl::Element);
    rdSet: Set(pivotocl::Element);
    rdVarsSeq: Sequence(Set(pivotocl::Element));
    rdtSet: Set(pivotocl::Element);
    rdtVarsSeq: Sequence(Set(pivotocl::Element));
    rn, dn, tmn: String;
    rOppositeDomains:Set(qvtrelation::RelationDomain);
    oppDomainSeq:Sequence(pivotocl::Element);
    whenVars: Set(pivotocl::Variable);
    whereVars: Set(pivotocl::Variable);
    rpSet: Set(qvtbase::Predicate);
    rt: qvtrelation::RelationalTransformation;
    mt: qvtbase::Transformation;

    domain relations r:Relation {
        transformation = rt,
        isTopLevel = true,
        name = rn,
        domain = rds:Set(RelationDomain) {
            rd:RelationDomain {
                isEnforceable = true,
                name = dn,
                typedModel = dir:TypedModel {
                    name = tmn,
                    usedPackage = up:pivotocl::Package{},
                    transformation = rt
                },
                pattern = dp:DomainPattern {
                    bindsTo = domainVars:Set(pivotocl::Variable) {},
                    templateExpression = te:ObjectTemplateExp {
                        bindsTo = tev:pivotocl::Variable {}
                    }
                }
            } ++ rOppositeDomains
        }
    };
    enforce domain core m:Mapping {
        transformation = mt,
        name = rn+'_'+dn,
        guardPattern = mg:GuardPattern {
            area = m
        },
        bottomPattern = mb:BottomPattern {
            area = m,
            variable = mbVars:Set(pivotocl::Variable){},
            realizedVariable = tcv:RealizedVariable {}
        },
        domain = md:CoreDomain {
            name = dn,
            isEnforceable = true,
            typedModel = mdir:TypedModel {
                name = tmn,
                usedPackage = up,
                transformation = mt
            },
            guardPattern = dg:GuardPattern {
                area = md
            },
            bottomPattern = db:BottomPattern {
                area = md,
                realizedVariable = mtev:pivotocl::Variable {}
            }
        }   --TODO: add var only if tev not in whenVars
    };
    when {
        RelationalTransformationToMappingTransformation(rt, mt);
    }
    where {
        allDomainVars = r.domain->iterate(md; acc:Set(qvtrelation::RelationDomain)=Set{} |
            acc->including(md.oclAsType(qvtrelation::RelationDomain))).pattern.bindsTo->asSet();
        whenVars = r.when.bindsTo;
        whereVars = r.where.bindsTo;

        -- Exclude where clause relation calls.
        -- The predicate corresponding to a where clause relation call is included not in this
        -- mapping but in the one corresponding to the invoked relation (refer to rule 2.6.1)
        rpSet = r.where.predicate->reject(p |
            p.conditionExpression.oclIsTypeOf(qvtrelation::RelationCallExp));

        oppositeDomainVars = rOppositeDomains->iterate(d; vars: Set(pivotocl::Variable) = Set{} |
            vars->union(d.oclAsType(qvtrelation::RelationDomain).pattern.bindsTo));
        sharedDomainVars = getSharedDomainVars(r);
        domainBottomUnSharedVars = domainVars - whenVars - sharedDomainVars;

        unsharedWhereVars =
            (whereVars - whenVars - allDomainVars)->union(sharedDomainVars);

        predicatesWithVarBindings =
            filterOutPredicatesThatReferToVars(rpSet, domainBottomUnSharedVars);
        predicatesWithoutVarBindings = rpSet - predicatesWithVarBindings;
        unsharedWhenVars = whenVars - allDomainVars;
        domainVarsSharedWithWhen = domainVars->intersection(whenVars)->excluding(tev);
        rdSeq = Sequence{r, rd};
        rdSet = Set{r, rd};
        rdVarsSeq = Sequence{rdSet, oppositeDomainVars};
        rdtSet = Set{r, rd, te};
        rdtVarsSeq = Sequence{rdtSet, predicatesWithoutVarBindings, domainBottomUnSharedVars};
        oppDomainSeq = Sequence{r, rd};
        relImplSeq = Sequence{r, rd};

        RelationDomainToTraceClassVar(rdSeq, tcv);
        RWhenPatternToMGuardPattern(r, mg);
        RVarSetToDGVarSet(domainVarsSharedWithWhen, dg);
        RVarToMRealizedVar(tev, mtev);
        if (unsharedWhereVars->isEmpty())
        then
            mbVars = Set{}
        else
            RVarSetToMBVarSet(unsharedWhereVars->asSequence(), mb)
        endif;
        RPredicateSetToMBPredicateSet(predicatesWithVarBindings->asSequence(), mb);
        RDomainToMDBottomForEnforcement(rdtVarsSeq, db);
        ROppositeDomainVarsToTraceClassProps(rdVarsSeq, mb);
        TROppositeDomainsToMappingForEnforcement(oppDomainSeq, m);
        RRelImplToMBottomEnforcementOperation(relImplSeq, mb);
    }
}

-- Rule 5 (extends Rule 3):
-- 5.1: an invoked relation maps to as many core mappings as the relations that invoke it.
--   i.e. there exists a separate core mapping for each invoker-invoked pair.
-- 5.2: The guard pattern of the mapping will have a variable corresponding to the trace
-- class of the invoker relation, with root object variables of all the patterns of all the
-- domains of the invoked relation being equated with corresponding properties of this
-- trace class .
-- 5.3: The root object variable of a relation domain's pattern becomes a pattern variable
-- in the core domain guard (this is in addition to the variables that occur in the when clause
-- as per rule 2.1).
--
top relation InvokedRelationToMappingForChecking
{
    allDomainVars: Set(pivotocl::Variable);
    sharedDomainVars: Set(pivotocl::Variable);
    unsharedWhereVars: Set(pivotocl::Variable);
    seqForInvoker: Sequence(pivotocl::Element);
    rn, irn: String;
    rt: qvtrelation::RelationalTransformation;
    mt: qvtbase::Transformation;
    whenVars: Set(pivotocl::Variable);
    whereVars: Set(pivotocl::Variable);

    domain relations r:Relation {
        transformation = rt,
        isTopLevel = false,
        name = rn,
        relationCallExp = ri:RelationCallExp {
            predicate = p:Predicate {
                pattern = pt:Pattern {
                    whereOwner = ir:Relation {name = irn}
                }
            }
        }
    }
    {
        not r.domain->exists(d| d.isEnforceable = true)
    };
    enforce domain core m:Mapping {
        transformation = mt,
        name = rn+'_'+irn,
        guardPattern = mg:GuardPattern {
            area = m
        },
        bottomPattern = mb:BottomPattern {
            variable = mbVars:Set(pivotocl::Variable){},
            realizedVariable = tcv:RealizedVariable {}
        }
    };
    when {
        RelationalTransformationToMappingTransformation(rt, mt);
    }
    where {
        allDomainVars = r.domain->iterate(md; acc:Set(qvtrelation::RelationDomain)=Set{} |
        acc->including(md.oclAsType(qvtrelation::RelationDomain))).pattern.bindsTo->asSet();
        whenVars = r.when.bindsTo;
        whereVars = r.where.bindsTo;
        sharedDomainVars = getSharedDomainVars(r);
        unsharedWhereVars =
        (whereVars - whenVars - allDomainVars)->union(sharedDomainVars);
        seqForInvoker = Sequence{ ir, ri, r};

        RelationToTraceClassVar(r, tcv);
        RWhenPatternToMGuardPattern(r, mg);
        RInvokerToMGuard(seqForInvoker, mg);
        if (unsharedWhereVars->isEmpty())
        then
            mbVars = Set{}
        else
            RVarSetToMVarSet(unsharedWhereVars->asSequence(), mbVars)
        endif;
        RWherePatternToMPattern(r, mb);
        RDomainToMDomainForChecking(r, m);
    }
}

-- Rule 6 (extends Rule 4):
-- 6.1: an invoked relation maps to as many core mappings as the relations that invoke it.
--   i.e. there exists a separate core mapping for each invoker-invoked pair.
-- 6.2: The guard pattern of the mapping will have a variable corresponding to the trace
-- class of the invoker relation, with root object variables of all the patterns of all the
-- domains of the invoked relation being equated with corresponding properties of this
-- trace class .
-- 6.3: The root object variable of a relation domain's pattern becomes a pattern variable
-- in the core domain guard (this is in addition to the variables that occur in the when clause
-- as per rule 2.1).
--
top relation InvokedRelationToMappingForEnforcement
{
    allDomainVars: Set(pivotocl::Variable);
    oppositeDomainVars: Set(pivotocl::Variable);
    sharedDomainVars: Set(pivotocl::Variable);
    predicatesWithVarBindings: Set(qvtbase::Predicate);
    predicatesWithoutVarBindings: Set(qvtbase::Predicate);
    unsharedWhenVars: Set(pivotocl::Variable);
    unsharedWhereVars: Set(pivotocl::Variable);
    domainTopVars: Set(pivotocl::Variable);
    domainBottomUnSharedVars: Set(pivotocl::Variable);
    rdSeq, relImplSeq: Sequence(pivotocl::Element);
    rdSet: Set(pivotocl::Element);
    rdVarsSeq: Sequence(Set(pivotocl::Element));
    rdtSet: Set(pivotocl::Element);
    rdtVarsSeq: Sequence(Set(pivotocl::Element));
    seqForInvoker: Sequence(pivotocl::Element);
    rn, irn, dn, tmn: String;
    rOppositeDomains:Set(qvtrelation::RelationDomain);
    oppDomainSeq:Sequence(pivotocl::Element);
    whenVars: Set(pivotocl::Variable);
    whereVars: Set(pivotocl::Variable);
    rpSet: Set(qvtbase::Predicate);
    rt: qvtrelation::RelationalTransformation;
    mt: qvtbase::Transformation;

    domain relations r:Relation {
        transformation = rt,
        isTopLevel = false,
        name = rn,
        relationCallExp = ri:RelationCallExp {
            predicate = p:Predicate {
                pattern = pt:Pattern {
                    whereOwner = ir:Relation {name = irn}
                }
            }
        },
        domain = rds:Set(RelationDomain) {
            rd:RelationDomain {
                isEnforceable = true,
                name = dn,
                typedModel = dir:TypedModel {
                    name = tmn,
                    usedPackage = up:pivotocl::Package{},
                    transformation = rt
                },
                pattern = dp:DomainPattern {
                    bindsTo = domainVars:Set(pivotocl::Variable) {},
                    templateExpression = te:ObjectTemplateExp {
                        bindsTo = tev:pivotocl::Variable {}
                    }
                }
            } ++ rOppositeDomains
        }
    };
    enforce domain core m:Mapping {
        transformation = mt,
        name = rn+'_'+irn+'_'+dn,
        guardPattern = mg:GuardPattern {
            area = m
        },
        bottomPattern = mb:BottomPattern {
            area = m,
            variable = mbVars:Set(pivotocl::Variable){},
            realizedVariable = tcv:RealizedVariable {}
        },
        domain = md:CoreDomain {
            name = dn,
            isEnforceable = true,
            typedModel = mdir:TypedModel {
                name = tmn,
                usedPackage = up,
                transformation = mt
            },
            guardPattern = dg:GuardPattern {
                area = md,
                variable = dgVars:Set(pivotocl::Variable) {}
            },
            bottomPattern = db:BottomPattern {
                area = md
            }
        }
    };
    when {
        RelationalTransformationToMappingTransformation(rt, mt);
    }
    where {
        allDomainVars = r.domain->iterate(md; acc:Set(qvtrelation::RelationDomain)=Set{} |
        acc->including(md.oclAsType(qvtrelation::RelationDomain))).pattern.bindsTo->asSet();
        whenVars = r.when.bindsTo;
        whereVars = r.where.bindsTo;

        -- Exclude where clause relation calls.
        -- The predicate corresponding to a where clause relation call is included not in this
        -- mapping but in the one corresponding to the invoked relation (refer to rule 2.6.1)
        rpSet = r.where.predicate->reject(p |
        p.conditionExpression.oclIsTypeOf(qvtrelation::RelationCallExp));

        oppositeDomainVars = rOppositeDomains->iterate(d; vars: Set(pivotocl::Variable) = Set{} |
        vars->union(d.oclAsType(qvtrelation::RelationDomain).pattern.bindsTo));
        sharedDomainVars = getSharedDomainVars(r);
        domainBottomUnSharedVars =
        (domainVars - whenVars - sharedDomainVars)->excluding(tev);
        unsharedWhereVars =
        (whereVars - whenVars - allDomainVars)->union(sharedDomainVars);
        predicatesWithVarBindings =
        filterOutPredicatesThatReferToVars(rpSet, domainBottomUnSharedVars);
        predicatesWithoutVarBindings = rpSet - predicatesWithVarBindings;
        unsharedWhenVars = whenVars - allDomainVars;
        domainTopVars = domainVars->intersection(whenVars)->including(tev);
        rdSeq = Sequence{r, rd};
        rdSet = Set{r, rd};
        rdVarsSeq = Sequence{rdSet, oppositeDomainVars};
        rdtSet = Set{r, rd, te};
        rdtVarsSeq = Sequence{rdtSet, predicatesWithoutVarBindings, domainBottomUnSharedVars};
        oppDomainSeq = Sequence{r, ir, rd};
        seqForInvoker = Sequence{ir, ri, r};
        relImplSeq = Sequence{r, rd};

        RelationDomainToTraceClassVar(rdSeq, tcv);
        if (unsharedWhereVars->isEmpty())
        then
            mbVars = Set{}
        else
            RVarSetToMBVarSet(unsharedWhereVars->asSequence(), mb)
        endif;
        RPredicateSetToMBPredicateSet(predicatesWithVarBindings->asSequence(), mb);
        RWhenPatternToMGuardPattern(r, mg);
        RInvokerToMGuard(seqForInvoker, mg);
        RVarSetToMVarSet(domainTopVars->asSequence(), dgVars);
        RDomainToMDBottomForEnforcement(rdtVarsSeq, db);
        ROppositeDomainVarsToTraceClassProps(rdVarsSeq, mb);
        IROppositeDomainsToMappingForEnforcement(oppDomainSeq, m);
        RRelImplToMBottomEnforcementOperation(relImplSeq, mb);
    }
}

relation RDomainToMDomainForChecking
{
    sharedDomainVars: Set(pivotocl::Variable);
    domainVarsSharedWithWhen: Set(pivotocl::Variable);
    domainBottomUnSharedVars: Set(pivotocl::Variable);
    seqForDomainPtrn: Sequence(pivotocl::Element);
    whenVars: Set(pivotocl::Variable);
    dn, tmn: String;
    rt: qvtrelation::RelationalTransformation;
    mt: qvtbase::Transformation;

    domain relations r:Relation {
        domain = rd:RelationDomain {
            name = dn,
            isCheckable = true,
            typedModel = dir:TypedModel {
                name = tmn,
                usedPackage = up:pivotocl::Package{},
                transformation = rt
            },
            pattern = dp:DomainPattern {
                bindsTo = domainVars:Set(pivotocl::Variable){},
                templateExpression = te:ObjectTemplateExp {}
            }
        }
    };
    enforce domain core m:Mapping {
        bottomPattern = mb:BottomPattern {
            area = m
        },
        domain = md:CoreDomain {
            name = dn,
            isCheckable = true,
            typedModel = mdir:TypedModel {
                name = tmn,
                usedPackage = up,
                transformation = mt
            },
            guardPattern = dg:GuardPattern {
                area = md
            },
            bottomPattern = db:BottomPattern {
                area = md
            }
        }
    };
    when {
        RelationalTransformationToMappingTransformation(rt, mt);
    }
    where {
        whenVars = r.when.bindsTo;
        sharedDomainVars = getSharedDomainVars(r);
        domainVarsSharedWithWhen = domainVars->intersection(whenVars);
        domainBottomUnSharedVars = domainVars - whenVars - sharedDomainVars;
        seqForDomainPtrn = Sequence{r, te};

        DomainVarsSharedWithWhenToDgVars(domainVarsSharedWithWhen, dg);
        DomainBottomUnSharedVarsToDbVars(domainBottomUnSharedVars, db);
        RDomainPatternToMDBottomPattern(seqForDomainPtrn, db);
        RDomainVarsToTraceClassProps(rd, mb);
    }
}

-- opposite domains of a top-level relation's enforced domain are mapped as per rules
-- 4.2 and 4.5
-- In addition, as per rule 6.3 the root object variable of a relation domain's pattern
-- becomes a pattern variable in the core domain guard (this is in addition to the variables
-- that occur in the when clause as per rule 2.1).
--
relation IROppositeDomainsToMappingForEnforcement
{
    sharedDomainVars:Set(pivotocl::Variable);
    domainTopVars: Set(pivotocl::Variable);
    domainBottomUnSharedVars: Set(pivotocl::Variable);
    domainBottomSharedVars: Set(pivotocl::Variable);
    seqForDomainPtrn: Sequence(pivotocl::Element);
    dn, tmn: String;
    c: Boolean;
    mbVars:Set(pivotocl::Variable);
    whenVars:Set(pivotocl::Variable);
    rt: qvtrelation::RelationalTransformation;
    mt: qvtbase::Transformation;
    up: pivotocl::Package;

    domain relations oppDomainSeq:Sequence(pivotocl::Element) {
        r:Relation {
            domain = rds:Set(RelationDomain) {
                ord:RelationDomain {      -- opposite domain
                    name = dn,
                    typedModel = dir:TypedModel {
                        name = tmn,
                        usedPackage = up,
                        transformation = rt
                    },
                    isCheckable = c,
                    pattern = dp:DomainPattern {
                        bindsTo = domainVars:Set(pivotocl::Variable) {},
                        templateExpression = te:ObjectTemplateExp {
                            bindsTo = tev:pivotocl::Variable {}
                        }
                    }
                } ++ _
            }
        },
        ir:Relation{},
        rd:RelationDomain{}
        ++ _
    }
    {
        ord <> rd
    };
    enforce domain core m:Mapping {
        domain = cd:CoreDomain {
            name = dn,
            typedModel = mdir:TypedModel {
                name = tmn,
                usedPackage = up,
                transformation = mt
            },
            isCheckable = c,
            isEnforceable = false,
            guardPattern = dg:GuardPattern {
                variable = dgVars:Set(pivotocl::Variable) {}
            },
            bottomPattern = db:BottomPattern {
                variable = dbVars:Set(pivotocl::Variable) {}
            }
        },
        bottomPattern = mb:BottomPattern {
            area = m
        }
    };
    when {
        RelationalTransformationToMappingTransformation(rt, mt);
    }
    where {
        whenVars = r.when.bindsTo;
        domainTopVars = domainVars->intersection(whenVars)->including(tev);
        sharedDomainVars = getSharedDomainVars(r);
        domainBottomUnSharedVars = (domainVars - whenVars - sharedDomainVars)->excluding(tev);
        domainBottomSharedVars =
        (domainVars - whenVars)->intersection(sharedDomainVars)->excluding(tev);
        seqForDomainPtrn = Sequence{r, te};

        RVarSetToMVarSet(domainTopVars->asSequence(), dgVars);
        RVarSetToMVarSet(domainBottomUnSharedVars->asSequence(), dbVars);
        RVarSetToMBVarSet(domainBottomSharedVars->asSequence(), mb);
        RDomainPatternToMDBottomPattern(seqForDomainPtrn, db);
        }
    }

-- opposite domains of an invoked relation's enforced domain are mapped as per rules
-- 4.2 and 4.5
--
relation TROppositeDomainsToMappingForEnforcement
{
    sharedDomainVars:Set(pivotocl::Variable);
    domainTopVars: Set(pivotocl::Variable);
    domainBottomUnSharedVars: Set(pivotocl::Variable);
    domainBottomSharedVars: Set(pivotocl::Variable);
    seqForDomainPtrn: Sequence(pivotocl::Element);
    dn, tmn: String;
    c: Boolean;
    mbVars:Set(pivotocl::Variable);
    whenVars:Set(pivotocl::Variable);
    rt: qvtrelation::RelationalTransformation;
    mt: qvtbase::Transformation;
    up: pivotocl::Package;

    domain relations oppDomainSeq:Sequence(pivotocl::Element) {
        r:Relation {
            domain = rds:Set(RelationDomain) {
                ord:RelationDomain {
                    name = dn,
                    typedModel = dir:TypedModel {
                        name = tmn,
                        usedPackage = up,
                        transformation = rt
                    },
                    isCheckable = c,
                    pattern = dp:DomainPattern {
                        bindsTo = domainVars:Set(pivotocl::Variable) {},
                        templateExpression = te:ObjectTemplateExp {}
                    }
                } ++ _
            }
        },
        rd:RelationDomain{}
        ++ _
    }
    {
        ord <> rd
    };
    enforce domain core m:Mapping {
        domain = cd:CoreDomain {
            name = dn,
            typedModel = mdir:TypedModel {
                name = tmn,
                usedPackage = up,
                transformation = mt
            },
            isCheckable = c,
            isEnforceable = false,
            guardPattern = dg:GuardPattern {
                variable = dgVars:Set(pivotocl::Variable) {},
                area = cd
            },
            bottomPattern = db:BottomPattern {
                variable = dbVars:Set(pivotocl::Variable) {}
            }
        },
        bottomPattern = mb:BottomPattern {
        area = m
        }
    };
    when {
        RelationalTransformationToMappingTransformation(rt, mt);
    }
    where {
        whenVars = r.when.bindsTo;
        domainTopVars = domainVars->intersection(whenVars);
        sharedDomainVars = getSharedDomainVars(r);
        domainBottomUnSharedVars = domainVars - whenVars - sharedDomainVars;
        domainBottomSharedVars =
        (domainVars - whenVars)->intersection(sharedDomainVars);
        seqForDomainPtrn = Sequence{r, te};

        RVarSetToDGVarSet(domainTopVars->asSequence(), dg);
        RVarSetToMBVarSet(domainBottomUnSharedVars->asSequence(), db);
        RVarSetToMBVarSet(domainBottomSharedVars->asSequence(), mb);
        RDomainPatternToMDBottomPattern(seqForDomainPtrn, db);
    }
}

relation RWhenPatternToMGuardPattern
{
    allDomainVars: Set(pivotocl::Variable);
    unsharedWhenVars: Set(pivotocl::Variable);

    domain relations r:Relation{
        when = whenp:Pattern {
            bindsTo = whenVars:Set(pivotocl::Variable) {}
        }
    };
    enforce domain core mg:GuardPattern {};
    where {
        allDomainVars = r.domain->iterate(md; acc:Set(qvtrelation::RelationDomain)=Set{} |
        acc->including(md.oclAsType(qvtrelation::RelationDomain))).pattern.bindsTo->asSet();
        unsharedWhenVars = whenVars - allDomainVars;

        RWhenRelCallToMGuard(whenp, mg);
        RSimplePatternToMPattern(whenp, mg);
        UnsharedWhenVarsToMgVars(unsharedWhenVars, mg);
    }
}

relation RVarSetToMVarSet
{
    rvRest: Sequence(pivotocl::Variable);
    mvRest: Set(pivotocl::Variable);

    domain relations rvSeq:Sequence(pivotocl::Variable) {
        rv:pivotocl::Variable {}
        ++ rvRest};
    enforce domain core mvSet:Set(pivotocl::Variable) {
        mv:pivotocl::Variable {}
        ++ mvRest};
    where {
        RVarToMVar(rv, mv);
        if (rvRest->isEmpty())
        then
            mvRest = Set{}
        else
            RVarSetToMVarSet(rvRest, mvRest)
        endif;
    }
}

relation RVarSetToMBVarSet
{
    rvRest: Sequence(pivotocl::Variable);
    mvRest: Set(pivotocl::Variable);

    domain relations rvSeq:Sequence(pivotocl::Variable) {
        rv:pivotocl::Variable {}
        ++ rvRest};
    enforce domain core mb:BottomPattern {
        variable = mv:pivotocl::Variable {}
    };
    where {
        RVarToMVar(rv, mv);
        RVarSetToMBVarSet(rvRest, mb);
    }
}

relation RVarSetToDGVarSet
{
    rvRest: Sequence(pivotocl::Variable);
    mvRest: Set(pivotocl::Variable);

    domain relations rvSeq:Sequence(pivotocl::Variable) {
        rv:pivotocl::Variable {}
        ++ rvRest};
    enforce domain core dg:GuardPattern {
        variable = mv:pivotocl::Variable {}
    };
    where {
        RVarToMVar(rv, mv);
        RVarSetToDGVarSet(rvRest, dg);
    }
}

relation RVarToMVar
{
    n: String;

    domain relations rv:pivotocl::Variable {
        name=n,
        type=t:Type {}
    };
    enforce domain core mv:pivotocl::Variable {
        name=n,
        type=t
    };
}

relation RVarToMRealizedVar
{
    n: String;

    domain relations rv:pivotocl::Variable {
        name=n,
        type=t:Type {}
    };
    enforce domain core mv:RealizedVariable {
        name=n,
        type=t
    };
}

relation RSimplePatternToMPattern
{
    domain relations rp:Pattern {
        predicate = pd:Predicate {
            conditionExpression = re:pivotocl::OCLExpression {}
        }
    }
    {
        not re.oclIsTypeOf(RelationCallExp)
    };
    enforce domain core mp:Pattern {
        predicate = mpd:Predicate{
            conditionExpression = me:pivotocl::OCLExpression {}
        }
    };
    where {
        RExpToMExp(re, me);
    }
}

-- Relation invocation in when clause maps to a trace class pattern in mapping guard.
-- Relation call argument position corresponds to the domain position in the invoked relation.
-- Domain's root pattern object var gives us the corresponding trace class prop.
--
relation RWhenRelCallToMGuard
{
    vdId:String;
    
    domain relations rp:Pattern {
        predicate = pd:Predicate {
            conditionExpression = e:RelationCallExp {
                referredRelation = r:Relation {
                    domain = dseq:Sequence(RelationDomain) {}
                },
                argument = aseq:Sequence(pivotocl::VariableExp) {}
        }
    }
};
    enforce domain core mp:GuardPattern {};
    where {
        vdId = aseq->iterate(a; s:String = '' | s.concat('_'.concat(a.referredVariable.name)));
        aseq->forAll( a | RWhenRelCallArgToMGuardPredicate( Sequence{r, a, dseq->at(aseq->indexOf(a)), vdId}, mp) );
    }
}

relation RWhenRelCallArgToMGuardPredicate
{
    tc: pivotocl::Class;
    dvn: String;
    mv:pivotocl::Variable;

    domain relations daSeq:Sequence(pivotocl::Element) {
        r:Relation{},
        ve:pivotocl::VariableExp {
            referredVariable = v:pivotocl::Variable {}
        },
        d:RelationDomain {
            rootVariable = dv:pivotocl::Variable {
                name = dvn
            }
        },
        vdId:String {}
        ++ _
    };
    enforce domain core mg:GuardPattern {
        variable = vd:pivotocl::Variable {
            name = tc.name + vdId + '_v',
            type = tc
        },
        predicate = mgp:Predicate {
            conditionExpression = ee:pivotocl::OperationCallExp {   -- vd.dvn = mv
                ownedSource = pe:pivotocl::PropertyCallExp {
                    ownedSource = pve:pivotocl::VariableExp {
                        referredVariable = vd
                    },
                    referredProperty = pep:pivotocl::Property {
                        name = dvn,
                        owningClass = vd.type.oclAsType(pivotocl::Class)
                    }
                },
                referredOperation = eo:pivotocl::Operation {
                    name = '='
                },
                ownedArguments = ave:pivotocl::VariableExp {
                    referredVariable = mv
                }
            }
        }
    };
    when {
    RelationToTraceClass(r, tc);
    }
    where {
    RVarToMVar(v, mv);
    }
}

-- invocation argument position corresponds to the domain position in invoked relation.
-- Invocation argument variable name gives the invoker trace class prop name;
-- Domain's root pattern object var gives us core domain guard var
--
relation RInvokerToMGuard
{
    domain relations seqForInvoker:Sequence(pivotocl::Element) {
        ir:Relation {},   -- invoking relation
        ri:RelationCallExp {
            argument = aseq:Sequence(pivotocl::VariableExp) {}
        },
        r:Relation {   -- invoked relation
            domain = dseq:Sequence(RelationDomain) {}
        }
        ++ _
    };
    enforce domain core mg:GuardPattern {};
    where {
        aseq->forAll( a | RInvokerToMGuardPredicate( Sequence{ ir, a, dseq->at(aseq->indexOf(a)) }, mg) );
    }
}

relation RInvokerToMGuardPredicate
{
    vn: String;
    tc: pivotocl::Class;
    mdv: pivotocl::Variable;

    domain relations seqForInvoker:Sequence(pivotocl::Element) {
        ir:Relation {},   -- invoking relation
        ve:pivotocl::VariableExp {
            referredVariable = v:pivotocl::Variable {
                name=vn
            }
        },
        d:RelationDomain {
            rootVariable = dv:pivotocl::Variable {}
        }
    ++ _
    };
    enforce domain core mg:GuardPattern {
        variable = vd:pivotocl::Variable {
            name = tc.name+'_v',
            type = tc
        },
        predicate = pd:Predicate {
            conditionExpression = ee:pivotocl::OperationCallExp {   -- vd.vn = mdv
                ownedSource = pe:pivotocl::PropertyCallExp {
                    ownedSource = mve:pivotocl::VariableExp {
                        referredVariable = vd
                    },
                    referredProperty = pep:pivotocl::Property {
                        name = vn,
                        owningClass = vd.type.oclAsType(pivotocl::Class)
                    }
                },
                referredOperation = eo:pivotocl::Operation {
                    name = '='
                },
                ownedArguments = ave:pivotocl::VariableExp {
                    referredVariable = mdv
                }
            }
        }
    };
    when {
        RelationToTraceClass(ir, tc);
    }
    where {
        RVarToMVar(dv, mdv);
    }
}

relation RDomainPatternToMDBottomPattern
{
    domain relations seqForDomainPtrn:Sequence(pivotocl::Element) {};
    enforce domain core db:BottomPattern {
        area = cd:CoreDomain {
            rule = m:Mapping {
                bottomPattern = mb:BottomPattern {
                    area = m
                }
            }
        }
    };   -- domain bottom
    where {
        RDomainPatternToMDBottomPatternComposite(seqForDomainPtrn, db);
        RDomainPatternToMDBottomPatternSimpleNonVarExpr(seqForDomainPtrn, db);
        RDomainPatternToMDBottomPatternSimpleUnSharedVarExpr(seqForDomainPtrn, db);
        RDomainPatternToMDBottomPatternSimpleSharedVarExpr(seqForDomainPtrn, mb);
    }
}

relation RDomainToMDBottomForEnforcement
{
    remainingUnBoundDomainVars: Set(pivotocl::Variable);
    predicatesWithVarBindings:Set(qvtbase::Predicate);
    remainingPredicatesWithoutVarBindings:Set(qvtbase::Predicate);
    rdSeq, rtSeq, rtdSeq: Sequence(pivotocl::Element);
    rdtVarsSeqRest: Sequence(Set(pivotocl::Element));
    predicatesWithoutVarBindings:Set(qvtbase::Predicate);
    unboundDomainVars:Set(pivotocl::Variable);
    tcv, mv: pivotocl::Variable;

    domain relations rdtVarsSeq:Sequence(Set(pivotocl::Element)) {
        rdtSet:Set(pivotocl::Element) {
            r:Relation{},
            rd:RelationDomain{},
            te:ObjectTemplateExp {
                bindsTo = v:pivotocl::Variable {}
            }
            ++ _
        }
        ++ _
    };
    enforce domain core db:BottomPattern {   -- domain bottom
        area = cd:CoreDomain {
            rule = m:Mapping {
                bottomPattern = mb:BottomPattern {
                    area = m
                }
            }
        }
    };
    where {
        rdtVarsSeq->at(2) = predicatesWithoutVarBindings;
        rdtVarsSeq->at(3) = unboundDomainVars;

        remainingUnBoundDomainVars = unboundDomainVars - Set{v};
        predicatesWithVarBindings = filterOutPredicatesThatReferToVars(
        predicatesWithoutVarBindings, remainingUnBoundDomainVars);

        remainingPredicatesWithoutVarBindings =
        predicatesWithoutVarBindings - predicatesWithVarBindings;
        rtSeq = Sequence{r, te};
        rtdSeq = Sequence{r, te, rd};
        rdtVarsSeqRest = Sequence{rdtSet, remainingPredicatesWithoutVarBindings, remainingUnBoundDomainVars};

        RDomainToMDBottomForEnforcementOfIdentityProp(rtSeq, db);
        RDomainVarToMDBottomAssignmnetForEnforcement(rdtVarsSeq, mb);
        --RDomainToMDBottomForEnforcementOfIdentityPropObject(rdtSeq, mb);
        RDomainToMDBottomForEnforcementOfNonIdentityPropPrimitive(rtdSeq, m);
        RDomainToMDBottomForEnforcementOfNonIdentityPropObject(rdtVarsSeqRest, m);
        RDomainToMBottomPredicateForEnforcement(rdtVarsSeq, mb);
    }
}

relation RDomainVarToMDBottomAssignmnetForEnforcement
{
    rdSeq : Sequence(pivotocl::Element);
    mv: pivotocl::Variable;

    domain relations rdtVarsSeq:Sequence(Set(pivotocl::Element)) {
        rdtSet:Set(pivotocl::Element) {
            r:Relation{},
            rd:RelationDomain{},
            te:ObjectTemplateExp {
                bindsTo = v:pivotocl::Variable {}
            }
            ++ _
        }
        ++ _
    };
    enforce domain core mb:BottomPattern {   -- mapping bottom
        realizedVariable = tcv:RealizedVariable {},   -- added this to correctly add the trace variable
        assignment = a:PropertyAssignment {
            slotExpression = ve1:pivotocl::VariableExp {
                referredVariable = tcv
            },
            targetProperty = tp:pivotocl::Property {
                name = v.name,
                owningClass = tcv.type.oclAsType(pivotocl::Class)
            },
            value = ve2:pivotocl::VariableExp {
                referredVariable = mv
            }
        }
    };
    where {
        rdSeq = Sequence{r, rd};
        RelationDomainToTraceClassVar(rdSeq, tcv);
        RVarToMVar(v, mv);
    }
}

relation RDomainToMBottomPredicateForEnforcement
{
    remainingUnBoundDomainVars: Set(pivotocl::Variable);
    predicatesWithVarBindings:Set(qvtbase::Predicate);
    rdSeq: Sequence(pivotocl::Element);
    predicatesWithoutVarBindings:Set(qvtbase::Predicate);
    unboundDomainVars:Set(pivotocl::Variable);
    tcv, mv: pivotocl::Variable;

    domain relations rdtVarsSeq:Sequence(Set(pivotocl::Element)) {
        rdtSet:Set(pivotocl::Element) {
            r:Relation {},
            rd:RelationDomain {},
            te:ObjectTemplateExp {
                bindsTo = v:pivotocl::Variable {}
            }
            ++ _
        }
        ++ _
    };
    enforce domain core mb:BottomPattern {
        predicate = pd:Predicate {
            conditionExpression = ee:pivotocl::OperationCallExp {   -- tcv.(v.name) = mv
                ownedSource = pe:pivotocl::PropertyCallExp {
                    --source = tcv,
                    ownedSource = pve:pivotocl::VariableExp {
                        referredVariable = tcv
                    },
                    referredProperty = pep:pivotocl::Property {
                        name = v.name,
                        owningClass = tcv.type.oclAsType(pivotocl::Class)
                    }
                },
                referredOperation = eo:pivotocl::Operation {
                    name = '='
                },
                ownedArguments = ave:pivotocl::VariableExp {
                    referredVariable = mv
                }
            }
        }
    };
    where {
        rdSeq = let s : Sequence(pivotocl::Element) = Sequence{} in s->append(r)->append(rd);
        RelationDomainToTraceClassVar(rdSeq, tcv);
        RVarToMVar(v, mv);

        rdtVarsSeq->at(2) = predicatesWithoutVarBindings;
        rdtVarsSeq->at(3) = unboundDomainVars;

        remainingUnBoundDomainVars = unboundDomainVars - Set{v};
        predicatesWithVarBindings = filterOutPredicatesThatReferToVars(
        predicatesWithoutVarBindings, remainingUnBoundDomainVars);

        RPredicateSetToMBPredicateSet(predicatesWithVarBindings->asSequence(), mb);
    }
}

relation RPredicateSetToMBPredicateSet
{
    rpRest: Sequence(qvtbase::Predicate);

    domain relations predSeq:Sequence(Predicate) {
        rp:Predicate {
        conditionExpression = re:pivotocl::OCLExpression {}
        }
        ++ rpRest
    };
    enforce domain core mb:BottomPattern {
        predicate = mp:Predicate {
            conditionExpression = me:pivotocl::OCLExpression {}
        }
    };
    where {
        RExpToMExp(re, me);
        RPredicateSetToMBPredicateSet(rpRest, mb);
    }
}

relation RDomainToMDBottomForEnforcementOfIdentityProp
{
    seqForAssignment: Sequence(pivotocl::Element);

    domain relations rtSeq:Sequence(pivotocl::Element) {
        r:Relation {},
        te:ObjectTemplateExp {
            bindsTo = v:pivotocl::Variable {
                type=c:Class {}
            },
            part = pt:PropertyTemplateItem {
                referredProperty = pp:pivotocl::Property {},
                value = e:pivotocl::OCLExpression {}
            }
        }
        {
            c.key.part->includes(pp)
        }
        ++ _
    };
    enforce domain core db:BottomPattern {
        area = cd:CoreDomain {
            rule = m:Mapping {
                bottomPattern = mb:BottomPattern{
                    area = m
                }
            }
        }
    };   -- domain bottom
    where {
        seqForAssignment = Sequence{r, v, pp, e};
        
        RDomainPatternExprToMappingDomainAssignment(seqForAssignment, db);
        RDomainPatternExprToMappingDomainVarAssignment(seqForAssignment, db);
        RDomainPatternExprToMappingDomainTemplateVarAssignment(seqForAssignment, db);
        RDomainPatternExprToMappingBottomVarAssignment(seqForAssignment, mb);
    }
}

relation RDomainToMDBottomForEnforcementOfIdentityPropObject
{
    seqForAssignment: Sequence(pivotocl::Element);
    mtv, tcv : pivotocl::Variable;
    rdSeq : Sequence(pivotocl::Element);

    domain relations rtSeq:Sequence(pivotocl::Element) {
        r:Relation {},
        rd:RelationDomain{},
        te:ObjectTemplateExp {
            bindsTo = v:pivotocl::Variable {
                type=c:Class {}
            },
            part = pt:PropertyTemplateItem {
                referredProperty = pp:pivotocl::Property {},
                value = e:ObjectTemplateExp {
                    bindsTo = tv:pivotocl::Variable {}
                }
            }
        }
        {
            c.key.part->includes(pp)
        }
        ++ _
    };
    enforce domain core mb:BottomPattern {
        assignment = a:PropertyAssignment {
            slotExpression = ve1:pivotocl::VariableExp {
                referredVariable = tcv
            },
            targetProperty = tp:pivotocl::Property {
                name = tv.name,
                owningClass = tcv.type.oclAsType(pivotocl::Class)
            },
            value = ve2:pivotocl::VariableExp {
                referredVariable = mtv
            }
        }
    };   -- domain bottom
    where {
        rdSeq = Sequence{r, rd};
        
        RelationDomainToTraceClassVar(rdSeq, tcv);
        RVarToMVar(tv, mtv);
    }
}

relation RDomainPatternExprToMappingDomainAssignment
{
    pn: String;
    mv: pivotocl::Variable;

    domain relations seqForAssignment: Sequence(pivotocl::Element) {
        _,
        v:pivotocl::Variable {},
        pp:pivotocl::Property {
            name = pn
        },
        e:pivotocl::OCLExpression {} {
            not e.oclIsTypeOf(pivotocl::VariableExp) and not e.oclIsTypeOf(ObjectTemplateExp)
        }
        ++ _
    };
    enforce domain core db:BottomPattern {
        assignment = a:PropertyAssignment {
            slotExpression = ve:pivotocl::VariableExp {
                referredVariable = mv
            },
            targetProperty = tp:pivotocl::Property {
                name = pn,
                owningClass = mv.type.oclAsType(pivotocl::Class)
            },
            value = me:pivotocl::OCLExpression {}
        }
    };
    where {
        RVarToMVar(v, mv);
        RExpToMExp(e, me);
    }
}

relation RDomainPatternExprToMappingDomainVarAssignment
{
    sharedDomainVars: Set(pivotocl::Variable);
    rev, mev : pivotocl::Variable;
    pn: String;

    domain relations seqForAssignment: Sequence(pivotocl::Element) {
        r:Relation {},
        v:pivotocl::Variable {},
        pp:pivotocl::Property {
            name = pn
        },
        e:pivotocl::VariableExp {
            referredVariable = rev
        }
        ++ _
    }
    {
        not sharedDomainVars->includes(e.referredVariable)
    };
    enforce domain core db:BottomPattern {
        realizedVariable = mv:RealizedVariable {},
        assignment = a:PropertyAssignment {
            slotExpression = ve:pivotocl::VariableExp {
                referredVariable = mv
            },
            targetProperty = tp:pivotocl::Property {
                name = pn,
                owningClass = mv.type.oclAsType(pivotocl::Class)
            },
            value = me:pivotocl::VariableExp {
                referredVariable = mev
            }
        }
    };
    when {
        sharedDomainVars = getSharedDomainVars(r);
    }
    where {
        RVarToMRealizedVar(v, mv);
        RVarToMVar(rev, mev);
    }
}

relation RDomainPatternExprToMappingDomainTemplateVarAssignment
{
    sharedDomainVars: Set(pivotocl::Variable);
    rev, mev: pivotocl::Variable;
    pn: String;

    domain relations seqForAssignment: Sequence(pivotocl::Element) {
        r:Relation {},
        v:pivotocl::Variable {},
        pp:pivotocl::Property {
            name = pn
        },
        e:ObjectTemplateExp {
            bindsTo = rev
        }
        ++ _
        }
        {
            not sharedDomainVars->includes(rev)
        };
    enforce domain core db:BottomPattern {
        realizedVariable = mv:RealizedVariable {},
        assignment = a:PropertyAssignment {
            slotExpression = ve:pivotocl::VariableExp {
                referredVariable = mv
            },
            targetProperty = tp:pivotocl::Property {
                name = pn,
                owningClass = mv.type.oclAsType(pivotocl::Class)
            },
            value = me:pivotocl::VariableExp {
                referredVariable = mev }
        }
    };
    when {
        sharedDomainVars = getSharedDomainVars(r);
    }
    where {
        RVarToMRealizedVar(v, mv);
        RVarToMVar(rev, mev);
    }
}

relation RDomainPatternExprToMappingBottomVarAssignment
{
    sharedDomainVars: Set(pivotocl::Variable);
    rev, mev, mv : pivotocl::Variable;
    pn: String;

    domain relations seqForAssignment: Sequence(pivotocl::Element) {
        r:Relation {},
        v:pivotocl::Variable {},
        pp:pivotocl::Property {
            name = pn
        },
        e:pivotocl::VariableExp {
            referredVariable = rev
        }
        ++ _
    }
    {
        sharedDomainVars->includes(e.referredVariable)
    };
    enforce domain core mb:BottomPattern {   -- mapping bottom
        -- realizedVariable = mv:RealizedVariable {}, -- the RV belongs to the domain bottom!
        assignment = a:PropertyAssignment {
            slotExpression = ve:pivotocl::VariableExp {
                referredVariable = mv
            },
            targetProperty = tp:pivotocl::Property {
                name = pn,
                owningClass = mv.type.oclAsType(pivotocl::Class)
            },
            value = me:pivotocl::VariableExp {
                referredVariable = mev
            }
        }
    };
    when {
        sharedDomainVars = getSharedDomainVars(r);
    }
    where {
        RVarToMRealizedVar(v, mv);
        RVarToMVar(rev, mev);
    }
}

relation RDomainToMDBottomForEnforcementOfNonIdentityPropPrimitive
{
    pn: String;
    mv: pivotocl::Variable;
    rtdeSeq: Sequence(pivotocl::Element);

    domain relations rtdSeq:Sequence(pivotocl::Element) {
        r:Relation {
            transformation = rt:RelationalTransformation {}
        },
        te:ObjectTemplateExp {
            bindsTo = v:pivotocl::Variable {type = c:Class {}},
            part = pt:PropertyTemplateItem {
            	referredProperty = pp:pivotocl::Property {name = pn},
            	value = e:pivotocl::OCLExpression {}
            }
        }
        {
            (not c.key.part->includes(pp)) and (not e.oclIsKindOf(TemplateExp))
        },
        rd:RelationDomain {
            pattern = rdp:DomainPattern {
                templateExpression = rdt:ObjectTemplateExp {}
            }
        }
        ++ _
    };
    enforce domain core m:Mapping {
        local = cm:Mapping {
            name = m.name+'_forNonIdentityProp',
            transformation = mt:Transformation{},
            guardPattern = gp:GuardPattern {
                area = cm
            },
            bottomPattern = bp:BottomPattern {
                area = cm,
                assignment = a:PropertyAssignment {
                    slotExpression = ve:pivotocl::VariableExp {
                        referredVariable = mv
                    },
                    targetProperty = tp:pivotocl::Property {
                        name = pn,
                        owningClass = mv.type.oclAsType(pivotocl::Class)
                    },
                    value = me:pivotocl::OCLExpression {}
                }
            }
        }
    };
    when {
        RelationalTransformationToMappingTransformation(rt, mt);
    }
    where {
    RVarToMVar(v, mv);
    RExpToMExp(e, me);

    rtdeSeq = Sequence{r, te, rd, e};
    -- if this rule fails, the local mapping ends with no guard pattern, so
    -- I added the gp to cm patterns..
    RDomainToMComposedMappingGuard(rtdeSeq, cm);
    }
}

relation RDomainToMComposedMappingGuard
{
    dn, tmn: String;
    tcv, mv: pivotocl::Variable;
    rdSeq: Sequence(pivotocl::Element);
    mt: qvtbase::Transformation;

    domain relations rtdSeq:Sequence(pivotocl::Element) {
        r:Relation {
            transformation = rt:RelationalTransformation{}
        },
        te:ObjectTemplateExp {},
        rd:RelationDomain {
            name = dn,
            typedModel = dir:TypedModel {
                name = tmn,
                usedPackage = up:pivotocl::Package{},
                transformation = rt
            },
            pattern = rdp:DomainPattern {
                templateExpression = rdt:ObjectTemplateExp {}
            }
        },
        ve:pivotocl::VariableExp {
            referredVariable = v:pivotocl::Variable {}
        }
        ++ _
    }
    {
        isVarBoundToSomeOtherTemplate(rdt, te, v)
    };
    enforce domain core cm:Mapping {
        guardPattern = mg:GuardPattern {
            predicate = pd:Predicate {
                conditionExpression = ee:pivotocl::OperationCallExp {   -- vd.vn = mdv
                    ownedSource = pe:pivotocl::PropertyCallExp {
                        ownedSource = ve1:pivotocl::VariableExp {
                            referredVariable = tcv
                        },
                        referredProperty = tp:pivotocl::Property {
                            name = mv.name,
                            owningClass = mv.type.oclAsType(pivotocl::Class)
                        }
                    },
                    referredOperation = eo:pivotocl::Operation {
                        name = '='
                    },
                    ownedArguments = ve2:pivotocl::VariableExp {
                        referredVariable = mv
                    }
                }
            }
        },
        domain = cd:CoreDomain {
            name = dn,
            typedModel = mdir:TypedModel {
                name = tmn,
                usedPackage = up,
                transformation = mt
            },
            guardPattern = cmdg:GuardPattern {
                variable = mv
            }
        }
    };
    when {
        RelationalTransformationToMappingTransformation(rt, mt);
    }
    where {
        rdSeq = Sequence{r, rd};
        
        RelationDomainToTraceClassVar(rdSeq, tcv);
        RVarToMVar(v, mv);
    }
}

relation RDomainToMDBottomForEnforcementOfNonIdentityPropObject
{
    rdtSetNext: Set(pivotocl::Element);
    rdtVarsSeqRest: Sequence(Set(pivotocl::Element));
    predicatesWithoutVarBindings:Set(qvtbase::Predicate);
    unboundDomainVars:Set(pivotocl::Variable);
    dn, pn, tmn: String;
    mv: pivotocl::Variable;

    domain relations rdtVarsSeq:Sequence(Set(pivotocl::Element)) {
        rdtSet:Set(pivotocl::Element) {
            r:Relation { 
                transformation = rt:RelationalTransformation {}
            },
                rd:RelationDomain {
                name = dn,
                typedModel = dir:TypedModel {
                    name = tmn,
                    usedPackage = up:pivotocl::Package {},
                    transformation = rt
                }
            },
            te:ObjectTemplateExp {
                bindsTo = v:pivotocl::Variable {
                    type = c:Class {}
                },
                part = pt:PropertyTemplateItem {
                    referredProperty = pp:pivotocl::Property {
                        name = pn
                    },
                    value = pte:ObjectTemplateExp {
                        bindsTo = pv:pivotocl::Variable {}
                    }
                }
            }
            {
                not c.key.part->includes(pp)
            }
            ++ _
        }
        ++ _
    };
    enforce domain core m:Mapping {
        local = cm:Mapping {
            name = m.name+'_for_'+pv.name,
            transformation = mt:Transformation{},
            domain = cd:CoreDomain {
                name = dn,
                isEnforceable = true,
                typedModel = mdir:TypedModel {
                    name = tmn,
                    usedPackage = up,
                    transformation = mt
                },
                bottomPattern = cmdb:BottomPattern {
                    realizedVariable = mpv:RealizedVariable {},
                    assignment = a:PropertyAssignment {
                        slotExpression = ve1:pivotocl::VariableExp {
                            referredVariable = mv
                        },
                        targetProperty = tp:pivotocl::Property {
                            name = pn,
                            owningClass = mv.type.oclAsType(pivotocl::Class)
                        },
                        value = ve2:pivotocl::VariableExp {
                            referredVariable = mpv
                        }
                    }
                }
            },
            bottomPattern = mb:BottomPattern {
                area = cm
            }
        }
    };
    when {
        RelationalTransformationToMappingTransformation(rt, mt);
    }
    where {
        RVarToMVar(v, mv);
        RVarToMRealizedVar(pv, mpv);

        rdtVarsSeq->at(2) = predicatesWithoutVarBindings;
        rdtVarsSeq->at(3) = unboundDomainVars;

        rdtSetNext = Set{r, rd, pte};
        rdtVarsSeqRest = Sequence{rdtSetNext, predicatesWithoutVarBindings, unboundDomainVars};
        RDomainToMDBottomForEnforcement(rdtVarsSeqRest, cmdb);
    }
}

relation RDomainPatternToMDBottomPatternComposite
{
    nextSeqForDomainPtrn: Sequence(pivotocl::Element);
    sharedDomainVars:Set(pivotocl::Variable);
    pn: String;
    mvte, mvpte: pivotocl::Variable;

    domain relations seqForDomainPtrn:Sequence(pivotocl::Element) {
        r:Relation {},
        te:ObjectTemplateExp {
            bindsTo = vte:pivotocl::Variable {},
            part = pt:PropertyTemplateItem {
                referredProperty = pp:pivotocl::Property {
                    name = pn
                },
                value = pte:ObjectTemplateExp {
                    bindsTo = vpte:pivotocl::Variable {}
                }
            }
        }
        ++ _
    };
    enforce domain core db:BottomPattern {
        assignment = a:PropertyAssignment {
            slotExpression = ve1:pivotocl::VariableExp {
                referredVariable = mvte
            },
            targetProperty = tp:pivotocl::Property {
                name = pn,
                owningClass = mvte.type.oclAsType(pivotocl::Class)
            },
            value = ve2:pivotocl::VariableExp {
                referredVariable = mvpte
            }
        }
    };
    where {
        nextSeqForDomainPtrn = Sequence{r, pte};
        
        RVarToMVar(vte, mvte);
        RVarToMVar(vpte, mvpte);
        RDomainPatternToMDBottomPattern(nextSeqForDomainPtrn, db);
    }
}

relation RDomainPatternToMDBottomPatternSimpleUnSharedVarExpr
{
    sharedDomainVars: Set(pivotocl::Variable);
    pn: String;
    mvte, mvpte: pivotocl::Variable;

    domain relations seqForDomainPtrn:Sequence(pivotocl::Element) {
        r:Relation{},
        te:ObjectTemplateExp {
            bindsTo = vte:pivotocl::Variable {},
            part = pt:PropertyTemplateItem {
                referredProperty = pp:pivotocl::Property {
                    name = pn
                },
                value = e:pivotocl::VariableExp {
                    referredVariable = vpte:pivotocl::Variable {}
                }
            }
        }
        ++ _
    }
    {
        not sharedDomainVars->includes(vpte)
    };
    enforce domain core db:BottomPattern {
        assignment = a:PropertyAssignment {
            slotExpression = ve1:pivotocl::VariableExp {
                referredVariable = mvte
            },
            targetProperty = tp:pivotocl::Property{
                name = pn,
                owningClass = mvte.type.oclAsType(pivotocl::Class)
            },
            value = ve2:pivotocl::VariableExp {
                referredVariable = mvpte
            }
        }
    };
    when {
        sharedDomainVars = getSharedDomainVars(r);
    }
    where {
        RVarToMVar(vte, mvte);
        RVarToMVar(vpte, mvpte);
    }
}

relation RDomainPatternToMDBottomPatternSimpleSharedVarExpr
{
    sharedDomainVars: Set(pivotocl::Variable);
    pn: String;
    mvte, mvpte: pivotocl::Variable;

    domain relations seqForDomainPtrn:Sequence(pivotocl::Element) {
        r:Relation{},
        te:ObjectTemplateExp {
            bindsTo = vte:pivotocl::Variable {},
            part = pt:PropertyTemplateItem {
                referredProperty = pp:pivotocl::Property {
                    name = pn
                },
                value = e:pivotocl::VariableExp {
                    referredVariable=vpte:pivotocl::Variable {}
                }
            }
        }
        ++ _
    }
    {
        sharedDomainVars->includes(vpte)
    };
    enforce domain core mb:BottomPattern {
        assignment = a:PropertyAssignment {
            slotExpression = ve1:pivotocl::VariableExp {
                referredVariable = mvte
            },
            targetProperty = tp:pivotocl::Property {
                name = pn,
                owningClass = mvte.type.oclAsType(pivotocl::Class)
            },
            value = ve2:pivotocl::VariableExp{
                referredVariable = mvpte
            }
        }
    };
    when {
        sharedDomainVars = getSharedDomainVars(r);
    }
    where {
        RVarToMVar(vte, mvte);
        RVarToMVar(vpte, mvpte);
    }
}

relation RDomainPatternToMDBottomPatternSimpleNonVarExpr
{
    pn: String;
    mvte: pivotocl::Variable;

    domain relations seqForDomainPtrn:Sequence(pivotocl::Element) {
        _,
        te:ObjectTemplateExp {
            bindsTo = vte:pivotocl::Variable {},
            part = pt:PropertyTemplateItem {
                referredProperty = pp:pivotocl::Property {
                    name = pn
                },
                value = e:pivotocl::OCLExpression {}
            }
        }
        ++ _
    }
    {
        not e.oclIsKindOf(TemplateExp) and not e.oclIsTypeOf(pivotocl::VariableExp)
    };
    enforce domain core db:BottomPattern {
        assignment = a:PropertyAssignment {
            slotExpression = ve:pivotocl::VariableExp {
                referredVariable = mvte
            },
            targetProperty = tp:pivotocl::Property {
                name = pn,
                owningClass = mvte.type.oclAsType(pivotocl::Class)
            },
            value = me:pivotocl::OCLExpression {}
        }
    };
    where {
        RVarToMVar(vte, mvte);
        RExpToMExp(e, me);
    }
}

relation RDomainVarsToTraceClassProps
{
    tcv, mdv: pivotocl::Variable;

    domain relations rd:RelationDomain {
        rule = r:Relation{},
        pattern = dp:DomainPattern {
            bindsTo = domainVars:Set(pivotocl::Variable) {
                dv:pivotocl::Variable {
                    templateExp = te: TemplateExp{}
                }
                ++_
            }
        }
    };
    enforce domain core mb:BottomPattern {
        assignment = a:PropertyAssignment {
            slotExpression = ve1:pivotocl::VariableExp {
                referredVariable = tcv
            },
            targetProperty = tp:pivotocl::Property {
                name = dv.name,
                owningClass = tcv.type.oclAsType(pivotocl::Class)
            },
            value = ve2:pivotocl::VariableExp {
                referredVariable = mdv
            }
        }
    };
    where {
        RelationToTraceClassVar(r, tcv);
        RVarToMVar(dv, mdv);
    }
}

relation ROppositeDomainVarsToTraceClassProps
{
    rdSeq: Sequence(pivotocl::Element);
    tcv, mdv: pivotocl::Variable;

    domain relations rdVarsSeq:Sequence(Set(pivotocl::Element)) {
        rdSet: Set(pivotocl::Element) {
            r:Relation {},
            rd:RelationDomain {}
            ++ _
        },
        domainVars:Set(pivotocl::Variable) {
            dv:pivotocl::Variable {
                templateExp = te:TemplateExp{}
            }
            ++ _
        }
        ++ _
    };
    enforce domain core mb:BottomPattern {
        assignment = a:PropertyAssignment {
            slotExpression = ve1:pivotocl::VariableExp {
                referredVariable = tcv
            },
            targetProperty = tp:pivotocl::Property {
                name = dv.name,
                owningClass = tcv.type.oclAsType(pivotocl::Class)
            },
            value = ve2:pivotocl::VariableExp {
                referredVariable = mdv
            }
        }
    };
    where {
        rdSeq = let s : Sequence(pivotocl::Element) = Sequence{} in s->append(r)->append(rd);
        RelationDomainToTraceClassVar(rdSeq, tcv);
        RVarToMVar(dv, mdv);
    }
}

relation RRelImplToMBottomEnforcementOperation
{
    emptySet:Set(qvtcorebase::EnforcementOperation);

    domain relations repImplSeq:Sequence(pivotocl::Element) {
        r:Relation {
            operationalImpl = ri:RelationImplementation {
                inDirectionOf = tm:TypedModel {},
                impl = op:pivotocl::Operation {}
            }
        },
        rd:RelationDomain {typedModel = tm:TypedModel{}}
        ++ _
    };
    enforce domain core mb:BottomPattern {
        enforcementOperation = eoSet:Set(EnforcementOperation) {
            eoc:EnforcementOperation {
                enforcementMode = EnforcementMode::Creation,
                operationCallExp = oce:pivotocl::OperationCallExp {
                    referredOperation = op
                }
            },
            eod:EnforcementOperation {
                enforcementMode = EnforcementMode::Deletion,
                operationCallExp = oce
            }
            ++ emptySet
        }
    }
    default_values {
        emptySet = Set{};
    };
    where {
        RRelDomainsToMOpCallArg(r, oce);
    }
}

relation RRelDomainsToMOpCallArg
{
    domain relations r:Relation {
        domain = rd:RelationDomain {
            pattern = p:DomainPattern {
                bindsTo = rv:pivotocl::Variable{}
            }
        }
    };
    enforce domain core oce:pivotocl::OperationCallExp {
        ownedArguments = ar:pivotocl::VariableExp {
            referredVariable = mv:pivotocl::Variable {}
        }
    };
    where {
        RVarToMVar(rv, mv);
    }
}

relation RelationToTraceClassVar
{
    rn: String;
    tc: pivotocl::Class;

    domain relations r:Relation {
        name = rn
    };
    enforce domain core tcv:RealizedVariable {
        name = rn+'_v',
        type = tc
    };
    when {
        RelationToTraceClass(r, tc);
    }
}

relation RelationDomainToTraceClassVar
{
    rn, dn: String;
    tc: pivotocl::Class;

    domain relations rdSeq:Sequence(pivotocl::Element) {
        r:Relation {
            name = rn
        },
        d:RelationDomain {
            name = dn
        }
        ++ _
    };
    enforce domain core tcv:RealizedVariable {
        name = rn+'_'+dn+'_v',
        type = tc
    };
    when {
        RelationToTraceClass(r, tc);
    }
}

-- copy an ocl expression
-- For space reasons this relation is not expanded out here
relation RExpToMExp
{
    domain relations re:pivotocl::OCLExpression {};
    enforce domain core me:pivotocl::OCLExpression {} /*implementedby CopyOclExpession(re, me)*/;
}

}