/*
 * generated by Xtext 2.10.0
 */
package org.eclipse.qvtd.doc.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.qvtd.doc.minioclcs.BooleanExpCS;
import org.eclipse.qvtd.doc.minioclcs.CallExpCS;
import org.eclipse.qvtd.doc.minioclcs.ClassCS;
import org.eclipse.qvtd.doc.minioclcs.ConstraintsDefCS;
import org.eclipse.qvtd.doc.minioclcs.IntLiteralExpCS;
import org.eclipse.qvtd.doc.minioclcs.InvariantCS;
import org.eclipse.qvtd.doc.minioclcs.LogicExpCS;
import org.eclipse.qvtd.doc.minioclcs.MinioclcsPackage;
import org.eclipse.qvtd.doc.minioclcs.NameExpCS;
import org.eclipse.qvtd.doc.minioclcs.OperationCS;
import org.eclipse.qvtd.doc.minioclcs.PackageCS;
import org.eclipse.qvtd.doc.minioclcs.ParameterCS;
import org.eclipse.qvtd.doc.minioclcs.PathElementCS;
import org.eclipse.qvtd.doc.minioclcs.PathNameCS;
import org.eclipse.qvtd.doc.minioclcs.PropertyCS;
import org.eclipse.qvtd.doc.minioclcs.RootCS;
import org.eclipse.qvtd.doc.minioclcs.RoundedBracketClauseCS;
import org.eclipse.qvtd.doc.minioclcs.StringLiteralExpCS;
import org.eclipse.qvtd.doc.services.MiniOCLCSGrammarAccess;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MiniOCLCSSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MiniOCLCSGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MinioclcsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MinioclcsPackage.BOOLEAN_EXP_CS:
				sequence_BooleanLiteralExpCS(context, (BooleanExpCS) semanticObject); 
				return; 
			case MinioclcsPackage.CALL_EXP_CS:
				sequence_CallExpCS(context, (CallExpCS) semanticObject); 
				return; 
			case MinioclcsPackage.CLASS_CS:
				sequence_ClassCS(context, (ClassCS) semanticObject); 
				return; 
			case MinioclcsPackage.CONSTRAINTS_DEF_CS:
				sequence_ConstraintsDefCS(context, (ConstraintsDefCS) semanticObject); 
				return; 
			case MinioclcsPackage.INT_LITERAL_EXP_CS:
				sequence_IntLiteralExpCS(context, (IntLiteralExpCS) semanticObject); 
				return; 
			case MinioclcsPackage.INVARIANT_CS:
				sequence_InvariantCS(context, (InvariantCS) semanticObject); 
				return; 
			case MinioclcsPackage.LOGIC_EXP_CS:
				sequence_LogicExpCS(context, (LogicExpCS) semanticObject); 
				return; 
			case MinioclcsPackage.NAME_EXP_CS:
				sequence_NameExpCS(context, (NameExpCS) semanticObject); 
				return; 
			case MinioclcsPackage.OPERATION_CS:
				sequence_OperationCS(context, (OperationCS) semanticObject); 
				return; 
			case MinioclcsPackage.PACKAGE_CS:
				sequence_PackageCS(context, (PackageCS) semanticObject); 
				return; 
			case MinioclcsPackage.PARAMETER_CS:
				sequence_ParameterCS(context, (ParameterCS) semanticObject); 
				return; 
			case MinioclcsPackage.PATH_ELEMENT_CS:
				sequence_PathElementCS(context, (PathElementCS) semanticObject); 
				return; 
			case MinioclcsPackage.PATH_NAME_CS:
				sequence_PathNameCS(context, (PathNameCS) semanticObject); 
				return; 
			case MinioclcsPackage.PROPERTY_CS:
				sequence_PropertyCS(context, (PropertyCS) semanticObject); 
				return; 
			case MinioclcsPackage.ROOT_CS:
				sequence_RootCS(context, (RootCS) semanticObject); 
				return; 
			case MinioclcsPackage.ROUNDED_BRACKET_CLAUSE_CS:
				sequence_RoundedBracketClauseCS(context, (RoundedBracketClauseCS) semanticObject); 
				return; 
			case MinioclcsPackage.STRING_LITERAL_EXP_CS:
				sequence_StringLiteralExpCS(context, (StringLiteralExpCS) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ExpCS returns BooleanExpCS
	 *     LogicExpCS returns BooleanExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns BooleanExpCS
	 *     CallExpCS returns BooleanExpCS
	 *     CallExpCS.CallExpCS_1_0 returns BooleanExpCS
	 *     PrimaryExpCS returns BooleanExpCS
	 *     LiteralExpCS returns BooleanExpCS
	 *     BooleanLiteralExpCS returns BooleanExpCS
	 *
	 * Constraint:
	 *     boolSymbol?='true'?
	 */
	protected void sequence_BooleanLiteralExpCS(ISerializationContext context, BooleanExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpCS returns CallExpCS
	 *     LogicExpCS returns CallExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns CallExpCS
	 *     CallExpCS returns CallExpCS
	 *     CallExpCS.CallExpCS_1_0 returns CallExpCS
	 *
	 * Constraint:
	 *     (source=CallExpCS_CallExpCS_1_0 (op='.' | op='->') nameExp=NameExpCS)
	 */
	protected void sequence_CallExpCS(ISerializationContext context, CallExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassCS returns ClassCS
	 *
	 * Constraint:
	 *     (name=ID extends=PathNameCS? (properties+=PropertyCS | operations+=OperationCS)*)
	 */
	protected void sequence_ClassCS(ISerializationContext context, ClassCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintsDefCS returns ConstraintsDefCS
	 *
	 * Constraint:
	 *     (typeRef=PathNameCS invariants+=InvariantCS*)
	 */
	protected void sequence_ConstraintsDefCS(ISerializationContext context, ConstraintsDefCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpCS returns IntLiteralExpCS
	 *     LogicExpCS returns IntLiteralExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns IntLiteralExpCS
	 *     CallExpCS returns IntLiteralExpCS
	 *     CallExpCS.CallExpCS_1_0 returns IntLiteralExpCS
	 *     PrimaryExpCS returns IntLiteralExpCS
	 *     LiteralExpCS returns IntLiteralExpCS
	 *     IntLiteralExpCS returns IntLiteralExpCS
	 *
	 * Constraint:
	 *     intSymbol=INT
	 */
	protected void sequence_IntLiteralExpCS(ISerializationContext context, IntLiteralExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinioclcsPackage.Literals.INT_LITERAL_EXP_CS__INT_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinioclcsPackage.Literals.INT_LITERAL_EXP_CS__INT_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralExpCSAccess().getIntSymbolINTTerminalRuleCall_0(), semanticObject.getIntSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InvariantCS returns InvariantCS
	 *
	 * Constraint:
	 *     exp=ExpCS
	 */
	protected void sequence_InvariantCS(ISerializationContext context, InvariantCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinioclcsPackage.Literals.INVARIANT_CS__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinioclcsPackage.Literals.INVARIANT_CS__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInvariantCSAccess().getExpExpCSParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpCS returns LogicExpCS
	 *     LogicExpCS returns LogicExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns LogicExpCS
	 *
	 * Constraint:
	 *     (left=LogicExpCS_LogicExpCS_1_0 (op='=' | op='<>') right=CallExpCS)
	 */
	protected void sequence_LogicExpCS(ISerializationContext context, LogicExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpCS returns NameExpCS
	 *     LogicExpCS returns NameExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns NameExpCS
	 *     CallExpCS returns NameExpCS
	 *     CallExpCS.CallExpCS_1_0 returns NameExpCS
	 *     PrimaryExpCS returns NameExpCS
	 *     NameExpCS returns NameExpCS
	 *
	 * Constraint:
	 *     (expName=PathNameCS roundedBrackets=RoundedBracketClauseCS?)
	 */
	protected void sequence_NameExpCS(ISerializationContext context, NameExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationCS returns OperationCS
	 *
	 * Constraint:
	 *     (name=ID (params+=ParameterCS params+=ParameterCS*)? resultRef=PathNameCS body=ExpCS)
	 */
	protected void sequence_OperationCS(ISerializationContext context, OperationCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageCS returns PackageCS
	 *
	 * Constraint:
	 *     (name=ID (packages+=PackageCS | classes+=ClassCS)*)
	 */
	protected void sequence_PackageCS(ISerializationContext context, PackageCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterCS returns ParameterCS
	 *
	 * Constraint:
	 *     (name=ID typeRef=PathNameCS)
	 */
	protected void sequence_ParameterCS(ISerializationContext context, ParameterCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinioclcsPackage.Literals.PARAMETER_CS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinioclcsPackage.Literals.PARAMETER_CS__NAME));
			if (transientValues.isValueTransient(semanticObject, MinioclcsPackage.Literals.PARAMETER_CS__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinioclcsPackage.Literals.PARAMETER_CS__TYPE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterCSAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterCSAccess().getTypeRefPathNameCSParserRuleCall_2_0(), semanticObject.getTypeRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathElementCS returns PathElementCS
	 *
	 * Constraint:
	 *     elementName=ID
	 */
	protected void sequence_PathElementCS(ISerializationContext context, PathElementCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinioclcsPackage.Literals.PATH_ELEMENT_CS__ELEMENT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinioclcsPackage.Literals.PATH_ELEMENT_CS__ELEMENT_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathElementCSAccess().getElementNameIDTerminalRuleCall_0(), semanticObject.getElementName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathNameCS returns PathNameCS
	 *
	 * Constraint:
	 *     (path+=PathElementCS pathElements+=PathElementCS*)
	 */
	protected void sequence_PathNameCS(ISerializationContext context, PathNameCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyCS returns PropertyCS
	 *
	 * Constraint:
	 *     (name=ID typeRef=PathNameCS)
	 */
	protected void sequence_PropertyCS(ISerializationContext context, PropertyCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinioclcsPackage.Literals.PROPERTY_CS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinioclcsPackage.Literals.PROPERTY_CS__NAME));
			if (transientValues.isValueTransient(semanticObject, MinioclcsPackage.Literals.PROPERTY_CS__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinioclcsPackage.Literals.PROPERTY_CS__TYPE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyCSAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyCSAccess().getTypeRefPathNameCSParserRuleCall_3_0(), semanticObject.getTypeRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RootCS returns RootCS
	 *
	 * Constraint:
	 *     (packages+=PackageCS | contraints+=ConstraintsDefCS)+
	 */
	protected void sequence_RootCS(ISerializationContext context, RootCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RoundedBracketClauseCS returns RoundedBracketClauseCS
	 *
	 * Constraint:
	 *     (args+=ExpCS args+=ExpCS*)?
	 */
	protected void sequence_RoundedBracketClauseCS(ISerializationContext context, RoundedBracketClauseCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpCS returns StringLiteralExpCS
	 *     LogicExpCS returns StringLiteralExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns StringLiteralExpCS
	 *     CallExpCS returns StringLiteralExpCS
	 *     CallExpCS.CallExpCS_1_0 returns StringLiteralExpCS
	 *     PrimaryExpCS returns StringLiteralExpCS
	 *     LiteralExpCS returns StringLiteralExpCS
	 *     StringLiteralExpCS returns StringLiteralExpCS
	 *
	 * Constraint:
	 *     stringSymbol=STRING
	 */
	protected void sequence_StringLiteralExpCS(ISerializationContext context, StringLiteralExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinioclcsPackage.Literals.STRING_LITERAL_EXP_CS__STRING_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinioclcsPackage.Literals.STRING_LITERAL_EXP_CS__STRING_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpCSAccess().getStringSymbolSTRINGTerminalRuleCall_0(), semanticObject.getStringSymbol());
		feeder.finish();
	}
	
	
}
